{"version":3,"file":"BoundingSphere-f5553fb7.js","sources":["../../Source/Core/GeographicProjection.js","../../Source/Core/Interval.js","../../Source/Core/BoundingSphere.js"],"sourcesContent":["import Cartesian3 from './Cartesian3.js';\r\nimport Cartographic from './Cartographic.js';\r\nimport defaultValue from './defaultValue.js';\r\nimport defined from './defined.js';\r\nimport DeveloperError from './DeveloperError.js';\r\nimport Ellipsoid from './Ellipsoid.js';\r\n\r\n    /**\r\n     * A simple map projection where longitude and latitude are linearly mapped to X and Y by multiplying\r\n     * them by the {@link Ellipsoid#maximumRadius}.  This projection\r\n     * is commonly known as geographic, equirectangular, equidistant cylindrical, or plate carrÃ©e.  It\r\n     * is also known as EPSG:4326.\r\n     *\r\n     * @alias GeographicProjection\r\n     * @constructor\r\n     *\r\n     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid.\r\n     *\r\n     * @see WebMercatorProjection\r\n     */\r\n    function GeographicProjection(ellipsoid) {\r\n        this._ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\r\n        this._semimajorAxis = this._ellipsoid.maximumRadius;\r\n        this._oneOverSemimajorAxis = 1.0 / this._semimajorAxis;\r\n    }\r\n\r\n    Object.defineProperties(GeographicProjection.prototype, {\r\n        /**\r\n         * Gets the {@link Ellipsoid}.\r\n         *\r\n         * @memberof GeographicProjection.prototype\r\n         *\r\n         * @type {Ellipsoid}\r\n         * @readonly\r\n         */\r\n        ellipsoid : {\r\n            get : function() {\r\n                return this._ellipsoid;\r\n            }\r\n        }\r\n    });\r\n\r\n    /**\r\n     * Projects a set of {@link Cartographic} coordinates, in radians, to map coordinates, in meters.\r\n     * X and Y are the longitude and latitude, respectively, multiplied by the maximum radius of the\r\n     * ellipsoid.  Z is the unmodified height.\r\n     *\r\n     * @param {Cartographic} cartographic The coordinates to project.\r\n     * @param {Cartesian3} [result] An instance into which to copy the result.  If this parameter is\r\n     *        undefined, a new instance is created and returned.\r\n     * @returns {Cartesian3} The projected coordinates.  If the result parameter is not undefined, the\r\n     *          coordinates are copied there and that instance is returned.  Otherwise, a new instance is\r\n     *          created and returned.\r\n     */\r\n    GeographicProjection.prototype.project = function(cartographic, result) {\r\n        // Actually this is the special case of equidistant cylindrical called the plate carree\r\n        var semimajorAxis = this._semimajorAxis;\r\n        var x = cartographic.longitude * semimajorAxis;\r\n        var y = cartographic.latitude * semimajorAxis;\r\n        var z = cartographic.height;\r\n\r\n        if (!defined(result)) {\r\n            return new Cartesian3(x, y, z);\r\n        }\r\n\r\n        result.x = x;\r\n        result.y = y;\r\n        result.z = z;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Unprojects a set of projected {@link Cartesian3} coordinates, in meters, to {@link Cartographic}\r\n     * coordinates, in radians.  Longitude and Latitude are the X and Y coordinates, respectively,\r\n     * divided by the maximum radius of the ellipsoid.  Height is the unmodified Z coordinate.\r\n     *\r\n     * @param {Cartesian3} cartesian The Cartesian position to unproject with height (z) in meters.\r\n     * @param {Cartographic} [result] An instance into which to copy the result.  If this parameter is\r\n     *        undefined, a new instance is created and returned.\r\n     * @returns {Cartographic} The unprojected coordinates.  If the result parameter is not undefined, the\r\n     *          coordinates are copied there and that instance is returned.  Otherwise, a new instance is\r\n     *          created and returned.\r\n     */\r\n    GeographicProjection.prototype.unproject = function(cartesian, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(cartesian)) {\r\n            throw new DeveloperError('cartesian is required');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var oneOverEarthSemimajorAxis = this._oneOverSemimajorAxis;\r\n        var longitude = cartesian.x * oneOverEarthSemimajorAxis;\r\n        var latitude = cartesian.y * oneOverEarthSemimajorAxis;\r\n        var height = cartesian.z;\r\n\r\n        if (!defined(result)) {\r\n            return new Cartographic(longitude, latitude, height);\r\n        }\r\n\r\n        result.longitude = longitude;\r\n        result.latitude = latitude;\r\n        result.height = height;\r\n        return result;\r\n    };\r\nexport default GeographicProjection;\r\n","import defaultValue from './defaultValue.js';\r\n\r\n    /**\r\n     * Represents the closed interval [start, stop].\r\n     * @alias Interval\r\n     * @constructor\r\n     *\r\n     * @param {Number} [start=0.0] The beginning of the interval.\r\n     * @param {Number} [stop=0.0] The end of the interval.\r\n     */\r\n    function Interval(start, stop) {\r\n        /**\r\n         * The beginning of the interval.\r\n         * @type {Number}\r\n         * @default 0.0\r\n         */\r\n        this.start = defaultValue(start, 0.0);\r\n        /**\r\n         * The end of the interval.\r\n         * @type {Number}\r\n         * @default 0.0\r\n         */\r\n        this.stop = defaultValue(stop, 0.0);\r\n    }\r\nexport default Interval;\r\n","import Cartesian3 from './Cartesian3.js';\r\nimport Cartographic from './Cartographic.js';\r\nimport Check from './Check.js';\r\nimport defaultValue from './defaultValue.js';\r\nimport defined from './defined.js';\r\nimport Ellipsoid from './Ellipsoid.js';\r\nimport GeographicProjection from './GeographicProjection.js';\r\nimport Intersect from './Intersect.js';\r\nimport Interval from './Interval.js';\r\nimport CesiumMath from './Math.js';\r\nimport Matrix3 from './Matrix3.js';\r\nimport Matrix4 from './Matrix4.js';\r\nimport Rectangle from './Rectangle.js';\r\n\r\n    /**\r\n     * A bounding sphere with a center and a radius.\r\n     * @alias BoundingSphere\r\n     * @constructor\r\n     *\r\n     * @param {Cartesian3} [center=Cartesian3.ZERO] The center of the bounding sphere.\r\n     * @param {Number} [radius=0.0] The radius of the bounding sphere.\r\n     *\r\n     * @see AxisAlignedBoundingBox\r\n     * @see BoundingRectangle\r\n     * @see Packable\r\n     */\r\n    function BoundingSphere(center, radius) {\r\n        /**\r\n         * The center point of the sphere.\r\n         * @type {Cartesian3}\r\n         * @default {@link Cartesian3.ZERO}\r\n         */\r\n        this.center = Cartesian3.clone(defaultValue(center, Cartesian3.ZERO));\r\n\r\n        /**\r\n         * The radius of the sphere.\r\n         * @type {Number}\r\n         * @default 0.0\r\n         */\r\n        this.radius = defaultValue(radius, 0.0);\r\n    }\r\n\r\n    var fromPointsXMin = new Cartesian3();\r\n    var fromPointsYMin = new Cartesian3();\r\n    var fromPointsZMin = new Cartesian3();\r\n    var fromPointsXMax = new Cartesian3();\r\n    var fromPointsYMax = new Cartesian3();\r\n    var fromPointsZMax = new Cartesian3();\r\n    var fromPointsCurrentPos = new Cartesian3();\r\n    var fromPointsScratch = new Cartesian3();\r\n    var fromPointsRitterCenter = new Cartesian3();\r\n    var fromPointsMinBoxPt = new Cartesian3();\r\n    var fromPointsMaxBoxPt = new Cartesian3();\r\n    var fromPointsNaiveCenterScratch = new Cartesian3();\r\n    var volumeConstant = (4.0 / 3.0) * CesiumMath.PI;\r\n\r\n    /**\r\n     * Computes a tight-fitting bounding sphere enclosing a list of 3D Cartesian points.\r\n     * The bounding sphere is computed by running two algorithms, a naive algorithm and\r\n     * Ritter's algorithm. The smaller of the two spheres is used to ensure a tight fit.\r\n     *\r\n     * @param {Cartesian3[]} [positions] An array of points that the bounding sphere will enclose.  Each point must have <code>x</code>, <code>y</code>, and <code>z</code> properties.\r\n     * @param {BoundingSphere} [result] The object onto which to store the result.\r\n     * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if one was not provided.\r\n     *\r\n     * @see {@link http://help.agi.com/AGIComponents/html/BlogBoundingSphere.htm|Bounding Sphere computation article}\r\n     */\r\n    BoundingSphere.fromPoints = function(positions, result) {\r\n        if (!defined(result)) {\r\n            result = new BoundingSphere();\r\n        }\r\n\r\n        if (!defined(positions) || positions.length === 0) {\r\n            result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);\r\n            result.radius = 0.0;\r\n            return result;\r\n        }\r\n\r\n        var currentPos = Cartesian3.clone(positions[0], fromPointsCurrentPos);\r\n\r\n        var xMin = Cartesian3.clone(currentPos, fromPointsXMin);\r\n        var yMin = Cartesian3.clone(currentPos, fromPointsYMin);\r\n        var zMin = Cartesian3.clone(currentPos, fromPointsZMin);\r\n\r\n        var xMax = Cartesian3.clone(currentPos, fromPointsXMax);\r\n        var yMax = Cartesian3.clone(currentPos, fromPointsYMax);\r\n        var zMax = Cartesian3.clone(currentPos, fromPointsZMax);\r\n\r\n        var numPositions = positions.length;\r\n        var i;\r\n        for (i = 1; i < numPositions; i++) {\r\n            Cartesian3.clone(positions[i], currentPos);\r\n\r\n            var x = currentPos.x;\r\n            var y = currentPos.y;\r\n            var z = currentPos.z;\r\n\r\n            // Store points containing the the smallest and largest components\r\n            if (x < xMin.x) {\r\n                Cartesian3.clone(currentPos, xMin);\r\n            }\r\n\r\n            if (x > xMax.x) {\r\n                Cartesian3.clone(currentPos, xMax);\r\n            }\r\n\r\n            if (y < yMin.y) {\r\n                Cartesian3.clone(currentPos, yMin);\r\n            }\r\n\r\n            if (y > yMax.y) {\r\n                Cartesian3.clone(currentPos, yMax);\r\n            }\r\n\r\n            if (z < zMin.z) {\r\n                Cartesian3.clone(currentPos, zMin);\r\n            }\r\n\r\n            if (z > zMax.z) {\r\n                Cartesian3.clone(currentPos, zMax);\r\n            }\r\n        }\r\n\r\n        // Compute x-, y-, and z-spans (Squared distances b/n each component's min. and max.).\r\n        var xSpan = Cartesian3.magnitudeSquared(Cartesian3.subtract(xMax, xMin, fromPointsScratch));\r\n        var ySpan = Cartesian3.magnitudeSquared(Cartesian3.subtract(yMax, yMin, fromPointsScratch));\r\n        var zSpan = Cartesian3.magnitudeSquared(Cartesian3.subtract(zMax, zMin, fromPointsScratch));\r\n\r\n        // Set the diameter endpoints to the largest span.\r\n        var diameter1 = xMin;\r\n        var diameter2 = xMax;\r\n        var maxSpan = xSpan;\r\n        if (ySpan > maxSpan) {\r\n            maxSpan = ySpan;\r\n            diameter1 = yMin;\r\n            diameter2 = yMax;\r\n        }\r\n        if (zSpan > maxSpan) {\r\n            maxSpan = zSpan;\r\n            diameter1 = zMin;\r\n            diameter2 = zMax;\r\n        }\r\n\r\n        // Calculate the center of the initial sphere found by Ritter's algorithm\r\n        var ritterCenter = fromPointsRitterCenter;\r\n        ritterCenter.x = (diameter1.x + diameter2.x) * 0.5;\r\n        ritterCenter.y = (diameter1.y + diameter2.y) * 0.5;\r\n        ritterCenter.z = (diameter1.z + diameter2.z) * 0.5;\r\n\r\n        // Calculate the radius of the initial sphere found by Ritter's algorithm\r\n        var radiusSquared = Cartesian3.magnitudeSquared(Cartesian3.subtract(diameter2, ritterCenter, fromPointsScratch));\r\n        var ritterRadius = Math.sqrt(radiusSquared);\r\n\r\n        // Find the center of the sphere found using the Naive method.\r\n        var minBoxPt = fromPointsMinBoxPt;\r\n        minBoxPt.x = xMin.x;\r\n        minBoxPt.y = yMin.y;\r\n        minBoxPt.z = zMin.z;\r\n\r\n        var maxBoxPt = fromPointsMaxBoxPt;\r\n        maxBoxPt.x = xMax.x;\r\n        maxBoxPt.y = yMax.y;\r\n        maxBoxPt.z = zMax.z;\r\n\r\n        var naiveCenter = Cartesian3.midpoint(minBoxPt, maxBoxPt, fromPointsNaiveCenterScratch);\r\n\r\n        // Begin 2nd pass to find naive radius and modify the ritter sphere.\r\n        var naiveRadius = 0;\r\n        for (i = 0; i < numPositions; i++) {\r\n            Cartesian3.clone(positions[i], currentPos);\r\n\r\n            // Find the furthest point from the naive center to calculate the naive radius.\r\n            var r = Cartesian3.magnitude(Cartesian3.subtract(currentPos, naiveCenter, fromPointsScratch));\r\n            if (r > naiveRadius) {\r\n                naiveRadius = r;\r\n            }\r\n\r\n            // Make adjustments to the Ritter Sphere to include all points.\r\n            var oldCenterToPointSquared = Cartesian3.magnitudeSquared(Cartesian3.subtract(currentPos, ritterCenter, fromPointsScratch));\r\n            if (oldCenterToPointSquared > radiusSquared) {\r\n                var oldCenterToPoint = Math.sqrt(oldCenterToPointSquared);\r\n                // Calculate new radius to include the point that lies outside\r\n                ritterRadius = (ritterRadius + oldCenterToPoint) * 0.5;\r\n                radiusSquared = ritterRadius * ritterRadius;\r\n                // Calculate center of new Ritter sphere\r\n                var oldToNew = oldCenterToPoint - ritterRadius;\r\n                ritterCenter.x = (ritterRadius * ritterCenter.x + oldToNew * currentPos.x) / oldCenterToPoint;\r\n                ritterCenter.y = (ritterRadius * ritterCenter.y + oldToNew * currentPos.y) / oldCenterToPoint;\r\n                ritterCenter.z = (ritterRadius * ritterCenter.z + oldToNew * currentPos.z) / oldCenterToPoint;\r\n            }\r\n        }\r\n\r\n        if (ritterRadius < naiveRadius) {\r\n            Cartesian3.clone(ritterCenter, result.center);\r\n            result.radius = ritterRadius;\r\n        } else {\r\n            Cartesian3.clone(naiveCenter, result.center);\r\n            result.radius = naiveRadius;\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    BoundingSphere.fromInstancePoints = function(positions, result, numPositions) {\r\n    if (!defined(result)) {\r\n        result = new BoundingSphere();\r\n    }\r\n\r\n    if (!defined(positions) || numPositions === 0) {\r\n        result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);\r\n        result.radius = 0.0;\r\n        return result;\r\n    }\r\n\r\n    var currentPos = Cartesian3.clone(positions[0], fromPointsCurrentPos);\r\n\r\n    var xMin = Cartesian3.clone(currentPos, fromPointsXMin);\r\n    var yMin = Cartesian3.clone(currentPos, fromPointsYMin);\r\n    var zMin = Cartesian3.clone(currentPos, fromPointsZMin);\r\n\r\n    var xMax = Cartesian3.clone(currentPos, fromPointsXMax);\r\n    var yMax = Cartesian3.clone(currentPos, fromPointsYMax);\r\n    var zMax = Cartesian3.clone(currentPos, fromPointsZMax);\r\n\r\n    var i;\r\n    for (i = 1; i < numPositions; i++) {\r\n        Cartesian3.clone(positions[i], currentPos);\r\n\r\n        var x = currentPos.x;\r\n        var y = currentPos.y;\r\n        var z = currentPos.z;\r\n\r\n        // Store points containing the the smallest and largest components\r\n        if (x < xMin.x) {\r\n            Cartesian3.clone(currentPos, xMin);\r\n        }\r\n\r\n        if (x > xMax.x) {\r\n            Cartesian3.clone(currentPos, xMax);\r\n        }\r\n\r\n        if (y < yMin.y) {\r\n            Cartesian3.clone(currentPos, yMin);\r\n        }\r\n\r\n        if (y > yMax.y) {\r\n            Cartesian3.clone(currentPos, yMax);\r\n        }\r\n\r\n        if (z < zMin.z) {\r\n            Cartesian3.clone(currentPos, zMin);\r\n        }\r\n\r\n        if (z > zMax.z) {\r\n            Cartesian3.clone(currentPos, zMax);\r\n        }\r\n    }\r\n\r\n    // Compute x-, y-, and z-spans (Squared distances b/n each component's min. and max.).\r\n    var xSpan = Cartesian3.magnitudeSquared(Cartesian3.subtract(xMax, xMin, fromPointsScratch));\r\n    var ySpan = Cartesian3.magnitudeSquared(Cartesian3.subtract(yMax, yMin, fromPointsScratch));\r\n    var zSpan = Cartesian3.magnitudeSquared(Cartesian3.subtract(zMax, zMin, fromPointsScratch));\r\n\r\n    // Set the diameter endpoints to the largest span.\r\n    var diameter1 = xMin;\r\n    var diameter2 = xMax;\r\n    var maxSpan = xSpan;\r\n    if (ySpan > maxSpan) {\r\n        maxSpan = ySpan;\r\n        diameter1 = yMin;\r\n        diameter2 = yMax;\r\n    }\r\n    if (zSpan > maxSpan) {\r\n        maxSpan = zSpan;\r\n        diameter1 = zMin;\r\n        diameter2 = zMax;\r\n    }\r\n\r\n    // Calculate the center of the initial sphere found by Ritter's algorithm\r\n    var ritterCenter = fromPointsRitterCenter;\r\n    ritterCenter.x = (diameter1.x + diameter2.x) * 0.5;\r\n    ritterCenter.y = (diameter1.y + diameter2.y) * 0.5;\r\n    ritterCenter.z = (diameter1.z + diameter2.z) * 0.5;\r\n\r\n    // Calculate the radius of the initial sphere found by Ritter's algorithm\r\n    var radiusSquared = Cartesian3.magnitudeSquared(Cartesian3.subtract(diameter2, ritterCenter, fromPointsScratch));\r\n    var ritterRadius = Math.sqrt(radiusSquared);\r\n\r\n    // Find the center of the sphere found using the Naive method.\r\n    var minBoxPt = fromPointsMinBoxPt;\r\n    minBoxPt.x = xMin.x;\r\n    minBoxPt.y = yMin.y;\r\n    minBoxPt.z = zMin.z;\r\n\r\n    var maxBoxPt = fromPointsMaxBoxPt;\r\n    maxBoxPt.x = xMax.x;\r\n    maxBoxPt.y = yMax.y;\r\n    maxBoxPt.z = zMax.z;\r\n\r\n    var naiveCenter = Cartesian3.midpoint(minBoxPt, maxBoxPt, fromPointsNaiveCenterScratch);\r\n\r\n    // Begin 2nd pass to find naive radius and modify the ritter sphere.\r\n    var naiveRadius = 0;\r\n    for (i = 0; i < numPositions; i++) {\r\n        Cartesian3.clone(positions[i], currentPos);\r\n\r\n        // Find the furthest point from the naive center to calculate the naive radius.\r\n        var r = Cartesian3.magnitude(Cartesian3.subtract(currentPos, naiveCenter, fromPointsScratch));\r\n        if (r > naiveRadius) {\r\n            naiveRadius = r;\r\n        }\r\n\r\n        // Make adjustments to the Ritter Sphere to include all points.\r\n        var oldCenterToPointSquared = Cartesian3.magnitudeSquared(Cartesian3.subtract(currentPos, ritterCenter, fromPointsScratch));\r\n        if (oldCenterToPointSquared > radiusSquared) {\r\n            var oldCenterToPoint = Math.sqrt(oldCenterToPointSquared);\r\n            // Calculate new radius to include the point that lies outside\r\n            ritterRadius = (ritterRadius + oldCenterToPoint) * 0.5;\r\n            radiusSquared = ritterRadius * ritterRadius;\r\n            // Calculate center of new Ritter sphere\r\n            var oldToNew = oldCenterToPoint - ritterRadius;\r\n            ritterCenter.x = (ritterRadius * ritterCenter.x + oldToNew * currentPos.x) / oldCenterToPoint;\r\n            ritterCenter.y = (ritterRadius * ritterCenter.y + oldToNew * currentPos.y) / oldCenterToPoint;\r\n            ritterCenter.z = (ritterRadius * ritterCenter.z + oldToNew * currentPos.z) / oldCenterToPoint;\r\n        }\r\n    }\r\n\r\n    if (ritterRadius < naiveRadius) {\r\n        Cartesian3.clone(ritterCenter, result.center);\r\n        result.radius = ritterRadius;\r\n    } else {\r\n        Cartesian3.clone(naiveCenter, result.center);\r\n        result.radius = naiveRadius;\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\n/**\r\n * å¤æ­ä¸¤ä¸ªç¹æ¯å¦ç¸äº¤\r\n * @param {BoundingSphere} boundingLeft\r\n * @param {BoundingSphere} boundingRight\r\n * @returns {Boolean}\r\n */\r\n    BoundingSphere.isIntersect = function(boundingLeft, boundingRight){\r\n        let distance = Cartesian3.distance(boundingLeft.center, boundingRight.center);\r\n        if (distance > boundingLeft.radius + boundingRight.radius){\r\n            return false;\r\n        }\r\n        return true;\r\n    };\r\n/**\r\n * åä¸ä¸ªåå´çæ¯å¦å¨åä¸ä¸ªåå´çåé¨\r\n * @param {BoundingSphere} boundingOuter\r\n * @param {BoundingSphere} boundingInner\r\n * @returns {Boolean}\r\n */\r\n    BoundingSphere.isInclude = function(boundingOuter, boundingInner){\r\n        let distance = Cartesian3.distance(boundingOuter.center, boundingInner.center);\r\n        if ( boundingOuter.radius > distance + boundingInner.radius){\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n\r\n    var defaultProjection = new GeographicProjection();\r\n    var fromRectangle2DLowerLeft = new Cartesian3();\r\n    var fromRectangle2DUpperRight = new Cartesian3();\r\n    var fromRectangle2DSouthwest = new Cartographic();\r\n    var fromRectangle2DNortheast = new Cartographic();\r\n\r\n    /**\r\n     * Computes a bounding sphere from a rectangle projected in 2D.\r\n     *\r\n     * @param {Rectangle} [rectangle] The rectangle around which to create a bounding sphere.\r\n     * @param {Object} [projection=GeographicProjection] The projection used to project the rectangle into 2D.\r\n     * @param {BoundingSphere} [result] The object onto which to store the result.\r\n     * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\r\n     */\r\n    BoundingSphere.fromRectangle2D = function(rectangle, projection, result) {\r\n        return BoundingSphere.fromRectangleWithHeights2D(rectangle, projection, 0.0, 0.0, result);\r\n    };\r\n\r\n    /**\r\n     * Computes a bounding sphere from a rectangle projected in 2D.  The bounding sphere accounts for the\r\n     * object's minimum and maximum heights over the rectangle.\r\n     *\r\n     * @param {Rectangle} [rectangle] The rectangle around which to create a bounding sphere.\r\n     * @param {Object} [projection=GeographicProjection] The projection used to project the rectangle into 2D.\r\n     * @param {Number} [minimumHeight=0.0] The minimum height over the rectangle.\r\n     * @param {Number} [maximumHeight=0.0] The maximum height over the rectangle.\r\n     * @param {BoundingSphere} [result] The object onto which to store the result.\r\n     * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\r\n     */\r\n    BoundingSphere.fromRectangleWithHeights2D = function(rectangle, projection, minimumHeight, maximumHeight, result) {\r\n        if (!defined(result)) {\r\n            result = new BoundingSphere();\r\n        }\r\n\r\n        if (!defined(rectangle)) {\r\n            result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);\r\n            result.radius = 0.0;\r\n            return result;\r\n        }\r\n\r\n        projection = defaultValue(projection, defaultProjection);\r\n\r\n        Rectangle.southwest(rectangle, fromRectangle2DSouthwest);\r\n        fromRectangle2DSouthwest.height = minimumHeight;\r\n        Rectangle.northeast(rectangle, fromRectangle2DNortheast);\r\n        fromRectangle2DNortheast.height = maximumHeight;\r\n\r\n        var lowerLeft = projection.project(fromRectangle2DSouthwest, fromRectangle2DLowerLeft);\r\n        var upperRight = projection.project(fromRectangle2DNortheast, fromRectangle2DUpperRight);\r\n\r\n        var width = upperRight.x - lowerLeft.x;\r\n        var height = upperRight.y - lowerLeft.y;\r\n        var elevation = upperRight.z - lowerLeft.z;\r\n\r\n        result.radius = Math.sqrt(width * width + height * height + elevation * elevation) * 0.5;\r\n        var center = result.center;\r\n        center.x = lowerLeft.x + width * 0.5;\r\n        center.y = lowerLeft.y + height * 0.5;\r\n        center.z = lowerLeft.z + elevation * 0.5;\r\n        return result;\r\n    };\r\n\r\n    var fromRectangle3DScratch = [];\r\n\r\n    /**\r\n     * Computes a bounding sphere from a rectangle in 3D. The bounding sphere is created using a subsample of points\r\n     * on the ellipsoid and contained in the rectangle. It may not be accurate for all rectangles on all types of ellipsoids.\r\n     *\r\n     * @param {Rectangle} [rectangle] The valid rectangle used to create a bounding sphere.\r\n     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid used to determine positions of the rectangle.\r\n     * @param {Number} [surfaceHeight=0.0] The height above the surface of the ellipsoid.\r\n     * @param {BoundingSphere} [result] The object onto which to store the result.\r\n     * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\r\n     */\r\n    BoundingSphere.fromRectangle3D = function(rectangle, ellipsoid, surfaceHeight, result) {\r\n        ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\r\n        surfaceHeight = defaultValue(surfaceHeight, 0.0);\r\n\r\n        if (!defined(result)) {\r\n            result = new BoundingSphere();\r\n        }\r\n\r\n        if (!defined(rectangle)) {\r\n            result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);\r\n            result.radius = 0.0;\r\n            return result;\r\n        }\r\n\r\n        var positions = Rectangle.subsample(rectangle, ellipsoid, surfaceHeight, fromRectangle3DScratch);\r\n        return BoundingSphere.fromPoints(positions, result);\r\n    };\r\n\r\n    /**\r\n     * Computes a tight-fitting bounding sphere enclosing a list of 3D points, where the points are\r\n     * stored in a flat array in X, Y, Z, order.  The bounding sphere is computed by running two\r\n     * algorithms, a naive algorithm and Ritter's algorithm. The smaller of the two spheres is used to\r\n     * ensure a tight fit.\r\n     *\r\n     * @param {Number[]} [positions] An array of points that the bounding sphere will enclose.  Each point\r\n     *        is formed from three elements in the array in the order X, Y, Z.\r\n     * @param {Cartesian3} [center=Cartesian3.ZERO] The position to which the positions are relative, which need not be the\r\n     *        origin of the coordinate system.  This is useful when the positions are to be used for\r\n     *        relative-to-center (RTC) rendering.\r\n     * @param {Number} [stride=3] The number of array elements per vertex.  It must be at least 3, but it may\r\n     *        be higher.  Regardless of the value of this parameter, the X coordinate of the first position\r\n     *        is at array index 0, the Y coordinate is at array index 1, and the Z coordinate is at array index\r\n     *        2.  When stride is 3, the X coordinate of the next position then begins at array index 3.  If\r\n     *        the stride is 5, however, two array elements are skipped and the next position begins at array\r\n     *        index 5.\r\n     * @param {BoundingSphere} [result] The object onto which to store the result.\r\n     * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if one was not provided.\r\n     *\r\n     * @example\r\n     * // Compute the bounding sphere from 3 positions, each specified relative to a center.\r\n     * // In addition to the X, Y, and Z coordinates, the points array contains two additional\r\n     * // elements per point which are ignored for the purpose of computing the bounding sphere.\r\n     * var center = new Cesium.Cartesian3(1.0, 2.0, 3.0);\r\n     * var points = [1.0, 2.0, 3.0, 0.1, 0.2,\r\n     *               4.0, 5.0, 6.0, 0.1, 0.2,\r\n     *               7.0, 8.0, 9.0, 0.1, 0.2];\r\n     * var sphere = Cesium.BoundingSphere.fromVertices(points, center, 5);\r\n     *\r\n     * @see {@link http://blogs.agi.com/insight3d/index.php/2008/02/04/a-bounding/|Bounding Sphere computation article}\r\n     */\r\n    BoundingSphere.fromVertices = function(positions, center, stride, result) {\r\n        if (!defined(result)) {\r\n            result = new BoundingSphere();\r\n        }\r\n\r\n        if (!defined(positions) || positions.length === 0) {\r\n            result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);\r\n            result.radius = 0.0;\r\n            return result;\r\n        }\r\n\r\n        center = defaultValue(center, Cartesian3.ZERO);\r\n\r\n        stride = defaultValue(stride, 3);\r\n\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.number.greaterThanOrEquals('stride', stride, 3);\r\n        //>>includeEnd('debug');\r\n\r\n        var currentPos = fromPointsCurrentPos;\r\n        currentPos.x = positions[0] + center.x;\r\n        currentPos.y = positions[1] + center.y;\r\n        currentPos.z = positions[2] + center.z;\r\n\r\n        var xMin = Cartesian3.clone(currentPos, fromPointsXMin);\r\n        var yMin = Cartesian3.clone(currentPos, fromPointsYMin);\r\n        var zMin = Cartesian3.clone(currentPos, fromPointsZMin);\r\n\r\n        var xMax = Cartesian3.clone(currentPos, fromPointsXMax);\r\n        var yMax = Cartesian3.clone(currentPos, fromPointsYMax);\r\n        var zMax = Cartesian3.clone(currentPos, fromPointsZMax);\r\n\r\n        var numElements = positions.length;\r\n        var i;\r\n        for (i = 0; i < numElements; i += stride) {\r\n            var x = positions[i] + center.x;\r\n            var y = positions[i + 1] + center.y;\r\n            var z = positions[i + 2] + center.z;\r\n\r\n            currentPos.x = x;\r\n            currentPos.y = y;\r\n            currentPos.z = z;\r\n\r\n            // Store points containing the the smallest and largest components\r\n            if (x < xMin.x) {\r\n                Cartesian3.clone(currentPos, xMin);\r\n            }\r\n\r\n            if (x > xMax.x) {\r\n                Cartesian3.clone(currentPos, xMax);\r\n            }\r\n\r\n            if (y < yMin.y) {\r\n                Cartesian3.clone(currentPos, yMin);\r\n            }\r\n\r\n            if (y > yMax.y) {\r\n                Cartesian3.clone(currentPos, yMax);\r\n            }\r\n\r\n            if (z < zMin.z) {\r\n                Cartesian3.clone(currentPos, zMin);\r\n            }\r\n\r\n            if (z > zMax.z) {\r\n                Cartesian3.clone(currentPos, zMax);\r\n            }\r\n        }\r\n\r\n        // Compute x-, y-, and z-spans (Squared distances b/n each component's min. and max.).\r\n        var xSpan = Cartesian3.magnitudeSquared(Cartesian3.subtract(xMax, xMin, fromPointsScratch));\r\n        var ySpan = Cartesian3.magnitudeSquared(Cartesian3.subtract(yMax, yMin, fromPointsScratch));\r\n        var zSpan = Cartesian3.magnitudeSquared(Cartesian3.subtract(zMax, zMin, fromPointsScratch));\r\n\r\n        // Set the diameter endpoints to the largest span.\r\n        var diameter1 = xMin;\r\n        var diameter2 = xMax;\r\n        var maxSpan = xSpan;\r\n        if (ySpan > maxSpan) {\r\n            maxSpan = ySpan;\r\n            diameter1 = yMin;\r\n            diameter2 = yMax;\r\n        }\r\n        if (zSpan > maxSpan) {\r\n            maxSpan = zSpan;\r\n            diameter1 = zMin;\r\n            diameter2 = zMax;\r\n        }\r\n\r\n        // Calculate the center of the initial sphere found by Ritter's algorithm\r\n        var ritterCenter = fromPointsRitterCenter;\r\n        ritterCenter.x = (diameter1.x + diameter2.x) * 0.5;\r\n        ritterCenter.y = (diameter1.y + diameter2.y) * 0.5;\r\n        ritterCenter.z = (diameter1.z + diameter2.z) * 0.5;\r\n\r\n        // Calculate the radius of the initial sphere found by Ritter's algorithm\r\n        var radiusSquared = Cartesian3.magnitudeSquared(Cartesian3.subtract(diameter2, ritterCenter, fromPointsScratch));\r\n        var ritterRadius = Math.sqrt(radiusSquared);\r\n\r\n        // Find the center of the sphere found using the Naive method.\r\n        var minBoxPt = fromPointsMinBoxPt;\r\n        minBoxPt.x = xMin.x;\r\n        minBoxPt.y = yMin.y;\r\n        minBoxPt.z = zMin.z;\r\n\r\n        var maxBoxPt = fromPointsMaxBoxPt;\r\n        maxBoxPt.x = xMax.x;\r\n        maxBoxPt.y = yMax.y;\r\n        maxBoxPt.z = zMax.z;\r\n\r\n        var naiveCenter = Cartesian3.midpoint(minBoxPt, maxBoxPt, fromPointsNaiveCenterScratch);\r\n\r\n        // Begin 2nd pass to find naive radius and modify the ritter sphere.\r\n        var naiveRadius = 0;\r\n        for (i = 0; i < numElements; i += stride) {\r\n            currentPos.x = positions[i] + center.x;\r\n            currentPos.y = positions[i + 1] + center.y;\r\n            currentPos.z = positions[i + 2] + center.z;\r\n\r\n            // Find the furthest point from the naive center to calculate the naive radius.\r\n            var r = Cartesian3.magnitude(Cartesian3.subtract(currentPos, naiveCenter, fromPointsScratch));\r\n            if (r > naiveRadius) {\r\n                naiveRadius = r;\r\n            }\r\n\r\n            // Make adjustments to the Ritter Sphere to include all points.\r\n            var oldCenterToPointSquared = Cartesian3.magnitudeSquared(Cartesian3.subtract(currentPos, ritterCenter, fromPointsScratch));\r\n            if (oldCenterToPointSquared > radiusSquared) {\r\n                var oldCenterToPoint = Math.sqrt(oldCenterToPointSquared);\r\n                // Calculate new radius to include the point that lies outside\r\n                ritterRadius = (ritterRadius + oldCenterToPoint) * 0.5;\r\n                radiusSquared = ritterRadius * ritterRadius;\r\n                // Calculate center of new Ritter sphere\r\n                var oldToNew = oldCenterToPoint - ritterRadius;\r\n                ritterCenter.x = (ritterRadius * ritterCenter.x + oldToNew * currentPos.x) / oldCenterToPoint;\r\n                ritterCenter.y = (ritterRadius * ritterCenter.y + oldToNew * currentPos.y) / oldCenterToPoint;\r\n                ritterCenter.z = (ritterRadius * ritterCenter.z + oldToNew * currentPos.z) / oldCenterToPoint;\r\n            }\r\n        }\r\n\r\n        if (ritterRadius < naiveRadius) {\r\n            Cartesian3.clone(ritterCenter, result.center);\r\n            result.radius = ritterRadius;\r\n        } else {\r\n            Cartesian3.clone(naiveCenter, result.center);\r\n            result.radius = naiveRadius;\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Computes a tight-fitting bounding sphere enclosing a list of EncodedCartesian3s, where the points are\r\n     * stored in parallel flat arrays in X, Y, Z, order.  The bounding sphere is computed by running two\r\n     * algorithms, a naive algorithm and Ritter's algorithm. The smaller of the two spheres is used to\r\n     * ensure a tight fit.\r\n     *\r\n     * @param {Number[]} [positionsHigh] An array of high bits of the encoded cartesians that the bounding sphere will enclose.  Each point\r\n     *        is formed from three elements in the array in the order X, Y, Z.\r\n     * @param {Number[]} [positionsLow] An array of low bits of the encoded cartesians that the bounding sphere will enclose.  Each point\r\n     *        is formed from three elements in the array in the order X, Y, Z.\r\n     * @param {BoundingSphere} [result] The object onto which to store the result.\r\n     * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if one was not provided.\r\n     *\r\n     * @see {@link http://blogs.agi.com/insight3d/index.php/2008/02/04/a-bounding/|Bounding Sphere computation article}\r\n     */\r\n    BoundingSphere.fromEncodedCartesianVertices = function(positionsHigh, positionsLow, result) {\r\n        if (!defined(result)) {\r\n            result = new BoundingSphere();\r\n        }\r\n\r\n        if (!defined(positionsHigh) || !defined(positionsLow) || positionsHigh.length !== positionsLow.length || positionsHigh.length === 0) {\r\n            result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);\r\n            result.radius = 0.0;\r\n            return result;\r\n        }\r\n\r\n        var currentPos = fromPointsCurrentPos;\r\n        currentPos.x = positionsHigh[0] + positionsLow[0];\r\n        currentPos.y = positionsHigh[1] + positionsLow[1];\r\n        currentPos.z = positionsHigh[2] + positionsLow[2];\r\n\r\n        var xMin = Cartesian3.clone(currentPos, fromPointsXMin);\r\n        var yMin = Cartesian3.clone(currentPos, fromPointsYMin);\r\n        var zMin = Cartesian3.clone(currentPos, fromPointsZMin);\r\n\r\n        var xMax = Cartesian3.clone(currentPos, fromPointsXMax);\r\n        var yMax = Cartesian3.clone(currentPos, fromPointsYMax);\r\n        var zMax = Cartesian3.clone(currentPos, fromPointsZMax);\r\n\r\n        var numElements = positionsHigh.length;\r\n        var i;\r\n        for (i = 0; i < numElements; i += 3) {\r\n            var x = positionsHigh[i] + positionsLow[i];\r\n            var y = positionsHigh[i + 1] + positionsLow[i + 1];\r\n            var z = positionsHigh[i + 2] + positionsLow[i + 2];\r\n\r\n            currentPos.x = x;\r\n            currentPos.y = y;\r\n            currentPos.z = z;\r\n\r\n            // Store points containing the the smallest and largest components\r\n            if (x < xMin.x) {\r\n                Cartesian3.clone(currentPos, xMin);\r\n            }\r\n\r\n            if (x > xMax.x) {\r\n                Cartesian3.clone(currentPos, xMax);\r\n            }\r\n\r\n            if (y < yMin.y) {\r\n                Cartesian3.clone(currentPos, yMin);\r\n            }\r\n\r\n            if (y > yMax.y) {\r\n                Cartesian3.clone(currentPos, yMax);\r\n            }\r\n\r\n            if (z < zMin.z) {\r\n                Cartesian3.clone(currentPos, zMin);\r\n            }\r\n\r\n            if (z > zMax.z) {\r\n                Cartesian3.clone(currentPos, zMax);\r\n            }\r\n        }\r\n\r\n        // Compute x-, y-, and z-spans (Squared distances b/n each component's min. and max.).\r\n        var xSpan = Cartesian3.magnitudeSquared(Cartesian3.subtract(xMax, xMin, fromPointsScratch));\r\n        var ySpan = Cartesian3.magnitudeSquared(Cartesian3.subtract(yMax, yMin, fromPointsScratch));\r\n        var zSpan = Cartesian3.magnitudeSquared(Cartesian3.subtract(zMax, zMin, fromPointsScratch));\r\n\r\n        // Set the diameter endpoints to the largest span.\r\n        var diameter1 = xMin;\r\n        var diameter2 = xMax;\r\n        var maxSpan = xSpan;\r\n        if (ySpan > maxSpan) {\r\n            maxSpan = ySpan;\r\n            diameter1 = yMin;\r\n            diameter2 = yMax;\r\n        }\r\n        if (zSpan > maxSpan) {\r\n            maxSpan = zSpan;\r\n            diameter1 = zMin;\r\n            diameter2 = zMax;\r\n        }\r\n\r\n        // Calculate the center of the initial sphere found by Ritter's algorithm\r\n        var ritterCenter = fromPointsRitterCenter;\r\n        ritterCenter.x = (diameter1.x + diameter2.x) * 0.5;\r\n        ritterCenter.y = (diameter1.y + diameter2.y) * 0.5;\r\n        ritterCenter.z = (diameter1.z + diameter2.z) * 0.5;\r\n\r\n        // Calculate the radius of the initial sphere found by Ritter's algorithm\r\n        var radiusSquared = Cartesian3.magnitudeSquared(Cartesian3.subtract(diameter2, ritterCenter, fromPointsScratch));\r\n        var ritterRadius = Math.sqrt(radiusSquared);\r\n\r\n        // Find the center of the sphere found using the Naive method.\r\n        var minBoxPt = fromPointsMinBoxPt;\r\n        minBoxPt.x = xMin.x;\r\n        minBoxPt.y = yMin.y;\r\n        minBoxPt.z = zMin.z;\r\n\r\n        var maxBoxPt = fromPointsMaxBoxPt;\r\n        maxBoxPt.x = xMax.x;\r\n        maxBoxPt.y = yMax.y;\r\n        maxBoxPt.z = zMax.z;\r\n\r\n        var naiveCenter = Cartesian3.midpoint(minBoxPt, maxBoxPt, fromPointsNaiveCenterScratch);\r\n\r\n        // Begin 2nd pass to find naive radius and modify the ritter sphere.\r\n        var naiveRadius = 0;\r\n        for (i = 0; i < numElements; i += 3) {\r\n            currentPos.x = positionsHigh[i] + positionsLow[i];\r\n            currentPos.y = positionsHigh[i + 1] + positionsLow[i + 1];\r\n            currentPos.z = positionsHigh[i + 2] + positionsLow[i + 2];\r\n\r\n            // Find the furthest point from the naive center to calculate the naive radius.\r\n            var r = Cartesian3.magnitude(Cartesian3.subtract(currentPos, naiveCenter, fromPointsScratch));\r\n            if (r > naiveRadius) {\r\n                naiveRadius = r;\r\n            }\r\n\r\n            // Make adjustments to the Ritter Sphere to include all points.\r\n            var oldCenterToPointSquared = Cartesian3.magnitudeSquared(Cartesian3.subtract(currentPos, ritterCenter, fromPointsScratch));\r\n            if (oldCenterToPointSquared > radiusSquared) {\r\n                var oldCenterToPoint = Math.sqrt(oldCenterToPointSquared);\r\n                // Calculate new radius to include the point that lies outside\r\n                ritterRadius = (ritterRadius + oldCenterToPoint) * 0.5;\r\n                radiusSquared = ritterRadius * ritterRadius;\r\n                // Calculate center of new Ritter sphere\r\n                var oldToNew = oldCenterToPoint - ritterRadius;\r\n                ritterCenter.x = (ritterRadius * ritterCenter.x + oldToNew * currentPos.x) / oldCenterToPoint;\r\n                ritterCenter.y = (ritterRadius * ritterCenter.y + oldToNew * currentPos.y) / oldCenterToPoint;\r\n                ritterCenter.z = (ritterRadius * ritterCenter.z + oldToNew * currentPos.z) / oldCenterToPoint;\r\n            }\r\n        }\r\n\r\n        if (ritterRadius < naiveRadius) {\r\n            Cartesian3.clone(ritterCenter, result.center);\r\n            result.radius = ritterRadius;\r\n        } else {\r\n            Cartesian3.clone(naiveCenter, result.center);\r\n            result.radius = naiveRadius;\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Computes a bounding sphere from the corner points of an axis-aligned bounding box.  The sphere\r\n     * tighly and fully encompases the box.\r\n     *\r\n     * @param {Cartesian3} [corner] The minimum height over the rectangle.\r\n     * @param {Cartesian3} [oppositeCorner] The maximum height over the rectangle.\r\n     * @param {BoundingSphere} [result] The object onto which to store the result.\r\n     * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\r\n     *\r\n     * @example\r\n     * // Create a bounding sphere around the unit cube\r\n     * var sphere = Cesium.BoundingSphere.fromCornerPoints(new Cesium.Cartesian3(-0.5, -0.5, -0.5), new Cesium.Cartesian3(0.5, 0.5, 0.5));\r\n     */\r\n    BoundingSphere.fromCornerPoints = function(corner, oppositeCorner, result) {\r\n        if (!defined(result)) {\r\n            result = new BoundingSphere();\r\n        }\r\n\r\n        var center = Cartesian3.midpoint(corner, oppositeCorner, result.center);\r\n        result.radius = Cartesian3.distance(center, oppositeCorner);\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Creates a bounding sphere encompassing an ellipsoid.\r\n     *\r\n     * @param {Ellipsoid} ellipsoid The ellipsoid around which to create a bounding sphere.\r\n     * @param {BoundingSphere} [result] The object onto which to store the result.\r\n     * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\r\n     *\r\n     * @example\r\n     * var boundingSphere = Cesium.BoundingSphere.fromEllipsoid(ellipsoid);\r\n     */\r\n    BoundingSphere.fromEllipsoid = function(ellipsoid, result) {\r\n        if (!defined(result)) {\r\n            result = new BoundingSphere();\r\n        }\r\n\r\n        Cartesian3.clone(Cartesian3.ZERO, result.center);\r\n        result.radius = ellipsoid.maximumRadius;\r\n        return result;\r\n    };\r\n\r\n    var fromBoundingSpheresScratch = new Cartesian3();\r\n\r\n    /**\r\n     * Computes a tight-fitting bounding sphere enclosing the provided array of bounding spheres.\r\n     *\r\n     * @param {BoundingSphere[]} [boundingSpheres] The array of bounding spheres.\r\n     * @param {BoundingSphere} [result] The object onto which to store the result.\r\n     * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\r\n     */\r\n    BoundingSphere.fromBoundingSpheres = function(boundingSpheres, result) {\r\n        if (!defined(result)) {\r\n            result = new BoundingSphere();\r\n        }\r\n\r\n        if (!defined(boundingSpheres) || boundingSpheres.length === 0) {\r\n            result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);\r\n            result.radius = 0.0;\r\n            return result;\r\n        }\r\n\r\n        var length = boundingSpheres.length;\r\n        if (length === 1) {\r\n            return BoundingSphere.clone(boundingSpheres[0], result);\r\n        }\r\n\r\n        if (length === 2) {\r\n            return BoundingSphere.union(boundingSpheres[0], boundingSpheres[1], result);\r\n        }\r\n\r\n        var positions = [];\r\n        var i;\r\n        for (i = 0; i < length; i++) {\r\n            positions.push(boundingSpheres[i].center);\r\n        }\r\n\r\n        result = BoundingSphere.fromPoints(positions, result);\r\n\r\n        var center = result.center;\r\n        var radius = result.radius;\r\n        for (i = 0; i < length; i++) {\r\n            var tmp = boundingSpheres[i];\r\n            radius = Math.max(radius, Cartesian3.distance(center, tmp.center, fromBoundingSpheresScratch) + tmp.radius);\r\n        }\r\n        result.radius = radius;\r\n\r\n        return result;\r\n    };\r\n\r\n    var fromOrientedBoundingBoxScratchU = new Cartesian3();\r\n    var fromOrientedBoundingBoxScratchV = new Cartesian3();\r\n    var fromOrientedBoundingBoxScratchW = new Cartesian3();\r\n\r\n    /**\r\n     * Computes a tight-fitting bounding sphere enclosing the provided oriented bounding box.\r\n     *\r\n     * @param {OrientedBoundingBox} orientedBoundingBox The oriented bounding box.\r\n     * @param {BoundingSphere} [result] The object onto which to store the result.\r\n     * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\r\n     */\r\n    BoundingSphere.fromOrientedBoundingBox = function(orientedBoundingBox, result) {\r\n        if (!defined(result)) {\r\n            result = new BoundingSphere();\r\n        }\r\n\r\n        var halfAxes = orientedBoundingBox.halfAxes;\r\n        var u = Matrix3.getColumn(halfAxes, 0, fromOrientedBoundingBoxScratchU);\r\n        var v = Matrix3.getColumn(halfAxes, 1, fromOrientedBoundingBoxScratchV);\r\n        var w = Matrix3.getColumn(halfAxes, 2, fromOrientedBoundingBoxScratchW);\r\n\r\n        Cartesian3.add(u, v, u);\r\n        Cartesian3.add(u, w, u);\r\n\r\n        result.center = Cartesian3.clone(orientedBoundingBox.center, result.center);\r\n        result.radius = Cartesian3.magnitude(u);\r\n\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Duplicates a BoundingSphere instance.\r\n     *\r\n     * @param {BoundingSphere} sphere The bounding sphere to duplicate.\r\n     * @param {BoundingSphere} [result] The object onto which to store the result.\r\n     * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided. (Returns undefined if sphere is undefined)\r\n     */\r\n    BoundingSphere.clone = function(sphere, result) {\r\n        if (!defined(sphere)) {\r\n            return undefined;\r\n        }\r\n\r\n        if (!defined(result)) {\r\n            return new BoundingSphere(sphere.center, sphere.radius);\r\n        }\r\n\r\n        result.center = Cartesian3.clone(sphere.center, result.center);\r\n        result.radius = sphere.radius;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * The number of elements used to pack the object into an array.\r\n     * @type {Number}\r\n     */\r\n    BoundingSphere.packedLength = 4;\r\n\r\n    /**\r\n     * Stores the provided instance into the provided array.\r\n     *\r\n     * @param {BoundingSphere} value The value to pack.\r\n     * @param {Number[]} array The array to pack into.\r\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\r\n     *\r\n     * @returns {Number[]} The array that was packed into\r\n     */\r\n    BoundingSphere.pack = function(value, array, startingIndex) {\r\n        startingIndex = defaultValue(startingIndex, 0);\r\n\r\n        var center = value.center;\r\n        array[startingIndex++] = center.x;\r\n        array[startingIndex++] = center.y;\r\n        array[startingIndex++] = center.z;\r\n        array[startingIndex] = value.radius;\r\n\r\n        return array;\r\n    };\r\n\r\n    /**\r\n     * Retrieves an instance from a packed array.\r\n     *\r\n     * @param {Number[]} array The packed array.\r\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\r\n     * @param {BoundingSphere} [result] The object into which to store the result.\r\n     * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if one was not provided.\r\n     */\r\n    BoundingSphere.unpack = function(array, startingIndex, result) {\r\n        startingIndex = defaultValue(startingIndex, 0);\r\n\r\n        if (!defined(result)) {\r\n            result = new BoundingSphere();\r\n        }\r\n\r\n        var center = result.center;\r\n        center.x = array[startingIndex++];\r\n        center.y = array[startingIndex++];\r\n        center.z = array[startingIndex++];\r\n        result.radius = array[startingIndex];\r\n        return result;\r\n    };\r\n\r\n    var unionScratch = new Cartesian3();\r\n    var unionScratchCenter = new Cartesian3();\r\n    /**\r\n     * Computes a bounding sphere that contains both the left and right bounding spheres.\r\n     *\r\n     * @param {BoundingSphere} left A sphere to enclose in a bounding sphere.\r\n     * @param {BoundingSphere} right A sphere to enclose in a bounding sphere.\r\n     * @param {BoundingSphere} [result] The object onto which to store the result.\r\n     * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\r\n     */\r\n    BoundingSphere.union = function(left, right, result) {\r\n        if (!defined(result)) {\r\n            result = new BoundingSphere();\r\n        }\r\n\r\n        var leftCenter = left.center;\r\n        var leftRadius = left.radius;\r\n        var rightCenter = right.center;\r\n        var rightRadius = right.radius;\r\n\r\n        var toRightCenter = Cartesian3.subtract(rightCenter, leftCenter, unionScratch);\r\n        var centerSeparation = Cartesian3.magnitude(toRightCenter);\r\n\r\n        if (leftRadius >= (centerSeparation + rightRadius)) {\r\n            // Left sphere wins.\r\n            left.clone(result);\r\n            return result;\r\n        }\r\n\r\n        if (rightRadius >= (centerSeparation + leftRadius)) {\r\n            // Right sphere wins.\r\n            right.clone(result);\r\n            return result;\r\n        }\r\n\r\n        // There are two tangent points, one on far side of each sphere.\r\n        var halfDistanceBetweenTangentPoints = (leftRadius + centerSeparation + rightRadius) * 0.5;\r\n\r\n        // Compute the center point halfway between the two tangent points.\r\n        var center = Cartesian3.multiplyByScalar(toRightCenter,\r\n                (-leftRadius + halfDistanceBetweenTangentPoints) / centerSeparation, unionScratchCenter);\r\n        Cartesian3.add(center, leftCenter, center);\r\n        Cartesian3.clone(center, result.center);\r\n        result.radius = halfDistanceBetweenTangentPoints;\r\n\r\n        return result;\r\n    };\r\n\r\n    var expandScratch = new Cartesian3();\r\n    /**\r\n     * å°boundingSphereåä¸ä¸ªæ¹åè¿è¡ç§»å¨ï¼åæ¶æ©å¤§å¶åå¾ï¼ä½¿å¶ä¸­å¿ç¹è¾¾å°è¿ä¸ªæ¹ååè·ç¦»çä¸­å¿ï¼åæ¶åæ¬ä¹åçä½ç½®\r\n     *\r\n     * @param {BoundingSphere} sphere A sphere to expand.\r\n     * @param {number} distance A distance to expand.\r\n     * @param {Cartesian3} direction A point to enclose in a bounding sphere.\r\n     * @param {BoundingSphere} [result] The object onto which to store the result.\r\n     * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\r\n     */\r\n    BoundingSphere.expandDistance = function(sphere, distance, direction, result) {\r\n        Cartesian3.multiplyByScalar(direction, distance, expandScratch);\r\n        let center = result.center;\r\n        Cartesian3.add(center, expandScratch, center);\r\n        result.radius = Math.sqrt(sphere.radius * sphere.radius + distance * distance);\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Computes a bounding sphere by enlarging the provided sphere to contain the provided point.\r\n     *\r\n     * @param {BoundingSphere} sphere A sphere to expand.\r\n     * @param {Cartesian3} point A point to enclose in a bounding sphere.\r\n     * @param {BoundingSphere} [result] The object onto which to store the result.\r\n     * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\r\n     */\r\n    BoundingSphere.expand = function(sphere, point, result) {\r\n        result = BoundingSphere.clone(sphere, result);\r\n\r\n        var radius = Cartesian3.magnitude(Cartesian3.subtract(point, result.center, expandScratch));\r\n        if (radius > result.radius) {\r\n            result.radius = radius;\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Determines which side of a plane a sphere is located.\r\n     *\r\n     * @param {BoundingSphere} sphere The bounding sphere to test.\r\n     * @param {Plane} plane The plane to test against.\r\n     * @returns {Intersect} {@link Intersect.INSIDE} if the entire sphere is on the side of the plane\r\n     *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire sphere is\r\n     *                      on the opposite side, and {@link Intersect.INTERSECTING} if the sphere\r\n     *                      intersects the plane.\r\n     */\r\n    BoundingSphere.intersectPlane = function(sphere, plane) {\r\n        var center = sphere.center;\r\n        var radius = sphere.radius;\r\n        var normal = plane.normal;\r\n        var distanceToPlane = Cartesian3.dot(normal, center) + plane.distance;\r\n\r\n        if (distanceToPlane < -radius) {\r\n            // The center point is negative side of the plane normal\r\n            return Intersect.OUTSIDE;\r\n        } else if (distanceToPlane < radius) {\r\n            // The center point is positive side of the plane, but radius extends beyond it; partial overlap\r\n            return Intersect.INTERSECTING;\r\n        }\r\n        return Intersect.INSIDE;\r\n    };\r\n\r\n    /**\r\n     * Applies a 4x4 affine transformation matrix to a bounding sphere.\r\n     *\r\n     * @param {BoundingSphere} sphere The bounding sphere to apply the transformation to.\r\n     * @param {Matrix4} transform The transformation matrix to apply to the bounding sphere.\r\n     * @param {BoundingSphere} [result] The object onto which to store the result.\r\n     * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\r\n     */\r\n    BoundingSphere.transform = function(sphere, transform, result) {\r\n        if (!defined(result)) {\r\n            result = new BoundingSphere();\r\n        }\r\n\r\n        result.center = Matrix4.multiplyByPoint(transform, sphere.center, result.center);\r\n        result.radius = Matrix4.getMaximumScale(transform) * sphere.radius;\r\n\r\n        return result;\r\n    };\r\n\r\n    var distanceSquaredToScratch = new Cartesian3();\r\n\r\n    /**\r\n     * Computes the estimated distance squared from the closest point on a bounding sphere to a point.\r\n     *\r\n     * @param {BoundingSphere} sphere The sphere.\r\n     * @param {Cartesian3} cartesian The point\r\n     * @returns {Number} The estimated distance squared from the bounding sphere to the point.\r\n     *\r\n     * @example\r\n     * // Sort bounding spheres from back to front\r\n     * spheres.sort(function(a, b) {\r\n     *     return Cesium.BoundingSphere.distanceSquaredTo(b, camera.positionWC) - Cesium.BoundingSphere.distanceSquaredTo(a, camera.positionWC);\r\n     * });\r\n     */\r\n    BoundingSphere.distanceSquaredTo = function(sphere, cartesian) {\r\n        var diff = Cartesian3.subtract(sphere.center, cartesian, distanceSquaredToScratch);\r\n        return Cartesian3.magnitudeSquared(diff) - sphere.radius * sphere.radius;\r\n    };\r\n\r\n    /**\r\n     * Applies a 4x4 affine transformation matrix to a bounding sphere where there is no scale\r\n     * The transformation matrix is not verified to have a uniform scale of 1.\r\n     * This method is faster than computing the general bounding sphere transform using {@link BoundingSphere.transform}.\r\n     *\r\n     * @param {BoundingSphere} sphere The bounding sphere to apply the transformation to.\r\n     * @param {Matrix4} transform The transformation matrix to apply to the bounding sphere.\r\n     * @param {BoundingSphere} [result] The object onto which to store the result.\r\n     * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\r\n     *\r\n     * @example\r\n     * var modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(positionOnEllipsoid);\r\n     * var boundingSphere = new Cesium.BoundingSphere();\r\n     * var newBoundingSphere = Cesium.BoundingSphere.transformWithoutScale(boundingSphere, modelMatrix);\r\n     */\r\n    BoundingSphere.transformWithoutScale = function(sphere, transform, result) {\r\n        if (!defined(result)) {\r\n            result = new BoundingSphere();\r\n        }\r\n\r\n        result.center = Matrix4.multiplyByPoint(transform, sphere.center, result.center);\r\n        result.radius = sphere.radius;\r\n\r\n        return result;\r\n    };\r\n\r\n    var scratchCartesian3 = new Cartesian3();\r\n    /**\r\n     * The distances calculated by the vector from the center of the bounding sphere to position projected onto direction\r\n     * plus/minus the radius of the bounding sphere.\r\n     * <br>\r\n     * If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the\r\n     * closest and farthest planes from position that intersect the bounding sphere.\r\n     *\r\n     * @param {BoundingSphere} sphere The bounding sphere to calculate the distance to.\r\n     * @param {Cartesian3} position The position to calculate the distance from.\r\n     * @param {Cartesian3} direction The direction from position.\r\n     * @param {Interval} [result] A Interval to store the nearest and farthest distances.\r\n     * @returns {Interval} The nearest and farthest distances on the bounding sphere from position in direction.\r\n     */\r\n    BoundingSphere.computePlaneDistances = function(sphere, position, direction, result) {\r\n        if (!defined(result)) {\r\n            result = new Interval();\r\n        }\r\n\r\n        var toCenter = Cartesian3.subtract(sphere.center, position, scratchCartesian3);\r\n        var mag = Cartesian3.dot(direction, toCenter);\r\n\r\n        result.start = mag - sphere.radius;\r\n        result.stop = mag + sphere.radius;\r\n        return result;\r\n    };\r\n\r\n    var projectTo2DNormalScratch = new Cartesian3();\r\n    var projectTo2DEastScratch = new Cartesian3();\r\n    var projectTo2DNorthScratch = new Cartesian3();\r\n    var projectTo2DWestScratch = new Cartesian3();\r\n    var projectTo2DSouthScratch = new Cartesian3();\r\n    var projectTo2DCartographicScratch = new Cartographic();\r\n    var projectTo2DPositionsScratch = new Array(8);\r\n    for (var n = 0; n < 8; ++n) {\r\n        projectTo2DPositionsScratch[n] = new Cartesian3();\r\n    }\r\n\r\n    var projectTo2DProjection = new GeographicProjection();\r\n    /**\r\n     * Creates a bounding sphere in 2D from a bounding sphere in 3D world coordinates.\r\n     *\r\n     * @param {BoundingSphere} sphere The bounding sphere to transform to 2D.\r\n     * @param {Object} [projection=GeographicProjection] The projection to 2D.\r\n     * @param {BoundingSphere} [result] The object onto which to store the result.\r\n     * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\r\n     */\r\n    BoundingSphere.projectTo2D = function(sphere, projection, result) {\r\n        projection = defaultValue(projection, projectTo2DProjection);\r\n\r\n        var ellipsoid = projection.ellipsoid;\r\n        var center = sphere.center;\r\n        var radius = sphere.radius;\r\n\r\n        var normal;\r\n        if (Cartesian3.equals(center, Cartesian3.ZERO)) {\r\n            // Bounding sphere is at the center. The geodetic surface normal is not\r\n            // defined here so pick the x-axis as a fallback.\r\n            normal = Cartesian3.clone(Cartesian3.UNIT_X, projectTo2DNormalScratch);\r\n        } else {\r\n            normal = ellipsoid.geodeticSurfaceNormal(center, projectTo2DNormalScratch);\r\n        }\r\n        var east = Cartesian3.cross(Cartesian3.UNIT_Z, normal, projectTo2DEastScratch);\r\n        Cartesian3.normalize(east, east);\r\n        var north = Cartesian3.cross(normal, east, projectTo2DNorthScratch);\r\n        Cartesian3.normalize(north, north);\r\n\r\n        Cartesian3.multiplyByScalar(normal, radius, normal);\r\n        Cartesian3.multiplyByScalar(north, radius, north);\r\n        Cartesian3.multiplyByScalar(east, radius, east);\r\n\r\n        var south = Cartesian3.negate(north, projectTo2DSouthScratch);\r\n        var west = Cartesian3.negate(east, projectTo2DWestScratch);\r\n\r\n        var positions = projectTo2DPositionsScratch;\r\n\r\n        // top NE corner\r\n        var corner = positions[0];\r\n        Cartesian3.add(normal, north, corner);\r\n        Cartesian3.add(corner, east, corner);\r\n\r\n        // top NW corner\r\n        corner = positions[1];\r\n        Cartesian3.add(normal, north, corner);\r\n        Cartesian3.add(corner, west, corner);\r\n\r\n        // top SW corner\r\n        corner = positions[2];\r\n        Cartesian3.add(normal, south, corner);\r\n        Cartesian3.add(corner, west, corner);\r\n\r\n        // top SE corner\r\n        corner = positions[3];\r\n        Cartesian3.add(normal, south, corner);\r\n        Cartesian3.add(corner, east, corner);\r\n\r\n        Cartesian3.negate(normal, normal);\r\n\r\n        // bottom NE corner\r\n        corner = positions[4];\r\n        Cartesian3.add(normal, north, corner);\r\n        Cartesian3.add(corner, east, corner);\r\n\r\n        // bottom NW corner\r\n        corner = positions[5];\r\n        Cartesian3.add(normal, north, corner);\r\n        Cartesian3.add(corner, west, corner);\r\n\r\n        // bottom SW corner\r\n        corner = positions[6];\r\n        Cartesian3.add(normal, south, corner);\r\n        Cartesian3.add(corner, west, corner);\r\n\r\n        // bottom SE corner\r\n        corner = positions[7];\r\n        Cartesian3.add(normal, south, corner);\r\n        Cartesian3.add(corner, east, corner);\r\n\r\n        var length = positions.length;\r\n        for (var i = 0; i < length; ++i) {\r\n            var position = positions[i];\r\n            Cartesian3.add(center, position, position);\r\n            var cartographic = ellipsoid.cartesianToCartographic(position, projectTo2DCartographicScratch);\r\n            projection.project(cartographic, position);\r\n        }\r\n\r\n        result = BoundingSphere.fromPoints(positions, result);\r\n\r\n        // swizzle center components\r\n        center = result.center;\r\n        var x = center.x;\r\n        var y = center.y;\r\n        var z = center.z;\r\n        center.x = z;\r\n        center.y = x;\r\n        center.z = y;\r\n\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Determines whether or not a sphere is hidden from view by the occluder.\r\n     *\r\n     * @param {BoundingSphere} sphere The bounding sphere surrounding the occludee object.\r\n     * @param {Occluder} occluder The occluder.\r\n     * @returns {Boolean} <code>true</code> if the sphere is not visible; otherwise <code>false</code>.\r\n     */\r\n    BoundingSphere.isOccluded = function(sphere, occluder) {\r\n        return !occluder.isBoundingSphereVisible(sphere);\r\n    };\r\n\r\n    /**\r\n     * Compares the provided BoundingSphere componentwise and returns\r\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\r\n     *\r\n     * @param {BoundingSphere} [left] The first BoundingSphere.\r\n     * @param {BoundingSphere} [right] The second BoundingSphere.\r\n     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\r\n     */\r\n    BoundingSphere.equals = function(left, right) {\r\n        return (left === right) ||\r\n               ((defined(left)) &&\r\n                (defined(right)) &&\r\n                Cartesian3.equals(left.center, right.center) &&\r\n                left.radius === right.radius);\r\n    };\r\n\r\n    /**\r\n     * Determines which side of a plane the sphere is located.\r\n     *\r\n     * @param {Plane} plane The plane to test against.\r\n     * @returns {Intersect} {@link Intersect.INSIDE} if the entire sphere is on the side of the plane\r\n     *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire sphere is\r\n     *                      on the opposite side, and {@link Intersect.INTERSECTING} if the sphere\r\n     *                      intersects the plane.\r\n     */\r\n    BoundingSphere.prototype.intersectPlane = function(plane) {\r\n        return BoundingSphere.intersectPlane(this, plane);\r\n    };\r\n\r\n    /**\r\n     * Computes the estimated distance squared from the closest point on a bounding sphere to a point.\r\n     *\r\n     * @param {Cartesian3} cartesian The point\r\n     * @returns {Number} The estimated distance squared from the bounding sphere to the point.\r\n     *\r\n     * @example\r\n     * // Sort bounding spheres from back to front\r\n     * spheres.sort(function(a, b) {\r\n     *     return b.distanceSquaredTo(camera.positionWC) - a.distanceSquaredTo(camera.positionWC);\r\n     * });\r\n     */\r\n    BoundingSphere.prototype.distanceSquaredTo = function(cartesian) {\r\n        return BoundingSphere.distanceSquaredTo(this, cartesian);\r\n    };\r\n\r\n    /**\r\n     * The distances calculated by the vector from the center of the bounding sphere to position projected onto direction\r\n     * plus/minus the radius of the bounding sphere.\r\n     * <br>\r\n     * If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the\r\n     * closest and farthest planes from position that intersect the bounding sphere.\r\n     *\r\n     * @param {Cartesian3} position The position to calculate the distance from.\r\n     * @param {Cartesian3} direction The direction from position.\r\n     * @param {Interval} [result] A Interval to store the nearest and farthest distances.\r\n     * @returns {Interval} The nearest and farthest distances on the bounding sphere from position in direction.\r\n     */\r\n    BoundingSphere.prototype.computePlaneDistances = function(position, direction, result) {\r\n        return BoundingSphere.computePlaneDistances(this, position, direction, result);\r\n    };\r\n\r\n    /**\r\n     * Determines whether or not a sphere is hidden from view by the occluder.\r\n     *\r\n     * @param {Occluder} occluder The occluder.\r\n     * @returns {Boolean} <code>true</code> if the sphere is not visible; otherwise <code>false</code>.\r\n     */\r\n    BoundingSphere.prototype.isOccluded = function(occluder) {\r\n        return BoundingSphere.isOccluded(this, occluder);\r\n    };\r\n\r\n    /**\r\n     * Compares this BoundingSphere against the provided BoundingSphere componentwise and returns\r\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\r\n     *\r\n     * @param {BoundingSphere} [right] The right hand side BoundingSphere.\r\n     * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\r\n     */\r\n    BoundingSphere.prototype.equals = function(right) {\r\n        return BoundingSphere.equals(this, right);\r\n    };\r\n\r\n    /**\r\n     * Duplicates this BoundingSphere instance.\r\n     *\r\n     * @param {BoundingSphere} [result] The object onto which to store the result.\r\n     * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\r\n     */\r\n    BoundingSphere.prototype.clone = function(result) {\r\n        return BoundingSphere.clone(this, result);\r\n    };\r\n\r\n    /**\r\n     * Computes the radius of the BoundingSphere.\r\n     * @returns {Number} The radius of the BoundingSphere.\r\n     */\r\n    BoundingSphere.prototype.volume = function() {\r\n        var radius = this.radius;\r\n        return volumeConstant * radius * radius * radius;\r\n    };\r\n\r\n    /**\r\n     * get corner ary.\r\n     * @returns {Cartesian3[]} corner ary\r\n     */\r\n     BoundingSphere.prototype.getCornerAry = function() {\r\n        var corners = [];\r\n\r\n        var scratchCorner = new Cartesian3();\r\n\r\n        var u = new Cartesian3(this.radius, 0, 0);\r\n        var v = new Cartesian3(0, this.radius, 0);\r\n        var w = new Cartesian3(0, 0, this.radius);\r\n\r\n        // project first corner\r\n        var corner = Cartesian3.add(u, v, scratchCorner);\r\n        Cartesian3.add(corner, w, corner);\r\n        Cartesian3.add(corner, this.center, corner);\r\n\r\n        corners.push(corner.clone());\r\n\r\n        // project second corner\r\n        Cartesian3.add(this.center, u, corner);\r\n        Cartesian3.add(corner, v, corner);\r\n        Cartesian3.subtract(corner, w, corner);\r\n\r\n        corners.push(corner.clone());\r\n\r\n        // project third corner\r\n        Cartesian3.add(this.center, u, corner);\r\n        Cartesian3.subtract(corner, v, corner);\r\n        Cartesian3.add(corner, w, corner);\r\n\r\n        corners.push(corner.clone());\r\n\r\n        // project fourth corner\r\n        Cartesian3.add(this.center, u, corner);\r\n        Cartesian3.subtract(corner, v, corner);\r\n        Cartesian3.subtract(corner, w, corner);\r\n\r\n        corners.push(corner.clone());\r\n\r\n        // project fifth corner\r\n        Cartesian3.subtract(this.center, u, corner);\r\n        Cartesian3.add(corner, v, corner);\r\n        Cartesian3.add(corner, w, corner);\r\n\r\n        corners.push(corner.clone());\r\n\r\n        // project sixth corner\r\n        Cartesian3.subtract(this.center, u, corner);\r\n        Cartesian3.add(corner, v, corner);\r\n        Cartesian3.subtract(corner, w, corner);\r\n\r\n        corners.push(corner.clone());\r\n\r\n        // project seventh corner\r\n        Cartesian3.subtract(this.center, u, corner);\r\n        Cartesian3.subtract(corner, v, corner);\r\n        Cartesian3.add(corner, w, corner);\r\n\r\n        corners.push(corner.clone());\r\n\r\n        // project eighth corner\r\n        Cartesian3.subtract(this.center, u, corner);\r\n        Cartesian3.subtract(corner, v, corner);\r\n        Cartesian3.subtract(corner, w, corner);\r\n\r\n        corners.push(corner.clone());\r\n\r\n        return corners;\r\n    };\r\nexport default BoundingSphere;\r\n"],"names":["defaultValue","Ellipsoid","defined","Cartesian3","DeveloperError","Cartographic","CesiumMath","Rectangle","Check","Matrix3","Intersect","Matrix4"],"mappings":"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"}