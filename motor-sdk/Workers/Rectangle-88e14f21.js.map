{"version":3,"file":"Rectangle-88e14f21.js","sources":["../../Source/Core/scaleToGeodeticSurface.js","../../Source/Core/Cartographic.js","../../Source/Core/Ellipsoid.js","../../Source/Core/Rectangle.js"],"sourcesContent":["import Cartesian3 from './Cartesian3.js';\r\nimport defined from './defined.js';\r\nimport DeveloperError from './DeveloperError.js';\r\nimport CesiumMath from './Math.js';\r\n\r\n    var scaleToGeodeticSurfaceIntersection = new Cartesian3();\r\n    var scaleToGeodeticSurfaceGradient = new Cartesian3();\r\n\r\n    /**\r\n     * Scales the provided Cartesian position along the geodetic surface normal\r\n     * so that it is on the surface of this ellipsoid.  If the position is\r\n     * at the center of the ellipsoid, this function returns undefined.\r\n     *\r\n     * @param {Cartesian3} cartesian The Cartesian position to scale.\r\n     * @param {Cartesian3} oneOverRadii One over radii of the ellipsoid.\r\n     * @param {Cartesian3} oneOverRadiiSquared One over radii squared of the ellipsoid.\r\n     * @param {Number} centerToleranceSquared Tolerance for closeness to the center.\r\n     * @param {Cartesian3} [result] The object onto which to store the result.\r\n     * @returns {Cartesian3} The modified result parameter, a new Cartesian3 instance if none was provided, or undefined if the position is at the center.\r\n     *\r\n     * @function scaleToGeodeticSurface\r\n     *\r\n     * @private\r\n     */\r\n    function scaleToGeodeticSurface(cartesian, oneOverRadii, oneOverRadiiSquared, centerToleranceSquared, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(cartesian)) {\r\n            throw new DeveloperError('cartesian is required.');\r\n        }\r\n        if (!defined(oneOverRadii)) {\r\n            throw new DeveloperError('oneOverRadii is required.');\r\n        }\r\n        if (!defined(oneOverRadiiSquared)) {\r\n            throw new DeveloperError('oneOverRadiiSquared is required.');\r\n        }\r\n        if (!defined(centerToleranceSquared)) {\r\n            throw new DeveloperError('centerToleranceSquared is required.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var positionX = cartesian.x;\r\n        var positionY = cartesian.y;\r\n        var positionZ = cartesian.z;\r\n\r\n        var oneOverRadiiX = oneOverRadii.x;\r\n        var oneOverRadiiY = oneOverRadii.y;\r\n        var oneOverRadiiZ = oneOverRadii.z;\r\n\r\n        var x2 = positionX * positionX * oneOverRadiiX * oneOverRadiiX;\r\n        var y2 = positionY * positionY * oneOverRadiiY * oneOverRadiiY;\r\n        var z2 = positionZ * positionZ * oneOverRadiiZ * oneOverRadiiZ;\r\n\r\n        // Compute the squared ellipsoid norm.\r\n        var squaredNorm = x2 + y2 + z2;\r\n        var ratio = Math.sqrt(1.0 / squaredNorm);\r\n\r\n        // As an initial approximation, assume that the radial intersection is the projection point.\r\n        var intersection = Cartesian3.multiplyByScalar(cartesian, ratio, scaleToGeodeticSurfaceIntersection);\r\n\r\n        // If the position is near the center, the iteration will not converge.\r\n        if (squaredNorm < centerToleranceSquared) {\r\n            return !isFinite(ratio) ? undefined : Cartesian3.clone(intersection, result);\r\n        }\r\n\r\n        var oneOverRadiiSquaredX = oneOverRadiiSquared.x;\r\n        var oneOverRadiiSquaredY = oneOverRadiiSquared.y;\r\n        var oneOverRadiiSquaredZ = oneOverRadiiSquared.z;\r\n\r\n        // Use the gradient at the intersection point in place of the true unit normal.\r\n        // The difference in magnitude will be absorbed in the multiplier.\r\n        var gradient = scaleToGeodeticSurfaceGradient;\r\n        gradient.x = intersection.x * oneOverRadiiSquaredX * 2.0;\r\n        gradient.y = intersection.y * oneOverRadiiSquaredY * 2.0;\r\n        gradient.z = intersection.z * oneOverRadiiSquaredZ * 2.0;\r\n\r\n        // Compute the initial guess at the normal vector multiplier, lambda.\r\n        var lambda = (1.0 - ratio) * Cartesian3.magnitude(cartesian) / (0.5 * Cartesian3.magnitude(gradient));\r\n        var correction = 0.0;\r\n\r\n        var func;\r\n        var denominator;\r\n        var xMultiplier;\r\n        var yMultiplier;\r\n        var zMultiplier;\r\n        var xMultiplier2;\r\n        var yMultiplier2;\r\n        var zMultiplier2;\r\n        var xMultiplier3;\r\n        var yMultiplier3;\r\n        var zMultiplier3;\r\n\r\n        do {\r\n            lambda -= correction;\r\n\r\n            xMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredX);\r\n            yMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredY);\r\n            zMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredZ);\r\n\r\n            xMultiplier2 = xMultiplier * xMultiplier;\r\n            yMultiplier2 = yMultiplier * yMultiplier;\r\n            zMultiplier2 = zMultiplier * zMultiplier;\r\n\r\n            xMultiplier3 = xMultiplier2 * xMultiplier;\r\n            yMultiplier3 = yMultiplier2 * yMultiplier;\r\n            zMultiplier3 = zMultiplier2 * zMultiplier;\r\n\r\n            func = x2 * xMultiplier2 + y2 * yMultiplier2 + z2 * zMultiplier2 - 1.0;\r\n\r\n            // \"denominator\" here refers to the use of this expression in the velocity and acceleration\r\n            // computations in the sections to follow.\r\n            denominator = x2 * xMultiplier3 * oneOverRadiiSquaredX + y2 * yMultiplier3 * oneOverRadiiSquaredY + z2 * zMultiplier3 * oneOverRadiiSquaredZ;\r\n\r\n            var derivative = -2.0 * denominator;\r\n\r\n            correction = func / derivative;\r\n        } while (Math.abs(func) > CesiumMath.EPSILON12);\r\n\r\n        if (!defined(result)) {\r\n            return new Cartesian3(positionX * xMultiplier, positionY * yMultiplier, positionZ * zMultiplier);\r\n        }\r\n        result.x = positionX * xMultiplier;\r\n        result.y = positionY * yMultiplier;\r\n        result.z = positionZ * zMultiplier;\r\n        return result;\r\n    }\r\nexport default scaleToGeodeticSurface;\r\n","import Cartesian3 from './Cartesian3.js';\r\nimport Check from './Check.js';\r\nimport defaultValue from './defaultValue.js';\r\nimport defined from './defined.js';\r\nimport CesiumMath from './Math.js';\r\nimport scaleToGeodeticSurface from './scaleToGeodeticSurface.js';\r\n\r\n    /**\r\n     * A position defined by longitude, latitude, and height.\r\n     * @alias Cartographic\r\n     * @constructor\r\n     *\r\n     * @param {Number} [longitude=0.0] The longitude, in radians.\r\n     * @param {Number} [latitude=0.0] The latitude, in radians.\r\n     * @param {Number} [height=0.0] The height, in meters, above the ellipsoid.\r\n     *\r\n     * @see Ellipsoid\r\n     */\r\n    function Cartographic(longitude, latitude, height) {\r\n        /**\r\n         * The longitude, in radians.\r\n         * @type {Number}\r\n         * @default 0.0\r\n         */\r\n        this.longitude = defaultValue(longitude, 0.0);\r\n\r\n        /**\r\n         * The latitude, in radians.\r\n         * @type {Number}\r\n         * @default 0.0\r\n         */\r\n        this.latitude = defaultValue(latitude, 0.0);\r\n\r\n        /**\r\n         * The height, in meters, above the ellipsoid.\r\n         * @type {Number}\r\n         * @default 0.0\r\n         */\r\n        this.height = defaultValue(height, 0.0);\r\n    }\r\n\r\n    /**\r\n     * Creates a new Cartographic instance from longitude and latitude\r\n     * specified in radians.\r\n     *\r\n     * @param {Number} longitude The longitude, in radians.\r\n     * @param {Number} latitude The latitude, in radians.\r\n     * @param {Number} [height=0.0] The height, in meters, above the ellipsoid.\r\n     * @param {Cartographic} [result] The object onto which to store the result.\r\n     * @returns {Cartographic} The modified result parameter or a new Cartographic instance if one was not provided.\r\n     */\r\n    Cartographic.fromRadians = function(longitude, latitude, height, result) {\r\n        height = defaultValue(height, 0.0);\r\n\r\n        if (!defined(result)) {\r\n            return new Cartographic(longitude, latitude, height);\r\n        }\r\n\r\n        result.longitude = longitude;\r\n        result.latitude = latitude;\r\n        result.height = height;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Creates a new Cartographic instance from longitude and latitude\r\n     * specified in degrees.  The values in the resulting object will\r\n     * be in radians.\r\n     *\r\n     * @param {Number} longitude The longitude, in degrees.\r\n     * @param {Number} latitude The latitude, in degrees.\r\n     * @param {Number} [height=0.0] The height, in meters, above the ellipsoid.\r\n     * @param {Cartographic} [result] The object onto which to store the result.\r\n     * @returns {Cartographic} The modified result parameter or a new Cartographic instance if one was not provided.\r\n     */\r\n    Cartographic.fromDegrees = function(longitude, latitude, height, result) {\r\n        longitude = CesiumMath.toRadians(longitude);\r\n        latitude = CesiumMath.toRadians(latitude);\r\n\r\n        return Cartographic.fromRadians(longitude, latitude, height, result);\r\n    };\r\n\r\n    var cartesianToCartographicN = new Cartesian3();\r\n    var cartesianToCartographicP = new Cartesian3();\r\n    var cartesianToCartographicH = new Cartesian3();\r\n    var wgs84OneOverRadii = new Cartesian3(1.0 / 6378137.0, 1.0 / 6378137.0, 1.0 / 6356752.3142451793);\r\n    var wgs84OneOverRadiiSquared = new Cartesian3(1.0 / (6378137.0 * 6378137.0), 1.0 / (6378137.0 * 6378137.0), 1.0 / (6356752.3142451793 * 6356752.3142451793));\r\n    var wgs84CenterToleranceSquared = CesiumMath.EPSILON1;\r\n\r\n    /**\r\n     * Creates a new Cartographic instance from a Cartesian position. The values in the\r\n     * resulting object will be in radians.\r\n     *\r\n     * @param {Cartesian3} cartesian The Cartesian position to convert to cartographic representation.\r\n     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the position lies.\r\n     * @param {Cartographic} [result] The object onto which to store the result.\r\n     * @returns {Cartographic} The modified result parameter, new Cartographic instance if none was provided, or undefined if the cartesian is at the center of the ellipsoid.\r\n     */\r\n    Cartographic.fromCartesian = function(cartesian, ellipsoid, result) {\r\n        var oneOverRadii = defined(ellipsoid) ? ellipsoid.oneOverRadii : wgs84OneOverRadii;\r\n        var oneOverRadiiSquared = defined(ellipsoid) ? ellipsoid.oneOverRadiiSquared : wgs84OneOverRadiiSquared;\r\n        var centerToleranceSquared = defined(ellipsoid) ? ellipsoid._centerToleranceSquared : wgs84CenterToleranceSquared;\r\n\r\n        //`cartesian is required.` is thrown from scaleToGeodeticSurface\r\n        var p = scaleToGeodeticSurface(cartesian, oneOverRadii, oneOverRadiiSquared, centerToleranceSquared, cartesianToCartographicP);\r\n\r\n        if (!defined(p)) {\r\n            return undefined;\r\n        }\r\n\r\n        var n = Cartesian3.multiplyComponents(p, oneOverRadiiSquared, cartesianToCartographicN);\r\n        n = Cartesian3.normalize(n, n);\r\n\r\n        var h = Cartesian3.subtract(cartesian, p, cartesianToCartographicH);\r\n\r\n        var longitude = Math.atan2(n.y, n.x);\r\n        var latitude = Math.asin(n.z);\r\n        var height = CesiumMath.sign(Cartesian3.dot(h, cartesian)) * Cartesian3.magnitude(h);\r\n\r\n        if (!defined(result)) {\r\n            return new Cartographic(longitude, latitude, height);\r\n        }\r\n        result.longitude = longitude;\r\n        result.latitude = latitude;\r\n        result.height = height;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Creates a new Cartesian3 instance from a Cartographic input. The values in the inputted\r\n     * object should be in radians.\r\n     *\r\n     * @param {Cartographic} cartographic Input to be converted into a Cartesian3 output.\r\n     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the position lies.\r\n     * @param {Cartesian3} [result] The object onto which to store the result.\r\n     * @returns {Cartesian3} The position\r\n     */\r\n    Cartographic.toCartesian = function(cartographic, ellipsoid, result) {\r\n        return Cartesian3.fromRadians(cartographic.longitude, cartographic.latitude, cartographic.height, ellipsoid, result);\r\n    };\r\n\r\n    /**\r\n     * Duplicates a Cartographic instance.\r\n     *\r\n     * @param {Cartographic} cartographic The cartographic to duplicate.\r\n     * @param {Cartographic} [result] The object onto which to store the result.\r\n     * @returns {Cartographic} The modified result parameter or a new Cartographic instance if one was not provided. (Returns undefined if cartographic is undefined)\r\n     */\r\n    Cartographic.clone = function(cartographic, result) {\r\n        if (!defined(cartographic)) {\r\n            return undefined;\r\n        }\r\n        if (!defined(result)) {\r\n            return new Cartographic(cartographic.longitude, cartographic.latitude, cartographic.height);\r\n        }\r\n        result.longitude = cartographic.longitude;\r\n        result.latitude = cartographic.latitude;\r\n        result.height = cartographic.height;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Compares the provided cartographics componentwise and returns\r\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\r\n     *\r\n     * @param {Cartographic} [left] The first cartographic.\r\n     * @param {Cartographic} [right] The second cartographic.\r\n     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\r\n     */\r\n    Cartographic.equals = function(left, right) {\r\n        return (left === right) ||\r\n                ((defined(left)) &&\r\n                 (defined(right)) &&\r\n                 (left.longitude === right.longitude) &&\r\n                 (left.latitude === right.latitude) &&\r\n                 (left.height === right.height));\r\n    };\r\n\r\n    /**\r\n     * Compares the provided cartographics componentwise and returns\r\n     * <code>true</code> if they are within the provided epsilon,\r\n     * <code>false</code> otherwise.\r\n     *\r\n     * @param {Cartographic} [left] The first cartographic.\r\n     * @param {Cartographic} [right] The second cartographic.\r\n     * @param {Number} [epsilon = 0] The epsilon to use for equality testing.\r\n     * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\r\n     */\r\n    Cartographic.equalsEpsilon = function(left, right, epsilon) {\r\n        epsilon = defaultValue(epsilon, 0);\r\n\r\n        return (left === right) ||\r\n               ((defined(left)) &&\r\n                (defined(right)) &&\r\n                (Math.abs(left.longitude - right.longitude) <= epsilon) &&\r\n                (Math.abs(left.latitude - right.latitude) <= epsilon) &&\r\n                (Math.abs(left.height - right.height) <= epsilon));\r\n    };\r\n\r\n    /**\r\n     * An immutable Cartographic instance initialized to (0.0, 0.0, 0.0).\r\n     *\r\n     * @type {Cartographic}\r\n     * @constant\r\n     */\r\n    Cartographic.ZERO = Object.freeze(new Cartographic(0.0, 0.0, 0.0));\r\n\r\n    /**\r\n     * Duplicates this instance.\r\n     *\r\n     * @param {Cartographic} [result] The object onto which to store the result.\r\n     * @returns {Cartographic} The modified result parameter or a new Cartographic instance if one was not provided.\r\n     */\r\n    Cartographic.prototype.clone = function(result) {\r\n        return Cartographic.clone(this, result);\r\n    };\r\n\r\n    /**\r\n     * Compares the provided against this cartographic componentwise and returns\r\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\r\n     *\r\n     * @param {Cartographic} [right] The second cartographic.\r\n     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\r\n     */\r\n    Cartographic.prototype.equals = function(right) {\r\n        return Cartographic.equals(this, right);\r\n    };\r\n\r\n    /**\r\n     * Compares the provided against this cartographic componentwise and returns\r\n     * <code>true</code> if they are within the provided epsilon,\r\n     * <code>false</code> otherwise.\r\n     *\r\n     * @param {Cartographic} [right] The second cartographic.\r\n     * @param {Number} [epsilon = 0] The epsilon to use for equality testing.\r\n     * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\r\n     */\r\n    Cartographic.prototype.equalsEpsilon = function(right, epsilon) {\r\n        return Cartographic.equalsEpsilon(this, right, epsilon);\r\n    };\r\n\r\n    /**\r\n     * Creates a string representing this cartographic in the format '(longitude, latitude, height)'.\r\n     *\r\n     * @returns {String} A string representing the provided cartographic in the format '(longitude, latitude, height)'.\r\n     */\r\n    Cartographic.prototype.toString = function() {\r\n        return '(' + this.longitude + ', ' + this.latitude + ', ' + this.height + ')';\r\n    };\r\nexport default Cartographic;\r\n","import Cartesian3 from './Cartesian3.js';\r\nimport Cartographic from './Cartographic.js';\r\nimport Check from './Check.js';\r\nimport defaultValue from './defaultValue.js';\r\nimport defined from './defined.js';\r\nimport DeveloperError from './DeveloperError.js';\r\nimport CesiumMath from './Math.js';\r\nimport scaleToGeodeticSurface from './scaleToGeodeticSurface.js';\r\n\r\n    function initialize(ellipsoid, x, y, z) {\r\n        x = defaultValue(x, 0.0);\r\n        y = defaultValue(y, 0.0);\r\n        z = defaultValue(z, 0.0);\r\n\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.number.greaterThanOrEquals('x', x, 0.0);\r\n        Check.typeOf.number.greaterThanOrEquals('y', y, 0.0);\r\n        Check.typeOf.number.greaterThanOrEquals('z', z, 0.0);\r\n        //>>includeEnd('debug');\r\n\r\n        ellipsoid._radii = new Cartesian3(x, y, z);\r\n\r\n        ellipsoid._radiiSquared = new Cartesian3(x * x,\r\n                                            y * y,\r\n                                            z * z);\r\n\r\n        ellipsoid._radiiToTheFourth = new Cartesian3(x * x * x * x,\r\n                                                y * y * y * y,\r\n                                                z * z * z * z);\r\n\r\n        ellipsoid._oneOverRadii = new Cartesian3(x === 0.0 ? 0.0 : 1.0 / x,\r\n                                            y === 0.0 ? 0.0 : 1.0 / y,\r\n                                            z === 0.0 ? 0.0 : 1.0 / z);\r\n\r\n        ellipsoid._oneOverRadiiSquared = new Cartesian3(x === 0.0 ? 0.0 : 1.0 / (x * x),\r\n                                                   y === 0.0 ? 0.0 : 1.0 / (y * y),\r\n                                                   z === 0.0 ? 0.0 : 1.0 / (z * z));\r\n\r\n        ellipsoid._minimumRadius = Math.min(x, y, z);\r\n\r\n        ellipsoid._maximumRadius = Math.max(x, y, z);\r\n\r\n        ellipsoid._centerToleranceSquared = CesiumMath.EPSILON1;\r\n\r\n        if (ellipsoid._radiiSquared.z !== 0) {\r\n            ellipsoid._squaredXOverSquaredZ = ellipsoid._radiiSquared.x / ellipsoid._radiiSquared.z;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * A quadratic surface defined in Cartesian coordinates by the equation\r\n     * <code>(x / a)^2 + (y / b)^2 + (z / c)^2 = 1</code>.  Primarily used\r\n     * by Cesium to represent the shape of planetary bodies.\r\n     *\r\n     * Rather than constructing this object directly, one of the provided\r\n     * constants is normally used.\r\n     * @alias Ellipsoid\r\n     * @constructor\r\n     *\r\n     * @param {Number} [x=0] The radius in the x direction.\r\n     * @param {Number} [y=0] The radius in the y direction.\r\n     * @param {Number} [z=0] The radius in the z direction.\r\n     *\r\n     * @exception {DeveloperError} All radii components must be greater than or equal to zero.\r\n     *\r\n     * @see Ellipsoid.fromCartesian3\r\n     * @see Ellipsoid.WGS84\r\n     * @see Ellipsoid.UNIT_SPHERE\r\n     */\r\n    function Ellipsoid(x, y, z) {\r\n        this._radii = undefined;\r\n        this._radiiSquared = undefined;\r\n        this._radiiToTheFourth = undefined;\r\n        this._oneOverRadii = undefined;\r\n        this._oneOverRadiiSquared = undefined;\r\n        this._minimumRadius = undefined;\r\n        this._maximumRadius = undefined;\r\n        this._centerToleranceSquared = undefined;\r\n        this._squaredXOverSquaredZ = undefined;\r\n\r\n        initialize(this, x, y, z);\r\n    }\r\n\r\n    Object.defineProperties(Ellipsoid.prototype, {\r\n        /**\r\n         * Gets the radii of the ellipsoid.\r\n         * @memberof Ellipsoid.prototype\r\n         * @type {Cartesian3}\r\n         * @readonly\r\n         */\r\n        radii : {\r\n            get: function() {\r\n                return this._radii;\r\n            }\r\n        },\r\n        /**\r\n         * Gets the squared radii of the ellipsoid.\r\n         * @memberof Ellipsoid.prototype\r\n         * @type {Cartesian3}\r\n         * @readonly\r\n         */\r\n        radiiSquared : {\r\n            get : function() {\r\n                return this._radiiSquared;\r\n            }\r\n        },\r\n        /**\r\n         * Gets the radii of the ellipsoid raise to the fourth power.\r\n         * @memberof Ellipsoid.prototype\r\n         * @type {Cartesian3}\r\n         * @readonly\r\n         */\r\n        radiiToTheFourth : {\r\n            get : function() {\r\n                return this._radiiToTheFourth;\r\n            }\r\n        },\r\n        /**\r\n         * Gets one over the radii of the ellipsoid.\r\n         * @memberof Ellipsoid.prototype\r\n         * @type {Cartesian3}\r\n         * @readonly\r\n         */\r\n        oneOverRadii : {\r\n            get : function() {\r\n                return this._oneOverRadii;\r\n            }\r\n        },\r\n        /**\r\n         * Gets one over the squared radii of the ellipsoid.\r\n         * @memberof Ellipsoid.prototype\r\n         * @type {Cartesian3}\r\n         * @readonly\r\n         */\r\n        oneOverRadiiSquared : {\r\n            get : function() {\r\n                return this._oneOverRadiiSquared;\r\n            }\r\n        },\r\n        /**\r\n         * Gets the minimum radius of the ellipsoid.\r\n         * @memberof Ellipsoid.prototype\r\n         * @type {Number}\r\n         * @readonly\r\n         */\r\n        minimumRadius : {\r\n            get : function() {\r\n                return this._minimumRadius;\r\n            }\r\n        },\r\n        /**\r\n         * Gets the maximum radius of the ellipsoid.\r\n         * @memberof Ellipsoid.prototype\r\n         * @type {Number}\r\n         * @readonly\r\n         */\r\n        maximumRadius : {\r\n            get : function() {\r\n                return this._maximumRadius;\r\n            }\r\n        }\r\n    });\r\n\r\n    /**\r\n     * Duplicates an Ellipsoid instance.\r\n     *\r\n     * @param {Ellipsoid} ellipsoid The ellipsoid to duplicate.\r\n     * @param {Ellipsoid} [result] The object onto which to store the result, or undefined if a new\r\n     *                    instance should be created.\r\n     * @returns {Ellipsoid} The cloned Ellipsoid. (Returns undefined if ellipsoid is undefined)\r\n     */\r\n    Ellipsoid.clone = function(ellipsoid, result) {\r\n        if (!defined(ellipsoid)) {\r\n            return undefined;\r\n        }\r\n        var radii = ellipsoid._radii;\r\n\r\n        if (!defined(result)) {\r\n            return new Ellipsoid(radii.x, radii.y, radii.z);\r\n        }\r\n\r\n        Cartesian3.clone(radii, result._radii);\r\n        Cartesian3.clone(ellipsoid._radiiSquared, result._radiiSquared);\r\n        Cartesian3.clone(ellipsoid._radiiToTheFourth, result._radiiToTheFourth);\r\n        Cartesian3.clone(ellipsoid._oneOverRadii, result._oneOverRadii);\r\n        Cartesian3.clone(ellipsoid._oneOverRadiiSquared, result._oneOverRadiiSquared);\r\n        result._minimumRadius = ellipsoid._minimumRadius;\r\n        result._maximumRadius = ellipsoid._maximumRadius;\r\n        result._centerToleranceSquared = ellipsoid._centerToleranceSquared;\r\n\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Computes an Ellipsoid from a Cartesian specifying the radii in x, y, and z directions.\r\n     *\r\n     * @param {Cartesian3} [cartesian=Cartesian3.ZERO] The ellipsoid's radius in the x, y, and z directions.\r\n     * @param {Ellipsoid} [result] The object onto which to store the result, or undefined if a new\r\n     *                    instance should be created.\r\n     * @returns {Ellipsoid} A new Ellipsoid instance.\r\n     *\r\n     * @exception {DeveloperError} All radii components must be greater than or equal to zero.\r\n     *\r\n     * @see Ellipsoid.WGS84\r\n     * @see Ellipsoid.UNIT_SPHERE\r\n     */\r\n    Ellipsoid.fromCartesian3 = function(cartesian, result) {\r\n        if (!defined(result)) {\r\n            result = new Ellipsoid();\r\n        }\r\n\r\n        if (!defined(cartesian)) {\r\n            return result;\r\n        }\r\n\r\n        initialize(result, cartesian.x, cartesian.y, cartesian.z);\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * An Ellipsoid instance initialized to the WGS84 standard.\r\n     *\r\n     * @type {Ellipsoid}\r\n     * @constant\r\n     */\r\n    Ellipsoid.WGS84 = Object.freeze(new Ellipsoid(6378137.0, 6378137.0, 6356752.3142451793));\r\n\r\n    /**\r\n     * An Ellipsoid instance initialized to radii of (1.0, 1.0, 1.0).\r\n     *\r\n     * @type {Ellipsoid}\r\n     * @constant\r\n     */\r\n    Ellipsoid.UNIT_SPHERE = Object.freeze(new Ellipsoid(1.0, 1.0, 1.0));\r\n\r\n    /**\r\n     * An Ellipsoid instance initialized to a sphere with the lunar radius.\r\n     *\r\n     * @type {Ellipsoid}\r\n     * @constant\r\n     */\r\n    Ellipsoid.MOON = Object.freeze(new Ellipsoid(CesiumMath.LUNAR_RADIUS, CesiumMath.LUNAR_RADIUS, CesiumMath.LUNAR_RADIUS));\r\n\r\n    /**\r\n     * Duplicates an Ellipsoid instance.\r\n     *\r\n     * @param {Ellipsoid} [result] The object onto which to store the result, or undefined if a new\r\n     *                    instance should be created.\r\n     * @returns {Ellipsoid} The cloned Ellipsoid.\r\n     */\r\n    Ellipsoid.prototype.clone = function(result) {\r\n        return Ellipsoid.clone(this, result);\r\n    };\r\n\r\n    /**\r\n     * The number of elements used to pack the object into an array.\r\n     * @type {Number}\r\n     */\r\n    Ellipsoid.packedLength = Cartesian3.packedLength;\r\n\r\n    /**\r\n     * Stores the provided instance into the provided array.\r\n     *\r\n     * @param {Ellipsoid} value The value to pack.\r\n     * @param {Number[]} array The array to pack into.\r\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\r\n     *\r\n     * @returns {Number[]} The array that was packed into\r\n     */\r\n    Ellipsoid.pack = function(value, array, startingIndex) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('value', value);\r\n        Check.defined('array', array);\r\n        //>>includeEnd('debug');\r\n\r\n        startingIndex = defaultValue(startingIndex, 0);\r\n\r\n        Cartesian3.pack(value._radii, array, startingIndex);\r\n\r\n        return array;\r\n    };\r\n\r\n    /**\r\n     * Retrieves an instance from a packed array.\r\n     *\r\n     * @param {Number[]} array The packed array.\r\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\r\n     * @param {Ellipsoid} [result] The object into which to store the result.\r\n     * @returns {Ellipsoid} The modified result parameter or a new Ellipsoid instance if one was not provided.\r\n     */\r\n    Ellipsoid.unpack = function(array, startingIndex, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('array', array);\r\n        //>>includeEnd('debug');\r\n\r\n        startingIndex = defaultValue(startingIndex, 0);\r\n\r\n        var radii = Cartesian3.unpack(array, startingIndex);\r\n        return Ellipsoid.fromCartesian3(radii, result);\r\n    };\r\n\r\n    /**\r\n     * Computes the unit vector directed from the center of this ellipsoid toward the provided Cartesian position.\r\n     * @function\r\n     *\r\n     * @param {Cartesian3} cartesian The Cartesian for which to to determine the geocentric normal.\r\n     * @param {Cartesian3} [result] The object onto which to store the result.\r\n     * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\r\n     */\r\n    Ellipsoid.prototype.geocentricSurfaceNormal = Cartesian3.normalize;\r\n\r\n    /**\r\n     * Computes the normal of the plane tangent to the surface of the ellipsoid at the provided position.\r\n     *\r\n     * @param {Cartographic} cartographic The cartographic position for which to to determine the geodetic normal.\r\n     * @param {Cartesian3} [result] The object onto which to store the result.\r\n     * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\r\n     */\r\n    Ellipsoid.prototype.geodeticSurfaceNormalCartographic = function(cartographic, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('cartographic', cartographic);\r\n        //>>includeEnd('debug');\r\n\r\n        var longitude = cartographic.longitude;\r\n        var latitude = cartographic.latitude;\r\n        var cosLatitude = Math.cos(latitude);\r\n\r\n        var x = cosLatitude * Math.cos(longitude);\r\n        var y = cosLatitude * Math.sin(longitude);\r\n        var z = Math.sin(latitude);\r\n\r\n        if (!defined(result)) {\r\n            result = new Cartesian3();\r\n        }\r\n        result.x = x;\r\n        result.y = y;\r\n        result.z = z;\r\n        return Cartesian3.normalize(result, result);\r\n    };\r\n\r\n    /**\r\n     * Computes the normal of the plane tangent to the surface of the ellipsoid at the provided position.\r\n     *\r\n     * @param {Cartesian3} cartesian The Cartesian position for which to to determine the surface normal.\r\n     * @param {Cartesian3} [result] The object onto which to store the result.\r\n     * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\r\n     */\r\n    Ellipsoid.prototype.geodeticSurfaceNormal = function(cartesian, result) {\r\n        if (!defined(result)) {\r\n            result = new Cartesian3();\r\n        }\r\n        result = Cartesian3.multiplyComponents(cartesian, this._oneOverRadiiSquared, result);\r\n        return Cartesian3.normalize(result, result);\r\n    };\r\n\r\n    var cartographicToCartesianNormal = new Cartesian3();\r\n    var cartographicToCartesianK = new Cartesian3();\r\n\r\n    /**\r\n     * Converts the provided cartographic to Cartesian representation.\r\n     *\r\n     * @param {Cartographic} cartographic The cartographic position.\r\n     * @param {Cartesian3} [result] The object onto which to store the result.\r\n     * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\r\n     *\r\n     * @example\r\n     * //Create a Cartographic and determine it's Cartesian representation on a WGS84 ellipsoid.\r\n     * var position = new Cesium.Cartographic(Cesium.Math.toRadians(21), Cesium.Math.toRadians(78), 5000);\r\n     * var cartesianPosition = Cesium.Ellipsoid.WGS84.cartographicToCartesian(position);\r\n     */\r\n    Ellipsoid.prototype.cartographicToCartesian = function(cartographic, result) {\r\n        //`cartographic is required` is thrown from geodeticSurfaceNormalCartographic.\r\n        var n = cartographicToCartesianNormal;\r\n        var k = cartographicToCartesianK;\r\n        this.geodeticSurfaceNormalCartographic(cartographic, n);\r\n        Cartesian3.multiplyComponents(this._radiiSquared, n, k);\r\n        var gamma = Math.sqrt(Cartesian3.dot(n, k));\r\n        Cartesian3.divideByScalar(k, gamma, k);\r\n        Cartesian3.multiplyByScalar(n, cartographic.height, n);\r\n\r\n        if (!defined(result)) {\r\n            result = new Cartesian3();\r\n        }\r\n        return Cartesian3.add(k, n, result);\r\n    };\r\n\r\n    /**\r\n     * Converts the provided array of cartographics to an array of Cartesians.\r\n     *\r\n     * @param {Cartographic[]} cartographics An array of cartographic positions.\r\n     * @param {Cartesian3[]} [result] The object onto which to store the result.\r\n     * @returns {Cartesian3[]} The modified result parameter or a new Array instance if none was provided.\r\n     *\r\n     * @example\r\n     * //Convert an array of Cartographics and determine their Cartesian representation on a WGS84 ellipsoid.\r\n     * var positions = [new Cesium.Cartographic(Cesium.Math.toRadians(21), Cesium.Math.toRadians(78), 0),\r\n     *                  new Cesium.Cartographic(Cesium.Math.toRadians(21.321), Cesium.Math.toRadians(78.123), 100),\r\n     *                  new Cesium.Cartographic(Cesium.Math.toRadians(21.645), Cesium.Math.toRadians(78.456), 250)];\r\n     * var cartesianPositions = Cesium.Ellipsoid.WGS84.cartographicArrayToCartesianArray(positions);\r\n     */\r\n    Ellipsoid.prototype.cartographicArrayToCartesianArray = function(cartographics, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('cartographics', cartographics);\r\n        //>>includeEnd('debug')\r\n\r\n        var length = cartographics.length;\r\n        if (!defined(result)) {\r\n            result = new Array(length);\r\n        } else {\r\n            result.length = length;\r\n        }\r\n        for ( var i = 0; i < length; i++) {\r\n            result[i] = this.cartographicToCartesian(cartographics[i], result[i]);\r\n        }\r\n        return result;\r\n    };\r\n\r\n    var cartesianToCartographicN = new Cartesian3();\r\n    var cartesianToCartographicP = new Cartesian3();\r\n    var cartesianToCartographicH = new Cartesian3();\r\n\r\n    /**\r\n     * Converts the provided cartesian to cartographic representation.\r\n     * The cartesian is undefined at the center of the ellipsoid.\r\n     *\r\n     * @param {Cartesian3} cartesian The Cartesian position to convert to cartographic representation.\r\n     * @param {Cartographic} [result] The object onto which to store the result.\r\n     * @returns {Cartographic} The modified result parameter, new Cartographic instance if none was provided, or undefined if the cartesian is at the center of the ellipsoid.\r\n     *\r\n     * @example\r\n     * //Create a Cartesian and determine it's Cartographic representation on a WGS84 ellipsoid.\r\n     * var position = new Cesium.Cartesian3(17832.12, 83234.52, 952313.73);\r\n     * var cartographicPosition = Cesium.Ellipsoid.WGS84.cartesianToCartographic(position);\r\n     */\r\n    Ellipsoid.prototype.cartesianToCartographic = function(cartesian, result) {\r\n        //`cartesian is required.` is thrown from scaleToGeodeticSurface\r\n        var p = this.scaleToGeodeticSurface(cartesian, cartesianToCartographicP);\r\n\r\n        if (!defined(p)) {\r\n            return undefined;\r\n        }\r\n\r\n        var n = this.geodeticSurfaceNormal(p, cartesianToCartographicN);\r\n        var h = Cartesian3.subtract(cartesian, p, cartesianToCartographicH);\r\n\r\n        var longitude = Math.atan2(n.y, n.x);\r\n        var latitude = Math.asin(n.z);\r\n        var height = CesiumMath.sign(Cartesian3.dot(h, cartesian)) * Cartesian3.magnitude(h);\r\n\r\n        if (!defined(result)) {\r\n            return new Cartographic(longitude, latitude, height);\r\n        }\r\n        result.longitude = longitude;\r\n        result.latitude = latitude;\r\n        result.height = height;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Converts the provided array of cartesians to an array of cartographics.\r\n     *\r\n     * @param {Cartesian3[]} cartesians An array of Cartesian positions.\r\n     * @param {Cartographic[]} [result] The object onto which to store the result.\r\n     * @returns {Cartographic[]} The modified result parameter or a new Array instance if none was provided.\r\n     *\r\n     * @example\r\n     * //Create an array of Cartesians and determine their Cartographic representation on a WGS84 ellipsoid.\r\n     * var positions = [new Cesium.Cartesian3(17832.12, 83234.52, 952313.73),\r\n     *                  new Cesium.Cartesian3(17832.13, 83234.53, 952313.73),\r\n     *                  new Cesium.Cartesian3(17832.14, 83234.54, 952313.73)]\r\n     * var cartographicPositions = Cesium.Ellipsoid.WGS84.cartesianArrayToCartographicArray(positions);\r\n     */\r\n    Ellipsoid.prototype.cartesianArrayToCartographicArray = function(cartesians, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('cartesians', cartesians);\r\n        //>>includeEnd('debug');\r\n\r\n        var length = cartesians.length;\r\n        if (!defined(result)) {\r\n            result = new Array(length);\r\n        } else {\r\n            result.length = length;\r\n        }\r\n        for ( var i = 0; i < length; ++i) {\r\n            result[i] = this.cartesianToCartographic(cartesians[i], result[i]);\r\n        }\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Scales the provided Cartesian position along the geodetic surface normal\r\n     * so that it is on the surface of this ellipsoid.  If the position is\r\n     * at the center of the ellipsoid, this function returns undefined.\r\n     *\r\n     * @param {Cartesian3} cartesian The Cartesian position to scale.\r\n     * @param {Cartesian3} [result] The object onto which to store the result.\r\n     * @returns {Cartesian3} The modified result parameter, a new Cartesian3 instance if none was provided, or undefined if the position is at the center.\r\n     */\r\n    Ellipsoid.prototype.scaleToGeodeticSurface = function(cartesian, result) {\r\n        return scaleToGeodeticSurface(cartesian, this._oneOverRadii, this._oneOverRadiiSquared, this._centerToleranceSquared, result);\r\n    };\r\n\r\n    /**\r\n     * Scales the provided Cartesian position along the geocentric surface normal\r\n     * so that it is on the surface of this ellipsoid.\r\n     *\r\n     * @param {Cartesian3} cartesian The Cartesian position to scale.\r\n     * @param {Cartesian3} [result] The object onto which to store the result.\r\n     * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\r\n     */\r\n    Ellipsoid.prototype.scaleToGeocentricSurface = function(cartesian, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('cartesian', cartesian);\r\n        //>>includeEnd('debug');\r\n\r\n        if (!defined(result)) {\r\n            result = new Cartesian3();\r\n        }\r\n\r\n        var positionX = cartesian.x;\r\n        var positionY = cartesian.y;\r\n        var positionZ = cartesian.z;\r\n        var oneOverRadiiSquared = this._oneOverRadiiSquared;\r\n\r\n        var beta = 1.0 / Math.sqrt((positionX * positionX) * oneOverRadiiSquared.x +\r\n                                   (positionY * positionY) * oneOverRadiiSquared.y +\r\n                                   (positionZ * positionZ) * oneOverRadiiSquared.z);\r\n\r\n        return Cartesian3.multiplyByScalar(cartesian, beta, result);\r\n    };\r\n\r\n    /**\r\n     * Transforms a Cartesian X, Y, Z position to the ellipsoid-scaled space by multiplying\r\n     * its components by the result of {@link Ellipsoid#oneOverRadii}.\r\n     *\r\n     * @param {Cartesian3} position The position to transform.\r\n     * @param {Cartesian3} [result] The position to which to copy the result, or undefined to create and\r\n     *        return a new instance.\r\n     * @returns {Cartesian3} The position expressed in the scaled space.  The returned instance is the\r\n     *          one passed as the result parameter if it is not undefined, or a new instance of it is.\r\n     */\r\n    Ellipsoid.prototype.transformPositionToScaledSpace = function(position, result) {\r\n        if (!defined(result)) {\r\n            result = new Cartesian3();\r\n        }\r\n\r\n        return Cartesian3.multiplyComponents(position, this._oneOverRadii, result);\r\n    };\r\n\r\n    /**\r\n     * Transforms a Cartesian X, Y, Z position from the ellipsoid-scaled space by multiplying\r\n     * its components by the result of {@link Ellipsoid#radii}.\r\n     *\r\n     * @param {Cartesian3} position The position to transform.\r\n     * @param {Cartesian3} [result] The position to which to copy the result, or undefined to create and\r\n     *        return a new instance.\r\n     * @returns {Cartesian3} The position expressed in the unscaled space.  The returned instance is the\r\n     *          one passed as the result parameter if it is not undefined, or a new instance of it is.\r\n     */\r\n    Ellipsoid.prototype.transformPositionFromScaledSpace = function(position, result) {\r\n        if (!defined(result)) {\r\n            result = new Cartesian3();\r\n        }\r\n\r\n        return Cartesian3.multiplyComponents(position, this._radii, result);\r\n    };\r\n\r\n    /**\r\n     * Compares this Ellipsoid against the provided Ellipsoid componentwise and returns\r\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\r\n     *\r\n     * @param {Ellipsoid} [right] The other Ellipsoid.\r\n     * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\r\n     */\r\n    Ellipsoid.prototype.equals = function(right) {\r\n        return (this === right) ||\r\n               (defined(right) &&\r\n                Cartesian3.equals(this._radii, right._radii));\r\n    };\r\n\r\n    /**\r\n     * Creates a string representing this Ellipsoid in the format '(radii.x, radii.y, radii.z)'.\r\n     *\r\n     * @returns {String} A string representing this ellipsoid in the format '(radii.x, radii.y, radii.z)'.\r\n     */\r\n    Ellipsoid.prototype.toString = function() {\r\n        return this._radii.toString();\r\n    };\r\n\r\n    /**\r\n     * Computes a point which is the intersection of the surface normal with the z-axis.\r\n     *\r\n     * @param {Cartesian3} position the position. must be on the surface of the ellipsoid.\r\n     * @param {Number} [buffer = 0.0] A buffer to subtract from the ellipsoid size when checking if the point is inside the ellipsoid.\r\n     *                                In earth case, with common earth datums, there is no need for this buffer since the intersection point is always (relatively) very close to the center.\r\n     *                                In WGS84 datum, intersection point is at max z = +-42841.31151331382 (0.673% of z-axis).\r\n     *                                Intersection point could be outside the ellipsoid if the ratio of MajorAxis / AxisOfRotation is bigger than the square root of 2\r\n     * @param {Cartesian3} [result] The cartesian to which to copy the result, or undefined to create and\r\n     *        return a new instance.\r\n     * @returns {Cartesian3 | undefined} the intersection point if it's inside the ellipsoid, undefined otherwise\r\n     *\r\n     * @exception {DeveloperError} position is required.\r\n     * @exception {DeveloperError} Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y).\r\n     * @exception {DeveloperError} Ellipsoid.radii.z must be greater than 0.\r\n     */\r\n    Ellipsoid.prototype.getSurfaceNormalIntersectionWithZAxis = function(position, buffer, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('position', position);\r\n\r\n        if (!CesiumMath.equalsEpsilon(this._radii.x, this._radii.y, CesiumMath.EPSILON15)) {\r\n            throw new DeveloperError('Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y)');\r\n        }\r\n\r\n        Check.typeOf.number.greaterThan('Ellipsoid.radii.z', this._radii.z, 0);\r\n        //>>includeEnd('debug');\r\n\r\n        buffer = defaultValue(buffer, 0.0);\r\n\r\n        var squaredXOverSquaredZ = this._squaredXOverSquaredZ;\r\n\r\n        if (!defined(result)) {\r\n            result = new Cartesian3();\r\n        }\r\n\r\n        result.x = 0.0;\r\n        result.y = 0.0;\r\n        result.z = position.z * (1 - squaredXOverSquaredZ);\r\n\r\n        if (Math.abs(result.z) >= this._radii.z - buffer) {\r\n            return undefined;\r\n        }\r\n\r\n        return result;\r\n    };\r\nexport default Ellipsoid;\r\n","import Cartographic from './Cartographic.js';\r\nimport Check from './Check.js';\r\nimport defaultValue from './defaultValue.js';\r\nimport defined from './defined.js';\r\nimport Ellipsoid from './Ellipsoid.js';\r\nimport CesiumMath from './Math.js';\r\n\r\n    /**\r\n     * A two dimensional region specified as longitude and latitude coordinates.\r\n     *\r\n     * @alias Rectangle\r\n     * @constructor\r\n     *\r\n     * @param {Number} [west=0.0] The westernmost longitude, in radians, in the range [-Pi, Pi].\r\n     * @param {Number} [south=0.0] The southernmost latitude, in radians, in the range [-Pi/2, Pi/2].\r\n     * @param {Number} [east=0.0] The easternmost longitude, in radians, in the range [-Pi, Pi].\r\n     * @param {Number} [north=0.0] The northernmost latitude, in radians, in the range [-Pi/2, Pi/2].\r\n     *\r\n     * @see Packable\r\n     */\r\n    function Rectangle(west, south, east, north) {\r\n        /**\r\n         * The westernmost longitude in radians in the range [-Pi, Pi].\r\n         *\r\n         * @type {Number}\r\n         * @default 0.0\r\n         */\r\n        this.west = defaultValue(west, 0.0);\r\n\r\n        /**\r\n         * The southernmost latitude in radians in the range [-Pi/2, Pi/2].\r\n         *\r\n         * @type {Number}\r\n         * @default 0.0\r\n         */\r\n        this.south = defaultValue(south, 0.0);\r\n\r\n        /**\r\n         * The easternmost longitude in radians in the range [-Pi, Pi].\r\n         *\r\n         * @type {Number}\r\n         * @default 0.0\r\n         */\r\n        this.east = defaultValue(east, 0.0);\r\n\r\n        /**\r\n         * The northernmost latitude in radians in the range [-Pi/2, Pi/2].\r\n         *\r\n         * @type {Number}\r\n         * @default 0.0\r\n         */\r\n        this.north = defaultValue(north, 0.0);\r\n    }\r\n\r\n    Object.defineProperties(Rectangle.prototype, {\r\n        /**\r\n         * Gets the width of the rectangle in radians.\r\n         * @memberof Rectangle.prototype\r\n         * @type {Number}\r\n         */\r\n        width : {\r\n            get : function() {\r\n                return Rectangle.computeWidth(this);\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Gets the height of the rectangle in radians.\r\n         * @memberof Rectangle.prototype\r\n         * @type {Number}\r\n         */\r\n        height : {\r\n            get : function() {\r\n                return Rectangle.computeHeight(this);\r\n            }\r\n        }\r\n    });\r\n\r\n    /**\r\n     * The number of elements used to pack the object into an array.\r\n     * @type {Number}\r\n     */\r\n    Rectangle.packedLength = 4;\r\n\r\n    /**\r\n     * Stores the provided instance into the provided array.\r\n     *\r\n     * @param {Rectangle} value The value to pack.\r\n     * @param {Number[]} array The array to pack into.\r\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\r\n     *\r\n     * @returns {Number[]} The array that was packed into\r\n     */\r\n    Rectangle.pack = function(value, array, startingIndex) {\r\n        startingIndex = defaultValue(startingIndex, 0);\r\n\r\n        array[startingIndex++] = value.west;\r\n        array[startingIndex++] = value.south;\r\n        array[startingIndex++] = value.east;\r\n        array[startingIndex] = value.north;\r\n\r\n        return array;\r\n    };\r\n\r\n    /**\r\n     * Retrieves an instance from a packed array.\r\n     *\r\n     * @param {Number[]} array The packed array.\r\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\r\n     * @param {Rectangle} [result] The object into which to store the result.\r\n     * @returns {Rectangle} The modified result parameter or a new Rectangle instance if one was not provided.\r\n     */\r\n    Rectangle.unpack = function(array, startingIndex, result) {\r\n        startingIndex = defaultValue(startingIndex, 0);\r\n\r\n        if (!defined(result)) {\r\n            result = new Rectangle();\r\n        }\r\n\r\n        result.west = array[startingIndex++];\r\n        result.south = array[startingIndex++];\r\n        result.east = array[startingIndex++];\r\n        result.north = array[startingIndex];\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Computes the width of a rectangle in radians.\r\n     * @param {Rectangle} rectangle The rectangle to compute the width of.\r\n     * @returns {Number} The width.\r\n     */\r\n    Rectangle.computeWidth = function(rectangle) {\r\n        var east = rectangle.east;\r\n        var west = rectangle.west;\r\n        if (east < west) {\r\n            east += CesiumMath.TWO_PI;\r\n        }\r\n        return east - west;\r\n    };\r\n\r\n    /**\r\n     * Computes the height of a rectangle in radians.\r\n     * @param {Rectangle} rectangle The rectangle to compute the height of.\r\n     * @returns {Number} The height.\r\n     */\r\n    Rectangle.computeHeight = function(rectangle) {\r\n        return rectangle.north - rectangle.south;\r\n    };\r\n\r\n    /**\r\n     * Creates a rectangle given the boundary longitude and latitude in degrees.\r\n     *\r\n     * @param {Number} [west=0.0] The westernmost longitude in degrees in the range [-180.0, 180.0].\r\n     * @param {Number} [south=0.0] The southernmost latitude in degrees in the range [-90.0, 90.0].\r\n     * @param {Number} [east=0.0] The easternmost longitude in degrees in the range [-180.0, 180.0].\r\n     * @param {Number} [north=0.0] The northernmost latitude in degrees in the range [-90.0, 90.0].\r\n     * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.\r\n     * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\r\n     *\r\n     * @example\r\n     * var rectangle = Cesium.Rectangle.fromDegrees(0.0, 20.0, 10.0, 30.0);\r\n     */\r\n    Rectangle.fromDegrees = function(west, south, east, north, result) {\r\n        west = CesiumMath.toRadians(defaultValue(west, 0.0));\r\n        south = CesiumMath.toRadians(defaultValue(south, 0.0));\r\n        east = CesiumMath.toRadians(defaultValue(east, 0.0));\r\n        north = CesiumMath.toRadians(defaultValue(north, 0.0));\r\n\r\n        if (!defined(result)) {\r\n            return new Rectangle(west, south, east, north);\r\n        }\r\n\r\n        result.west = west;\r\n        result.south = south;\r\n        result.east = east;\r\n        result.north = north;\r\n\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Creates a rectangle given the boundary longitude and latitude in radians.\r\n     *\r\n     * @param {Number} [west=0.0] The westernmost longitude in radians in the range [-Math.PI, Math.PI].\r\n     * @param {Number} [south=0.0] The southernmost latitude in radians in the range [-Math.PI/2, Math.PI/2].\r\n     * @param {Number} [east=0.0] The easternmost longitude in radians in the range [-Math.PI, Math.PI].\r\n     * @param {Number} [north=0.0] The northernmost latitude in radians in the range [-Math.PI/2, Math.PI/2].\r\n     * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.\r\n     * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\r\n     *\r\n     * @example\r\n     * var rectangle = Cesium.Rectangle.fromRadians(0.0, Math.PI/4, Math.PI/8, 3*Math.PI/4);\r\n     */\r\n    Rectangle.fromRadians = function(west, south, east, north, result) {\r\n        if (!defined(result)) {\r\n            return new Rectangle(west, south, east, north);\r\n        }\r\n\r\n        result.west = defaultValue(west, 0.0);\r\n        result.south = defaultValue(south, 0.0);\r\n        result.east = defaultValue(east, 0.0);\r\n        result.north = defaultValue(north, 0.0);\r\n\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Creates the smallest possible Rectangle that encloses all positions in the provided array.\r\n     *\r\n     * @param {Cartographic[]} cartographics The list of Cartographic instances.\r\n     * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.\r\n     * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\r\n     */\r\n    Rectangle.fromCartographicArray = function(cartographics, result) {\r\n        var west = Number.MAX_VALUE;\r\n        var east = -Number.MAX_VALUE;\r\n        var westOverIDL = Number.MAX_VALUE;\r\n        var eastOverIDL = -Number.MAX_VALUE;\r\n        var south = Number.MAX_VALUE;\r\n        var north = -Number.MAX_VALUE;\r\n\r\n        for ( var i = 0, len = cartographics.length; i < len; i++) {\r\n            var position = cartographics[i];\r\n            west = Math.min(west, position.longitude);\r\n            east = Math.max(east, position.longitude);\r\n            south = Math.min(south, position.latitude);\r\n            north = Math.max(north, position.latitude);\r\n\r\n            var lonAdjusted = position.longitude >= 0 ?  position.longitude : position.longitude +  CesiumMath.TWO_PI;\r\n            westOverIDL = Math.min(westOverIDL, lonAdjusted);\r\n            eastOverIDL = Math.max(eastOverIDL, lonAdjusted);\r\n        }\r\n\r\n        if(east - west > eastOverIDL - westOverIDL) {\r\n            west = westOverIDL;\r\n            east = eastOverIDL;\r\n\r\n            if (east > CesiumMath.PI) {\r\n                east = east - CesiumMath.TWO_PI;\r\n            }\r\n            if (west > CesiumMath.PI) {\r\n                west = west - CesiumMath.TWO_PI;\r\n            }\r\n        }\r\n\r\n        if (!defined(result)) {\r\n            return new Rectangle(west, south, east, north);\r\n        }\r\n\r\n        result.west = west;\r\n        result.south = south;\r\n        result.east = east;\r\n        result.north = north;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Creates the smallest possible Rectangle that encloses all positions in the provided array.\r\n     *\r\n     * @param {Cartesian3[]} cartesians The list of Cartesian instances.\r\n     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid the cartesians are on.\r\n     * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.\r\n     * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\r\n     */\r\n    Rectangle.fromCartesianArray = function(cartesians, ellipsoid, result) {\r\n        ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\r\n\r\n        var west = Number.MAX_VALUE;\r\n        var east = -Number.MAX_VALUE;\r\n        var westOverIDL = Number.MAX_VALUE;\r\n        var eastOverIDL = -Number.MAX_VALUE;\r\n        var south = Number.MAX_VALUE;\r\n        var north = -Number.MAX_VALUE;\r\n\r\n        for ( var i = 0, len = cartesians.length; i < len; i++) {\r\n            var position = ellipsoid.cartesianToCartographic(cartesians[i]);\r\n            west = Math.min(west, position.longitude);\r\n            east = Math.max(east, position.longitude);\r\n            south = Math.min(south, position.latitude);\r\n            north = Math.max(north, position.latitude);\r\n\r\n            var lonAdjusted = position.longitude >= 0 ?  position.longitude : position.longitude +  CesiumMath.TWO_PI;\r\n            westOverIDL = Math.min(westOverIDL, lonAdjusted);\r\n            eastOverIDL = Math.max(eastOverIDL, lonAdjusted);\r\n        }\r\n\r\n        if(east - west > eastOverIDL - westOverIDL) {\r\n            west = westOverIDL;\r\n            east = eastOverIDL;\r\n\r\n            if (east > CesiumMath.PI) {\r\n                east = east - CesiumMath.TWO_PI;\r\n            }\r\n            if (west > CesiumMath.PI) {\r\n                west = west - CesiumMath.TWO_PI;\r\n            }\r\n        }\r\n\r\n        if (!defined(result)) {\r\n            return new Rectangle(west, south, east, north);\r\n        }\r\n\r\n        result.west = west;\r\n        result.south = south;\r\n        result.east = east;\r\n        result.north = north;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Duplicates a Rectangle.\r\n     *\r\n     * @param {Rectangle} rectangle The rectangle to clone.\r\n     * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.\r\n     * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided. (Returns undefined if rectangle is undefined)\r\n     */\r\n    Rectangle.clone = function(rectangle, result) {\r\n        if (!defined(rectangle)) {\r\n            return undefined;\r\n        }\r\n\r\n        if (!defined(result)) {\r\n            return new Rectangle(rectangle.west, rectangle.south, rectangle.east, rectangle.north);\r\n        }\r\n\r\n        result.west = rectangle.west;\r\n        result.south = rectangle.south;\r\n        result.east = rectangle.east;\r\n        result.north = rectangle.north;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Compares the provided Rectangles componentwise and returns\r\n     * <code>true</code> if they pass an absolute or relative tolerance test,\r\n     * <code>false</code> otherwise.\r\n     *\r\n     * @param {Rectangle} [left] The first Rectangle.\r\n     * @param {Rectangle} [right] The second Rectangle.\r\n     * @param {Number} [absoluteEpsilon=0] The absolute epsilon tolerance to use for equality testing.\r\n     * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\r\n     */\r\n    Rectangle.equalsEpsilon = function(left, right, absoluteEpsilon) {\r\n        absoluteEpsilon = defaultValue(absoluteEpsilon, 0);\r\n\r\n        return (left === right) ||\r\n               (defined(left) &&\r\n                defined(right) &&\r\n                (Math.abs(left.west - right.west) <= absoluteEpsilon) &&\r\n                (Math.abs(left.south - right.south) <= absoluteEpsilon) &&\r\n                (Math.abs(left.east - right.east) <= absoluteEpsilon) &&\r\n                (Math.abs(left.north - right.north) <= absoluteEpsilon));\r\n    };\r\n\r\n    /**\r\n     * Duplicates this Rectangle.\r\n     *\r\n     * @param {Rectangle} [result] The object onto which to store the result.\r\n     * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\r\n     */\r\n    Rectangle.prototype.clone = function(result) {\r\n        return Rectangle.clone(this, result);\r\n    };\r\n\r\n    /**\r\n     * Compares the provided Rectangle with this Rectangle componentwise and returns\r\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\r\n     *\r\n     * @param {Rectangle} [other] The Rectangle to compare.\r\n     * @returns {Boolean} <code>true</code> if the Rectangles are equal, <code>false</code> otherwise.\r\n     */\r\n    Rectangle.prototype.equals = function(other) {\r\n        return Rectangle.equals(this, other);\r\n    };\r\n\r\n    /**\r\n     * Compares the provided rectangles and returns <code>true</code> if they are equal,\r\n     * <code>false</code> otherwise.\r\n     *\r\n     * @param {Rectangle} [left] The first Rectangle.\r\n     * @param {Rectangle} [right] The second Rectangle.\r\n     * @returns {Boolean} <code>true</code> if left and right are equal; otherwise <code>false</code>.\r\n     */\r\n    Rectangle.equals = function(left, right) {\r\n        return (left === right) ||\r\n               ((defined(left)) &&\r\n                (defined(right)) &&\r\n                (left.west === right.west) &&\r\n                (left.south === right.south) &&\r\n                (left.east === right.east) &&\r\n                (left.north === right.north));\r\n    };\r\n\r\n    /**\r\n     * Compares the provided Rectangle with this Rectangle componentwise and returns\r\n     * <code>true</code> if they are within the provided epsilon,\r\n     * <code>false</code> otherwise.\r\n     *\r\n     * @param {Rectangle} [other] The Rectangle to compare.\r\n     * @param {Number} [epsilon=0] The epsilon to use for equality testing.\r\n     * @returns {Boolean} <code>true</code> if the Rectangles are within the provided epsilon, <code>false</code> otherwise.\r\n     */\r\n    Rectangle.prototype.equalsEpsilon = function(other, epsilon) {\r\n        epsilon = defaultValue(epsilon, 0);\r\n\r\n        return Rectangle.equalsEpsilon(this, other, epsilon);\r\n    };\r\n\r\n    /**\r\n     * Checks a Rectangle's properties and throws if they are not in valid ranges.\r\n     *\r\n     * @param {Rectangle} rectangle The rectangle to validate\r\n     *\r\n     * @exception {DeveloperError} <code>north</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].\r\n     * @exception {DeveloperError} <code>south</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].\r\n     * @exception {DeveloperError} <code>east</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].\r\n     * @exception {DeveloperError} <code>west</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].\r\n     */\r\n    Rectangle.validate = function(rectangle) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('rectangle', rectangle);\r\n\r\n        var north = rectangle.north;\r\n        Check.typeOf.number.greaterThanOrEquals('north', north, -CesiumMath.PI_OVER_TWO);\r\n        Check.typeOf.number.lessThanOrEquals('north', north, CesiumMath.PI_OVER_TWO);\r\n\r\n        var south = rectangle.south;\r\n        Check.typeOf.number.greaterThanOrEquals('south', south, -CesiumMath.PI_OVER_TWO);\r\n        Check.typeOf.number.lessThanOrEquals('south', south, CesiumMath.PI_OVER_TWO);\r\n\r\n        var west = rectangle.west;\r\n        Check.typeOf.number.greaterThanOrEquals('west', west, -Math.PI);\r\n        Check.typeOf.number.lessThanOrEquals('west', west, Math.PI);\r\n\r\n        var east = rectangle.east;\r\n        Check.typeOf.number.greaterThanOrEquals('east', east, -Math.PI);\r\n        Check.typeOf.number.lessThanOrEquals('east', east, Math.PI);\r\n        //>>includeEnd('debug');\r\n    };\r\n\r\n    /**\r\n     * Computes the southwest corner of a rectangle.\r\n     *\r\n     * @param {Rectangle} rectangle The rectangle for which to find the corner\r\n     * @param {Cartographic} [result] The object onto which to store the result.\r\n     * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.\r\n     */\r\n    Rectangle.southwest = function(rectangle, result) {\r\n        if (!defined(result)) {\r\n            return new Cartographic(rectangle.west, rectangle.south);\r\n        }\r\n        result.longitude = rectangle.west;\r\n        result.latitude = rectangle.south;\r\n        result.height = 0.0;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Computes the northwest corner of a rectangle.\r\n     *\r\n     * @param {Rectangle} rectangle The rectangle for which to find the corner\r\n     * @param {Cartographic} [result] The object onto which to store the result.\r\n     * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.\r\n     */\r\n    Rectangle.northwest = function(rectangle, result) {\r\n        if (!defined(result)) {\r\n            return new Cartographic(rectangle.west, rectangle.north);\r\n        }\r\n        result.longitude = rectangle.west;\r\n        result.latitude = rectangle.north;\r\n        result.height = 0.0;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Computes the northeast corner of a rectangle.\r\n     *\r\n     * @param {Rectangle} rectangle The rectangle for which to find the corner\r\n     * @param {Cartographic} [result] The object onto which to store the result.\r\n     * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.\r\n     */\r\n    Rectangle.northeast = function(rectangle, result) {\r\n        if (!defined(result)) {\r\n            return new Cartographic(rectangle.east, rectangle.north);\r\n        }\r\n        result.longitude = rectangle.east;\r\n        result.latitude = rectangle.north;\r\n        result.height = 0.0;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Computes the southeast corner of a rectangle.\r\n     *\r\n     * @param {Rectangle} rectangle The rectangle for which to find the corner\r\n     * @param {Cartographic} [result] The object onto which to store the result.\r\n     * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.\r\n     */\r\n    Rectangle.southeast = function(rectangle, result) {\r\n        if (!defined(result)) {\r\n            return new Cartographic(rectangle.east, rectangle.south);\r\n        }\r\n        result.longitude = rectangle.east;\r\n        result.latitude = rectangle.south;\r\n        result.height = 0.0;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Computes the center of a rectangle.\r\n     *\r\n     * @param {Rectangle} rectangle The rectangle for which to find the center\r\n     * @param {Cartographic} [result] The object onto which to store the result.\r\n     * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.\r\n     */\r\n    Rectangle.center = function(rectangle, result) {\r\n        var east = rectangle.east;\r\n        var west = rectangle.west;\r\n\r\n        if (east < west) {\r\n            east += CesiumMath.TWO_PI;\r\n        }\r\n\r\n        var longitude = CesiumMath.negativePiToPi((west + east) * 0.5);\r\n        var latitude = (rectangle.south + rectangle.north) * 0.5;\r\n\r\n        if (!defined(result)) {\r\n            return new Cartographic(longitude, latitude);\r\n        }\r\n\r\n        result.longitude = longitude;\r\n        result.latitude = latitude;\r\n        result.height = 0.0;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Computes the intersection of two rectangles.  This function assumes that the rectangle's coordinates are\r\n     * latitude and longitude in radians and produces a correct intersection, taking into account the fact that\r\n     * the same angle can be represented with multiple values as well as the wrapping of longitude at the\r\n     * anti-meridian.  For a simple intersection that ignores these factors and can be used with projected\r\n     * coordinates, see {@link Rectangle.simpleIntersection}.\r\n     *\r\n     * @param {Rectangle} rectangle On rectangle to find an intersection\r\n     * @param {Rectangle} otherRectangle Another rectangle to find an intersection\r\n     * @param {Rectangle} [result] The object onto which to store the result.\r\n     * @returns {Rectangle|undefined} The modified result parameter, a new Rectangle instance if none was provided or undefined if there is no intersection.\r\n     */\r\n    Rectangle.intersection = function(rectangle, otherRectangle, result) {\r\n        var rectangleEast = rectangle.east;\r\n        var rectangleWest = rectangle.west;\r\n\r\n        var otherRectangleEast = otherRectangle.east;\r\n        var otherRectangleWest = otherRectangle.west;\r\n\r\n        if (rectangleEast < rectangleWest && otherRectangleEast > 0.0) {\r\n            rectangleEast += CesiumMath.TWO_PI;\r\n        } else if (otherRectangleEast < otherRectangleWest && rectangleEast > 0.0) {\r\n            otherRectangleEast += CesiumMath.TWO_PI;\r\n        }\r\n\r\n        if (rectangleEast < rectangleWest && otherRectangleWest < 0.0) {\r\n            otherRectangleWest += CesiumMath.TWO_PI;\r\n        } else if (otherRectangleEast < otherRectangleWest && rectangleWest < 0.0) {\r\n            rectangleWest += CesiumMath.TWO_PI;\r\n        }\r\n\r\n        var west = CesiumMath.negativePiToPi(Math.max(rectangleWest, otherRectangleWest));\r\n        var east = CesiumMath.negativePiToPi(Math.min(rectangleEast, otherRectangleEast));\r\n\r\n        if ((rectangle.west < rectangle.east || otherRectangle.west < otherRectangle.east) && east <= west) {\r\n            return undefined;\r\n        }\r\n\r\n        var south = Math.max(rectangle.south, otherRectangle.south);\r\n        var north = Math.min(rectangle.north, otherRectangle.north);\r\n\r\n        if (south >= north) {\r\n            return undefined;\r\n        }\r\n\r\n        if (!defined(result)) {\r\n            return new Rectangle(west, south, east, north);\r\n        }\r\n        result.west = west;\r\n        result.south = south;\r\n        result.east = east;\r\n        result.north = north;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Computes a simple intersection of two rectangles.  Unlike {@link Rectangle.intersection}, this function\r\n     * does not attempt to put the angular coordinates into a consistent range or to account for crossing the\r\n     * anti-meridian.  As such, it can be used for rectangles where the coordinates are not simply latitude\r\n     * and longitude (i.e. projected coordinates).\r\n     *\r\n     * @param {Rectangle} rectangle On rectangle to find an intersection\r\n     * @param {Rectangle} otherRectangle Another rectangle to find an intersection\r\n     * @param {Rectangle} [result] The object onto which to store the result.\r\n     * @returns {Rectangle|undefined} The modified result parameter, a new Rectangle instance if none was provided or undefined if there is no intersection.\r\n     */\r\n    Rectangle.simpleIntersection = function(rectangle, otherRectangle, result) {\r\n        var west = Math.max(rectangle.west, otherRectangle.west);\r\n        var south = Math.max(rectangle.south, otherRectangle.south);\r\n        var east = Math.min(rectangle.east, otherRectangle.east);\r\n        var north = Math.min(rectangle.north, otherRectangle.north);\r\n\r\n        if (south >= north || west >= east) {\r\n            return undefined;\r\n        }\r\n\r\n        if (!defined(result)) {\r\n            return new Rectangle(west, south, east, north);\r\n        }\r\n\r\n        result.west = west;\r\n        result.south = south;\r\n        result.east = east;\r\n        result.north = north;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Computes a rectangle that is the union of two rectangles.\r\n     *\r\n     * @param {Rectangle} rectangle A rectangle to enclose in rectangle.\r\n     * @param {Rectangle} otherRectangle A rectangle to enclose in a rectangle.\r\n     * @param {Rectangle} [result] The object onto which to store the result.\r\n     * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\r\n     */\r\n    Rectangle.union = function(rectangle, otherRectangle, result) {\r\n        if (!defined(result)) {\r\n            result = new Rectangle();\r\n        }\r\n\r\n        var rectangleEast = rectangle.east;\r\n        var rectangleWest = rectangle.west;\r\n\r\n        var otherRectangleEast = otherRectangle.east;\r\n        var otherRectangleWest = otherRectangle.west;\r\n\r\n        if (rectangleEast < rectangleWest && otherRectangleEast > 0.0) {\r\n            rectangleEast += CesiumMath.TWO_PI;\r\n        } else if (otherRectangleEast < otherRectangleWest && rectangleEast > 0.0) {\r\n            otherRectangleEast += CesiumMath.TWO_PI;\r\n        }\r\n\r\n        if (rectangleEast < rectangleWest && otherRectangleWest < 0.0) {\r\n            otherRectangleWest += CesiumMath.TWO_PI;\r\n        } else if (otherRectangleEast < otherRectangleWest && rectangleWest < 0.0) {\r\n            rectangleWest += CesiumMath.TWO_PI;\r\n        }\r\n\r\n        var west = CesiumMath.convertLongitudeRange(Math.min(rectangleWest, otherRectangleWest));\r\n        var east = CesiumMath.convertLongitudeRange(Math.max(rectangleEast, otherRectangleEast));\r\n\r\n        result.west = west;\r\n        result.south = Math.min(rectangle.south, otherRectangle.south);\r\n        result.east = east;\r\n        result.north = Math.max(rectangle.north, otherRectangle.north);\r\n\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Computes a rectangle by enlarging the provided rectangle until it contains the provided cartographic.\r\n     *\r\n     * @param {Rectangle} rectangle A rectangle to expand.\r\n     * @param {Cartographic} cartographic A cartographic to enclose in a rectangle.\r\n     * @param {Rectangle} [result] The object onto which to store the result.\r\n     * @returns {Rectangle} The modified result parameter or a new Rectangle instance if one was not provided.\r\n     */\r\n    Rectangle.expand = function(rectangle, cartographic, result) {\r\n        if (!defined(result)) {\r\n            result = new Rectangle();\r\n        }\r\n\r\n        result.west = Math.min(rectangle.west, cartographic.longitude);\r\n        result.south = Math.min(rectangle.south, cartographic.latitude);\r\n        result.east = Math.max(rectangle.east, cartographic.longitude);\r\n        result.north = Math.max(rectangle.north, cartographic.latitude);\r\n\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Returns true if the cartographic is on or inside the rectangle, false otherwise.\r\n     *\r\n     * @param {Rectangle} rectangle The rectangle\r\n     * @param {Cartographic} cartographic The cartographic to test.\r\n     * @returns {Boolean} true if the provided cartographic is inside the rectangle, false otherwise.\r\n     */\r\n    Rectangle.contains = function(rectangle, cartographic) {\r\n        var longitude = cartographic.longitude;\r\n        var latitude = cartographic.latitude;\r\n\r\n        var west = rectangle.west;\r\n        var east = rectangle.east;\r\n\r\n        if (east < west) {\r\n            east += CesiumMath.TWO_PI;\r\n            if (longitude < 0.0) {\r\n                longitude += CesiumMath.TWO_PI;\r\n            }\r\n        }\r\n        return (longitude > west || CesiumMath.equalsEpsilon(longitude, west, CesiumMath.EPSILON14)) &&\r\n               (longitude < east || CesiumMath.equalsEpsilon(longitude, east, CesiumMath.EPSILON14)) &&\r\n               latitude >= rectangle.south &&\r\n               latitude <= rectangle.north;\r\n    };\r\n\r\n    var subsampleLlaScratch = new Cartographic();\r\n    /**\r\n     * Samples a rectangle so that it includes a list of Cartesian points suitable for passing to\r\n     * {@link BoundingSphere#fromPoints}.  Sampling is necessary to account\r\n     * for rectangles that cover the poles or cross the equator.\r\n     *\r\n     * @param {Rectangle} rectangle The rectangle to subsample.\r\n     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid to use.\r\n     * @param {Number} [surfaceHeight=0.0] The height of the rectangle above the ellipsoid.\r\n     * @param {Cartesian3[]} [result] The array of Cartesians onto which to store the result.\r\n     * @returns {Cartesian3[]} The modified result parameter or a new Array of Cartesians instances if none was provided.\r\n     */\r\n    Rectangle.subsample = function(rectangle, ellipsoid, surfaceHeight, result) {\r\n        ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\r\n        surfaceHeight = defaultValue(surfaceHeight, 0.0);\r\n\r\n        if (!defined(result)) {\r\n            result = [];\r\n        }\r\n        var length = 0;\r\n\r\n        var north = rectangle.north;\r\n        var south = rectangle.south;\r\n        var east = rectangle.east;\r\n        var west = rectangle.west;\r\n\r\n        var lla = subsampleLlaScratch;\r\n        lla.height = surfaceHeight;\r\n\r\n        lla.longitude = west;\r\n        lla.latitude = north;\r\n        result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\r\n        length++;\r\n\r\n        lla.longitude = east;\r\n        result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\r\n        length++;\r\n\r\n        lla.latitude = south;\r\n        result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\r\n        length++;\r\n\r\n        lla.longitude = west;\r\n        result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\r\n        length++;\r\n\r\n        if (north < 0.0) {\r\n            lla.latitude = north;\r\n        } else if (south > 0.0) {\r\n            lla.latitude = south;\r\n        } else {\r\n            lla.latitude = 0.0;\r\n        }\r\n\r\n        for ( var i = 1; i < 8; ++i) {\r\n            lla.longitude = -Math.PI + i * CesiumMath.PI_OVER_TWO;\r\n            if (Rectangle.contains(rectangle, lla)) {\r\n                result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\r\n                length++;\r\n            }\r\n        }\r\n\r\n        if (lla.latitude === 0.0) {\r\n            lla.longitude = west;\r\n            result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\r\n            length++;\r\n            lla.longitude = east;\r\n            result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\r\n            length++;\r\n        }\r\n        result.length = length;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * The largest possible rectangle.\r\n     *\r\n     * @type {Rectangle}\r\n     * @constant\r\n    */\r\n    Rectangle.MAX_VALUE = Object.freeze(new Rectangle(-Math.PI, -CesiumMath.PI_OVER_TWO, Math.PI, CesiumMath.PI_OVER_TWO));\r\nexport default Rectangle;\r\n"],"names":["Cartesian3","defined","DeveloperError","CesiumMath","defaultValue","Check","cartesianToCartographicN","cartesianToCartographicP","cartesianToCartographicH"],"mappings":";;;IAKI,IAAI,kCAAkC,GAAG,IAAIA,qBAAU,EAAE,CAAC;IAC9D,IAAI,IAAI,8BAA8B,GAAG,IAAIA,qBAAU,EAAE,CAAC;AAC1D;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,SAAS,sBAAsB,CAAC,SAAS,EAAE,YAAY,EAAE,mBAAmB,EAAE,sBAAsB,EAAE,MAAM,EAAE;IAClH;IACA,QAAQ,IAAI,CAACC,YAAO,CAAC,SAAS,CAAC,EAAE;IACjC,YAAY,MAAM,IAAIC,oBAAc,CAAC,wBAAwB,CAAC,CAAC;IAC/D,SAAS;IACT,QAAQ,IAAI,CAACD,YAAO,CAAC,YAAY,CAAC,EAAE;IACpC,YAAY,MAAM,IAAIC,oBAAc,CAAC,2BAA2B,CAAC,CAAC;IAClE,SAAS;IACT,QAAQ,IAAI,CAACD,YAAO,CAAC,mBAAmB,CAAC,EAAE;IAC3C,YAAY,MAAM,IAAIC,oBAAc,CAAC,kCAAkC,CAAC,CAAC;IACzE,SAAS;IACT,QAAQ,IAAI,CAACD,YAAO,CAAC,sBAAsB,CAAC,EAAE;IAC9C,YAAY,MAAM,IAAIC,oBAAc,CAAC,qCAAqC,CAAC,CAAC;IAC5E,SAAS;IACT;AACA;IACA,QAAQ,IAAI,SAAS,GAAG,SAAS,CAAC,CAAC,CAAC;IACpC,QAAQ,IAAI,SAAS,GAAG,SAAS,CAAC,CAAC,CAAC;IACpC,QAAQ,IAAI,SAAS,GAAG,SAAS,CAAC,CAAC,CAAC;AACpC;IACA,QAAQ,IAAI,aAAa,GAAG,YAAY,CAAC,CAAC,CAAC;IAC3C,QAAQ,IAAI,aAAa,GAAG,YAAY,CAAC,CAAC,CAAC;IAC3C,QAAQ,IAAI,aAAa,GAAG,YAAY,CAAC,CAAC,CAAC;AAC3C;IACA,QAAQ,IAAI,EAAE,GAAG,SAAS,GAAG,SAAS,GAAG,aAAa,GAAG,aAAa,CAAC;IACvE,QAAQ,IAAI,EAAE,GAAG,SAAS,GAAG,SAAS,GAAG,aAAa,GAAG,aAAa,CAAC;IACvE,QAAQ,IAAI,EAAE,GAAG,SAAS,GAAG,SAAS,GAAG,aAAa,GAAG,aAAa,CAAC;AACvE;IACA;IACA,QAAQ,IAAI,WAAW,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC;IACvC,QAAQ,IAAI,KAAK,GAAG,IAAI,CAAC,IAAI,CAAC,GAAG,GAAG,WAAW,CAAC,CAAC;AACjD;IACA;IACA,QAAQ,IAAI,YAAY,GAAGF,qBAAU,CAAC,gBAAgB,CAAC,SAAS,EAAE,KAAK,EAAE,kCAAkC,CAAC,CAAC;AAC7G;IACA;IACA,QAAQ,IAAI,WAAW,GAAG,sBAAsB,EAAE;IAClD,YAAY,OAAO,CAAC,QAAQ,CAAC,KAAK,CAAC,GAAG,SAAS,GAAGA,qBAAU,CAAC,KAAK,CAAC,YAAY,EAAE,MAAM,CAAC,CAAC;IACzF,SAAS;AACT;IACA,QAAQ,IAAI,oBAAoB,GAAG,mBAAmB,CAAC,CAAC,CAAC;IACzD,QAAQ,IAAI,oBAAoB,GAAG,mBAAmB,CAAC,CAAC,CAAC;IACzD,QAAQ,IAAI,oBAAoB,GAAG,mBAAmB,CAAC,CAAC,CAAC;AACzD;IACA;IACA;IACA,QAAQ,IAAI,QAAQ,GAAG,8BAA8B,CAAC;IACtD,QAAQ,QAAQ,CAAC,CAAC,GAAG,YAAY,CAAC,CAAC,GAAG,oBAAoB,GAAG,GAAG,CAAC;IACjE,QAAQ,QAAQ,CAAC,CAAC,GAAG,YAAY,CAAC,CAAC,GAAG,oBAAoB,GAAG,GAAG,CAAC;IACjE,QAAQ,QAAQ,CAAC,CAAC,GAAG,YAAY,CAAC,CAAC,GAAG,oBAAoB,GAAG,GAAG,CAAC;AACjE;IACA;IACA,QAAQ,IAAI,MAAM,GAAG,CAAC,GAAG,GAAG,KAAK,IAAIA,qBAAU,CAAC,SAAS,CAAC,SAAS,CAAC,IAAI,GAAG,GAAGA,qBAAU,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC,CAAC;IAC9G,QAAQ,IAAI,UAAU,GAAG,GAAG,CAAC;AAC7B;IACA,QAAQ,IAAI,IAAI,CAAC;IACjB,QAAQ,IAAI,WAAW,CAAC;IACxB,QAAQ,IAAI,WAAW,CAAC;IACxB,QAAQ,IAAI,WAAW,CAAC;IACxB,QAAQ,IAAI,WAAW,CAAC;IACxB,QAAQ,IAAI,YAAY,CAAC;IACzB,QAAQ,IAAI,YAAY,CAAC;IACzB,QAAQ,IAAI,YAAY,CAAC;IACzB,QAAQ,IAAI,YAAY,CAAC;IACzB,QAAQ,IAAI,YAAY,CAAC;IACzB,QAAQ,IAAI,YAAY,CAAC;AACzB;IACA,QAAQ,GAAG;IACX,YAAY,MAAM,IAAI,UAAU,CAAC;AACjC;IACA,YAAY,WAAW,GAAG,GAAG,IAAI,GAAG,GAAG,MAAM,GAAG,oBAAoB,CAAC,CAAC;IACtE,YAAY,WAAW,GAAG,GAAG,IAAI,GAAG,GAAG,MAAM,GAAG,oBAAoB,CAAC,CAAC;IACtE,YAAY,WAAW,GAAG,GAAG,IAAI,GAAG,GAAG,MAAM,GAAG,oBAAoB,CAAC,CAAC;AACtE;IACA,YAAY,YAAY,GAAG,WAAW,GAAG,WAAW,CAAC;IACrD,YAAY,YAAY,GAAG,WAAW,GAAG,WAAW,CAAC;IACrD,YAAY,YAAY,GAAG,WAAW,GAAG,WAAW,CAAC;AACrD;IACA,YAAY,YAAY,GAAG,YAAY,GAAG,WAAW,CAAC;IACtD,YAAY,YAAY,GAAG,YAAY,GAAG,WAAW,CAAC;IACtD,YAAY,YAAY,GAAG,YAAY,GAAG,WAAW,CAAC;AACtD;IACA,YAAY,IAAI,GAAG,EAAE,GAAG,YAAY,GAAG,EAAE,GAAG,YAAY,GAAG,EAAE,GAAG,YAAY,GAAG,GAAG,CAAC;AACnF;IACA;IACA;IACA,YAAY,WAAW,GAAG,EAAE,GAAG,YAAY,GAAG,oBAAoB,GAAG,EAAE,GAAG,YAAY,GAAG,oBAAoB,GAAG,EAAE,GAAG,YAAY,GAAG,oBAAoB,CAAC;AACzJ;IACA,YAAY,IAAI,UAAU,GAAG,CAAC,GAAG,GAAG,WAAW,CAAC;AAChD;IACA,YAAY,UAAU,GAAG,IAAI,GAAG,UAAU,CAAC;IAC3C,SAAS,QAAQ,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,GAAGG,qBAAU,CAAC,SAAS,EAAE;AACxD;IACA,QAAQ,IAAI,CAACF,YAAO,CAAC,MAAM,CAAC,EAAE;IAC9B,YAAY,OAAO,IAAID,qBAAU,CAAC,SAAS,GAAG,WAAW,EAAE,SAAS,GAAG,WAAW,EAAE,SAAS,GAAG,WAAW,CAAC,CAAC;IAC7G,SAAS;IACT,QAAQ,MAAM,CAAC,CAAC,GAAG,SAAS,GAAG,WAAW,CAAC;IAC3C,QAAQ,MAAM,CAAC,CAAC,GAAG,SAAS,GAAG,WAAW,CAAC;IAC3C,QAAQ,MAAM,CAAC,CAAC,GAAG,SAAS,GAAG,WAAW,CAAC;IAC3C,QAAQ,OAAO,MAAM,CAAC;IACtB;;ICrHI;IACJ;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,SAAS,YAAY,CAAC,SAAS,EAAE,QAAQ,EAAE,MAAM,EAAE;IACvD;IACA;IACA;IACA;IACA;IACA,QAAQ,IAAI,CAAC,SAAS,GAAGI,iBAAY,CAAC,SAAS,EAAE,GAAG,CAAC,CAAC;AACtD;IACA;IACA;IACA;IACA;IACA;IACA,QAAQ,IAAI,CAAC,QAAQ,GAAGA,iBAAY,CAAC,QAAQ,EAAE,GAAG,CAAC,CAAC;AACpD;IACA;IACA;IACA;IACA;IACA;IACA,QAAQ,IAAI,CAAC,MAAM,GAAGA,iBAAY,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC;IAChD,KAAK;AACL;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,YAAY,CAAC,WAAW,GAAG,SAAS,SAAS,EAAE,QAAQ,EAAE,MAAM,EAAE,MAAM,EAAE;IAC7E,QAAQ,MAAM,GAAGA,iBAAY,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC;AAC3C;IACA,QAAQ,IAAI,CAACH,YAAO,CAAC,MAAM,CAAC,EAAE;IAC9B,YAAY,OAAO,IAAI,YAAY,CAAC,SAAS,EAAE,QAAQ,EAAE,MAAM,CAAC,CAAC;IACjE,SAAS;AACT;IACA,QAAQ,MAAM,CAAC,SAAS,GAAG,SAAS,CAAC;IACrC,QAAQ,MAAM,CAAC,QAAQ,GAAG,QAAQ,CAAC;IACnC,QAAQ,MAAM,CAAC,MAAM,GAAG,MAAM,CAAC;IAC/B,QAAQ,OAAO,MAAM,CAAC;IACtB,KAAK,CAAC;AACN;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,YAAY,CAAC,WAAW,GAAG,SAAS,SAAS,EAAE,QAAQ,EAAE,MAAM,EAAE,MAAM,EAAE;IAC7E,QAAQ,SAAS,GAAGE,qBAAU,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC;IACpD,QAAQ,QAAQ,GAAGA,qBAAU,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC;AAClD;IACA,QAAQ,OAAO,YAAY,CAAC,WAAW,CAAC,SAAS,EAAE,QAAQ,EAAE,MAAM,EAAE,MAAM,CAAC,CAAC;IAC7E,KAAK,CAAC;AACN;IACA,IAAI,IAAI,wBAAwB,GAAG,IAAIH,qBAAU,EAAE,CAAC;IACpD,IAAI,IAAI,wBAAwB,GAAG,IAAIA,qBAAU,EAAE,CAAC;IACpD,IAAI,IAAI,wBAAwB,GAAG,IAAIA,qBAAU,EAAE,CAAC;IACpD,IAAI,IAAI,iBAAiB,GAAG,IAAIA,qBAAU,CAAC,GAAG,GAAG,SAAS,EAAE,GAAG,GAAG,SAAS,EAAE,GAAG,GAAG,kBAAkB,CAAC,CAAC;IACvG,IAAI,IAAI,wBAAwB,GAAG,IAAIA,qBAAU,CAAC,GAAG,IAAI,SAAS,GAAG,SAAS,CAAC,EAAE,GAAG,IAAI,SAAS,GAAG,SAAS,CAAC,EAAE,GAAG,IAAI,kBAAkB,GAAG,kBAAkB,CAAC,CAAC,CAAC;IACjK,IAAI,IAAI,2BAA2B,GAAGG,qBAAU,CAAC,QAAQ,CAAC;AAC1D;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,YAAY,CAAC,aAAa,GAAG,SAAS,SAAS,EAAE,SAAS,EAAE,MAAM,EAAE;IACxE,QAAQ,IAAI,YAAY,GAAGF,YAAO,CAAC,SAAS,CAAC,GAAG,SAAS,CAAC,YAAY,GAAG,iBAAiB,CAAC;IAC3F,QAAQ,IAAI,mBAAmB,GAAGA,YAAO,CAAC,SAAS,CAAC,GAAG,SAAS,CAAC,mBAAmB,GAAG,wBAAwB,CAAC;IAChH,QAAQ,IAAI,sBAAsB,GAAGA,YAAO,CAAC,SAAS,CAAC,GAAG,SAAS,CAAC,uBAAuB,GAAG,2BAA2B,CAAC;AAC1H;IACA;IACA,QAAQ,IAAI,CAAC,GAAG,sBAAsB,CAAC,SAAS,EAAE,YAAY,EAAE,mBAAmB,EAAE,sBAAsB,EAAE,wBAAwB,CAAC,CAAC;AACvI;IACA,QAAQ,IAAI,CAACA,YAAO,CAAC,CAAC,CAAC,EAAE;IACzB,YAAY,OAAO,SAAS,CAAC;IAC7B,SAAS;AACT;IACA,QAAQ,IAAI,CAAC,GAAGD,qBAAU,CAAC,kBAAkB,CAAC,CAAC,EAAE,mBAAmB,EAAE,wBAAwB,CAAC,CAAC;IAChG,QAAQ,CAAC,GAAGA,qBAAU,CAAC,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AACvC;IACA,QAAQ,IAAI,CAAC,GAAGA,qBAAU,CAAC,QAAQ,CAAC,SAAS,EAAE,CAAC,EAAE,wBAAwB,CAAC,CAAC;AAC5E;IACA,QAAQ,IAAI,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;IAC7C,QAAQ,IAAI,QAAQ,GAAG,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IACtC,QAAQ,IAAI,MAAM,GAAGG,qBAAU,CAAC,IAAI,CAACH,qBAAU,CAAC,GAAG,CAAC,CAAC,EAAE,SAAS,CAAC,CAAC,GAAGA,qBAAU,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;AAC7F;IACA,QAAQ,IAAI,CAACC,YAAO,CAAC,MAAM,CAAC,EAAE;IAC9B,YAAY,OAAO,IAAI,YAAY,CAAC,SAAS,EAAE,QAAQ,EAAE,MAAM,CAAC,CAAC;IACjE,SAAS;IACT,QAAQ,MAAM,CAAC,SAAS,GAAG,SAAS,CAAC;IACrC,QAAQ,MAAM,CAAC,QAAQ,GAAG,QAAQ,CAAC;IACnC,QAAQ,MAAM,CAAC,MAAM,GAAG,MAAM,CAAC;IAC/B,QAAQ,OAAO,MAAM,CAAC;IACtB,KAAK,CAAC;AACN;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,YAAY,CAAC,WAAW,GAAG,SAAS,YAAY,EAAE,SAAS,EAAE,MAAM,EAAE;IACzE,QAAQ,OAAOD,qBAAU,CAAC,WAAW,CAAC,YAAY,CAAC,SAAS,EAAE,YAAY,CAAC,QAAQ,EAAE,YAAY,CAAC,MAAM,EAAE,SAAS,EAAE,MAAM,CAAC,CAAC;IAC7H,KAAK,CAAC;AACN;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,YAAY,CAAC,KAAK,GAAG,SAAS,YAAY,EAAE,MAAM,EAAE;IACxD,QAAQ,IAAI,CAACC,YAAO,CAAC,YAAY,CAAC,EAAE;IACpC,YAAY,OAAO,SAAS,CAAC;IAC7B,SAAS;IACT,QAAQ,IAAI,CAACA,YAAO,CAAC,MAAM,CAAC,EAAE;IAC9B,YAAY,OAAO,IAAI,YAAY,CAAC,YAAY,CAAC,SAAS,EAAE,YAAY,CAAC,QAAQ,EAAE,YAAY,CAAC,MAAM,CAAC,CAAC;IACxG,SAAS;IACT,QAAQ,MAAM,CAAC,SAAS,GAAG,YAAY,CAAC,SAAS,CAAC;IAClD,QAAQ,MAAM,CAAC,QAAQ,GAAG,YAAY,CAAC,QAAQ,CAAC;IAChD,QAAQ,MAAM,CAAC,MAAM,GAAG,YAAY,CAAC,MAAM,CAAC;IAC5C,QAAQ,OAAO,MAAM,CAAC;IACtB,KAAK,CAAC;AACN;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,YAAY,CAAC,MAAM,GAAG,SAAS,IAAI,EAAE,KAAK,EAAE;IAChD,QAAQ,OAAO,CAAC,IAAI,KAAK,KAAK;IAC9B,iBAAiB,CAACA,YAAO,CAAC,IAAI,CAAC;IAC/B,kBAAkBA,YAAO,CAAC,KAAK,CAAC,CAAC;IACjC,kBAAkB,IAAI,CAAC,SAAS,KAAK,KAAK,CAAC,SAAS,CAAC;IACrD,kBAAkB,IAAI,CAAC,QAAQ,KAAK,KAAK,CAAC,QAAQ,CAAC;IACnD,kBAAkB,IAAI,CAAC,MAAM,KAAK,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC;IACjD,KAAK,CAAC;AACN;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,YAAY,CAAC,aAAa,GAAG,SAAS,IAAI,EAAE,KAAK,EAAE,OAAO,EAAE;IAChE,QAAQ,OAAO,GAAGG,iBAAY,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC;AAC3C;IACA,QAAQ,OAAO,CAAC,IAAI,KAAK,KAAK;IAC9B,gBAAgB,CAACH,YAAO,CAAC,IAAI,CAAC;IAC9B,iBAAiBA,YAAO,CAAC,KAAK,CAAC,CAAC;IAChC,iBAAiB,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,SAAS,GAAG,KAAK,CAAC,SAAS,CAAC,IAAI,OAAO,CAAC;IACvE,iBAAiB,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC,QAAQ,CAAC,IAAI,OAAO,CAAC;IACrE,iBAAiB,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC,MAAM,CAAC,IAAI,OAAO,CAAC,CAAC,CAAC;IACnE,KAAK,CAAC;AACN;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,YAAY,CAAC,IAAI,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,YAAY,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC,CAAC;AACvE;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,YAAY,CAAC,SAAS,CAAC,KAAK,GAAG,SAAS,MAAM,EAAE;IACpD,QAAQ,OAAO,YAAY,CAAC,KAAK,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;IAChD,KAAK,CAAC;AACN;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,YAAY,CAAC,SAAS,CAAC,MAAM,GAAG,SAAS,KAAK,EAAE;IACpD,QAAQ,OAAO,YAAY,CAAC,MAAM,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;IAChD,KAAK,CAAC;AACN;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,YAAY,CAAC,SAAS,CAAC,aAAa,GAAG,SAAS,KAAK,EAAE,OAAO,EAAE;IACpE,QAAQ,OAAO,YAAY,CAAC,aAAa,CAAC,IAAI,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;IAChE,KAAK,CAAC;AACN;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,YAAY,CAAC,SAAS,CAAC,QAAQ,GAAG,WAAW;IACjD,QAAQ,OAAO,GAAG,GAAG,IAAI,CAAC,SAAS,GAAG,IAAI,GAAG,IAAI,CAAC,QAAQ,GAAG,IAAI,GAAG,IAAI,CAAC,MAAM,GAAG,GAAG,CAAC;IACtF,KAAK,CAAC;;IC/OF,SAAS,UAAU,CAAC,SAAS,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE;IAC5C,QAAQ,CAAC,GAAGG,iBAAY,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC;IACjC,QAAQ,CAAC,GAAGA,iBAAY,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC;IACjC,QAAQ,CAAC,GAAGA,iBAAY,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC;AACjC;IACA;IACA,QAAQC,WAAK,CAAC,MAAM,CAAC,MAAM,CAAC,mBAAmB,CAAC,GAAG,EAAE,CAAC,EAAE,GAAG,CAAC,CAAC;IAC7D,QAAQA,WAAK,CAAC,MAAM,CAAC,MAAM,CAAC,mBAAmB,CAAC,GAAG,EAAE,CAAC,EAAE,GAAG,CAAC,CAAC;IAC7D,QAAQA,WAAK,CAAC,MAAM,CAAC,MAAM,CAAC,mBAAmB,CAAC,GAAG,EAAE,CAAC,EAAE,GAAG,CAAC,CAAC;IAC7D;AACA;IACA,QAAQ,SAAS,CAAC,MAAM,GAAG,IAAIL,qBAAU,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;AACnD;IACA,QAAQ,SAAS,CAAC,aAAa,GAAG,IAAIA,qBAAU,CAAC,CAAC,GAAG,CAAC;IACtD,4CAA4C,CAAC,GAAG,CAAC;IACjD,4CAA4C,CAAC,GAAG,CAAC,CAAC,CAAC;AACnD;IACA,QAAQ,SAAS,CAAC,iBAAiB,GAAG,IAAIA,qBAAU,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC;IAClE,gDAAgD,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC;IAC7D,gDAAgD,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;AAC/D;IACA,QAAQ,SAAS,CAAC,aAAa,GAAG,IAAIA,qBAAU,CAAC,CAAC,KAAK,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC;IAC1E,4CAA4C,CAAC,KAAK,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC;IACrE,4CAA4C,CAAC,KAAK,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC,CAAC,CAAC;AACvE;IACA,QAAQ,SAAS,CAAC,oBAAoB,GAAG,IAAIA,qBAAU,CAAC,CAAC,KAAK,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC;IACvF,mDAAmD,CAAC,KAAK,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC;IAClF,mDAAmD,CAAC,KAAK,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;AACpF;IACA,QAAQ,SAAS,CAAC,cAAc,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;AACrD;IACA,QAAQ,SAAS,CAAC,cAAc,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;AACrD;IACA,QAAQ,SAAS,CAAC,uBAAuB,GAAGG,qBAAU,CAAC,QAAQ,CAAC;AAChE;IACA,QAAQ,IAAI,SAAS,CAAC,aAAa,CAAC,CAAC,KAAK,CAAC,EAAE;IAC7C,YAAY,SAAS,CAAC,qBAAqB,GAAG,SAAS,CAAC,aAAa,CAAC,CAAC,GAAG,SAAS,CAAC,aAAa,CAAC,CAAC,CAAC;IACpG,SAAS;IACT,KAAK;AACL;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,SAAS,SAAS,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE;IAChC,QAAQ,IAAI,CAAC,MAAM,GAAG,SAAS,CAAC;IAChC,QAAQ,IAAI,CAAC,aAAa,GAAG,SAAS,CAAC;IACvC,QAAQ,IAAI,CAAC,iBAAiB,GAAG,SAAS,CAAC;IAC3C,QAAQ,IAAI,CAAC,aAAa,GAAG,SAAS,CAAC;IACvC,QAAQ,IAAI,CAAC,oBAAoB,GAAG,SAAS,CAAC;IAC9C,QAAQ,IAAI,CAAC,cAAc,GAAG,SAAS,CAAC;IACxC,QAAQ,IAAI,CAAC,cAAc,GAAG,SAAS,CAAC;IACxC,QAAQ,IAAI,CAAC,uBAAuB,GAAG,SAAS,CAAC;IACjD,QAAQ,IAAI,CAAC,qBAAqB,GAAG,SAAS,CAAC;AAC/C;IACA,QAAQ,UAAU,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;IAClC,KAAK;AACL;IACA,IAAI,MAAM,CAAC,gBAAgB,CAAC,SAAS,CAAC,SAAS,EAAE;IACjD;IACA;IACA;IACA;IACA;IACA;IACA,QAAQ,KAAK,GAAG;IAChB,YAAY,GAAG,EAAE,WAAW;IAC5B,gBAAgB,OAAO,IAAI,CAAC,MAAM,CAAC;IACnC,aAAa;IACb,SAAS;IACT;IACA;IACA;IACA;IACA;IACA;IACA,QAAQ,YAAY,GAAG;IACvB,YAAY,GAAG,GAAG,WAAW;IAC7B,gBAAgB,OAAO,IAAI,CAAC,aAAa,CAAC;IAC1C,aAAa;IACb,SAAS;IACT;IACA;IACA;IACA;IACA;IACA;IACA,QAAQ,gBAAgB,GAAG;IAC3B,YAAY,GAAG,GAAG,WAAW;IAC7B,gBAAgB,OAAO,IAAI,CAAC,iBAAiB,CAAC;IAC9C,aAAa;IACb,SAAS;IACT;IACA;IACA;IACA;IACA;IACA;IACA,QAAQ,YAAY,GAAG;IACvB,YAAY,GAAG,GAAG,WAAW;IAC7B,gBAAgB,OAAO,IAAI,CAAC,aAAa,CAAC;IAC1C,aAAa;IACb,SAAS;IACT;IACA;IACA;IACA;IACA;IACA;IACA,QAAQ,mBAAmB,GAAG;IAC9B,YAAY,GAAG,GAAG,WAAW;IAC7B,gBAAgB,OAAO,IAAI,CAAC,oBAAoB,CAAC;IACjD,aAAa;IACb,SAAS;IACT;IACA;IACA;IACA;IACA;IACA;IACA,QAAQ,aAAa,GAAG;IACxB,YAAY,GAAG,GAAG,WAAW;IAC7B,gBAAgB,OAAO,IAAI,CAAC,cAAc,CAAC;IAC3C,aAAa;IACb,SAAS;IACT;IACA;IACA;IACA;IACA;IACA;IACA,QAAQ,aAAa,GAAG;IACxB,YAAY,GAAG,GAAG,WAAW;IAC7B,gBAAgB,OAAO,IAAI,CAAC,cAAc,CAAC;IAC3C,aAAa;IACb,SAAS;IACT,KAAK,CAAC,CAAC;AACP;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,SAAS,CAAC,KAAK,GAAG,SAAS,SAAS,EAAE,MAAM,EAAE;IAClD,QAAQ,IAAI,CAACF,YAAO,CAAC,SAAS,CAAC,EAAE;IACjC,YAAY,OAAO,SAAS,CAAC;IAC7B,SAAS;IACT,QAAQ,IAAI,KAAK,GAAG,SAAS,CAAC,MAAM,CAAC;AACrC;IACA,QAAQ,IAAI,CAACA,YAAO,CAAC,MAAM,CAAC,EAAE;IAC9B,YAAY,OAAO,IAAI,SAAS,CAAC,KAAK,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC;IAC5D,SAAS;AACT;IACA,QAAQD,qBAAU,CAAC,KAAK,CAAC,KAAK,EAAE,MAAM,CAAC,MAAM,CAAC,CAAC;IAC/C,QAAQA,qBAAU,CAAC,KAAK,CAAC,SAAS,CAAC,aAAa,EAAE,MAAM,CAAC,aAAa,CAAC,CAAC;IACxE,QAAQA,qBAAU,CAAC,KAAK,CAAC,SAAS,CAAC,iBAAiB,EAAE,MAAM,CAAC,iBAAiB,CAAC,CAAC;IAChF,QAAQA,qBAAU,CAAC,KAAK,CAAC,SAAS,CAAC,aAAa,EAAE,MAAM,CAAC,aAAa,CAAC,CAAC;IACxE,QAAQA,qBAAU,CAAC,KAAK,CAAC,SAAS,CAAC,oBAAoB,EAAE,MAAM,CAAC,oBAAoB,CAAC,CAAC;IACtF,QAAQ,MAAM,CAAC,cAAc,GAAG,SAAS,CAAC,cAAc,CAAC;IACzD,QAAQ,MAAM,CAAC,cAAc,GAAG,SAAS,CAAC,cAAc,CAAC;IACzD,QAAQ,MAAM,CAAC,uBAAuB,GAAG,SAAS,CAAC,uBAAuB,CAAC;AAC3E;IACA,QAAQ,OAAO,MAAM,CAAC;IACtB,KAAK,CAAC;AACN;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,SAAS,CAAC,cAAc,GAAG,SAAS,SAAS,EAAE,MAAM,EAAE;IAC3D,QAAQ,IAAI,CAACC,YAAO,CAAC,MAAM,CAAC,EAAE;IAC9B,YAAY,MAAM,GAAG,IAAI,SAAS,EAAE,CAAC;IACrC,SAAS;AACT;IACA,QAAQ,IAAI,CAACA,YAAO,CAAC,SAAS,CAAC,EAAE;IACjC,YAAY,OAAO,MAAM,CAAC;IAC1B,SAAS;AACT;IACA,QAAQ,UAAU,CAAC,MAAM,EAAE,SAAS,CAAC,CAAC,EAAE,SAAS,CAAC,CAAC,EAAE,SAAS,CAAC,CAAC,CAAC,CAAC;IAClE,QAAQ,OAAO,MAAM,CAAC;IACtB,KAAK,CAAC;AACN;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,SAAS,CAAC,KAAK,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,SAAS,CAAC,SAAS,EAAE,SAAS,EAAE,kBAAkB,CAAC,CAAC,CAAC;AAC7F;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,SAAS,CAAC,WAAW,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,SAAS,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC,CAAC;AACxE;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,SAAS,CAAC,IAAI,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,SAAS,CAACE,qBAAU,CAAC,YAAY,EAAEA,qBAAU,CAAC,YAAY,EAAEA,qBAAU,CAAC,YAAY,CAAC,CAAC,CAAC;AAC7H;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,SAAS,CAAC,SAAS,CAAC,KAAK,GAAG,SAAS,MAAM,EAAE;IACjD,QAAQ,OAAO,SAAS,CAAC,KAAK,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;IAC7C,KAAK,CAAC;AACN;IACA;IACA;IACA;IACA;IACA,IAAI,SAAS,CAAC,YAAY,GAAGH,qBAAU,CAAC,YAAY,CAAC;AACrD;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,SAAS,CAAC,IAAI,GAAG,SAAS,KAAK,EAAE,KAAK,EAAE,aAAa,EAAE;IAC3D;IACA,QAAQK,WAAK,CAAC,MAAM,CAAC,MAAM,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;IAC5C,QAAQA,WAAK,CAAC,OAAO,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;IACtC;AACA;IACA,QAAQ,aAAa,GAAGD,iBAAY,CAAC,aAAa,EAAE,CAAC,CAAC,CAAC;AACvD;IACA,QAAQJ,qBAAU,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE,KAAK,EAAE,aAAa,CAAC,CAAC;AAC5D;IACA,QAAQ,OAAO,KAAK,CAAC;IACrB,KAAK,CAAC;AACN;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,SAAS,CAAC,MAAM,GAAG,SAAS,KAAK,EAAE,aAAa,EAAE,MAAM,EAAE;IAC9D;IACA,QAAQK,WAAK,CAAC,OAAO,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;IACtC;AACA;IACA,QAAQ,aAAa,GAAGD,iBAAY,CAAC,aAAa,EAAE,CAAC,CAAC,CAAC;AACvD;IACA,QAAQ,IAAI,KAAK,GAAGJ,qBAAU,CAAC,MAAM,CAAC,KAAK,EAAE,aAAa,CAAC,CAAC;IAC5D,QAAQ,OAAO,SAAS,CAAC,cAAc,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;IACvD,KAAK,CAAC;AACN;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,SAAS,CAAC,SAAS,CAAC,uBAAuB,GAAGA,qBAAU,CAAC,SAAS,CAAC;AACvE;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,SAAS,CAAC,SAAS,CAAC,iCAAiC,GAAG,SAAS,YAAY,EAAE,MAAM,EAAE;IAC3F;IACA,QAAQK,WAAK,CAAC,MAAM,CAAC,MAAM,CAAC,cAAc,EAAE,YAAY,CAAC,CAAC;IAC1D;AACA;IACA,QAAQ,IAAI,SAAS,GAAG,YAAY,CAAC,SAAS,CAAC;IAC/C,QAAQ,IAAI,QAAQ,GAAG,YAAY,CAAC,QAAQ,CAAC;IAC7C,QAAQ,IAAI,WAAW,GAAG,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;AAC7C;IACA,QAAQ,IAAI,CAAC,GAAG,WAAW,GAAG,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;IAClD,QAAQ,IAAI,CAAC,GAAG,WAAW,GAAG,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;IAClD,QAAQ,IAAI,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;AACnC;IACA,QAAQ,IAAI,CAACJ,YAAO,CAAC,MAAM,CAAC,EAAE;IAC9B,YAAY,MAAM,GAAG,IAAID,qBAAU,EAAE,CAAC;IACtC,SAAS;IACT,QAAQ,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC;IACrB,QAAQ,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC;IACrB,QAAQ,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC;IACrB,QAAQ,OAAOA,qBAAU,CAAC,SAAS,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;IACpD,KAAK,CAAC;AACN;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,SAAS,CAAC,SAAS,CAAC,qBAAqB,GAAG,SAAS,SAAS,EAAE,MAAM,EAAE;IAC5E,QAAQ,IAAI,CAACC,YAAO,CAAC,MAAM,CAAC,EAAE;IAC9B,YAAY,MAAM,GAAG,IAAID,qBAAU,EAAE,CAAC;IACtC,SAAS;IACT,QAAQ,MAAM,GAAGA,qBAAU,CAAC,kBAAkB,CAAC,SAAS,EAAE,IAAI,CAAC,oBAAoB,EAAE,MAAM,CAAC,CAAC;IAC7F,QAAQ,OAAOA,qBAAU,CAAC,SAAS,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;IACpD,KAAK,CAAC;AACN;IACA,IAAI,IAAI,6BAA6B,GAAG,IAAIA,qBAAU,EAAE,CAAC;IACzD,IAAI,IAAI,wBAAwB,GAAG,IAAIA,qBAAU,EAAE,CAAC;AACpD;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,SAAS,CAAC,SAAS,CAAC,uBAAuB,GAAG,SAAS,YAAY,EAAE,MAAM,EAAE;IACjF;IACA,QAAQ,IAAI,CAAC,GAAG,6BAA6B,CAAC;IAC9C,QAAQ,IAAI,CAAC,GAAG,wBAAwB,CAAC;IACzC,QAAQ,IAAI,CAAC,iCAAiC,CAAC,YAAY,EAAE,CAAC,CAAC,CAAC;IAChE,QAAQA,qBAAU,CAAC,kBAAkB,CAAC,IAAI,CAAC,aAAa,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;IAChE,QAAQ,IAAI,KAAK,GAAG,IAAI,CAAC,IAAI,CAACA,qBAAU,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;IACpD,QAAQA,qBAAU,CAAC,cAAc,CAAC,CAAC,EAAE,KAAK,EAAE,CAAC,CAAC,CAAC;IAC/C,QAAQA,qBAAU,CAAC,gBAAgB,CAAC,CAAC,EAAE,YAAY,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC;AAC/D;IACA,QAAQ,IAAI,CAACC,YAAO,CAAC,MAAM,CAAC,EAAE;IAC9B,YAAY,MAAM,GAAG,IAAID,qBAAU,EAAE,CAAC;IACtC,SAAS;IACT,QAAQ,OAAOA,qBAAU,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,MAAM,CAAC,CAAC;IAC5C,KAAK,CAAC;AACN;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,SAAS,CAAC,SAAS,CAAC,iCAAiC,GAAG,SAAS,aAAa,EAAE,MAAM,EAAE;IAC5F;IACA,QAAQK,WAAK,CAAC,OAAO,CAAC,eAAe,EAAE,aAAa,CAAC,CAAC;IACtD;AACA;IACA,QAAQ,IAAI,MAAM,GAAG,aAAa,CAAC,MAAM,CAAC;IAC1C,QAAQ,IAAI,CAACJ,YAAO,CAAC,MAAM,CAAC,EAAE;IAC9B,YAAY,MAAM,GAAG,IAAI,KAAK,CAAC,MAAM,CAAC,CAAC;IACvC,SAAS,MAAM;IACf,YAAY,MAAM,CAAC,MAAM,GAAG,MAAM,CAAC;IACnC,SAAS;IACT,QAAQ,MAAM,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,EAAE,CAAC,EAAE,EAAE;IAC1C,YAAY,MAAM,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,uBAAuB,CAAC,aAAa,CAAC,CAAC,CAAC,EAAE,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;IAClF,SAAS;IACT,QAAQ,OAAO,MAAM,CAAC;IACtB,KAAK,CAAC;AACN;IACA,IAAI,IAAIK,0BAAwB,GAAG,IAAIN,qBAAU,EAAE,CAAC;IACpD,IAAI,IAAIO,0BAAwB,GAAG,IAAIP,qBAAU,EAAE,CAAC;IACpD,IAAI,IAAIQ,0BAAwB,GAAG,IAAIR,qBAAU,EAAE,CAAC;AACpD;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,SAAS,CAAC,SAAS,CAAC,uBAAuB,GAAG,SAAS,SAAS,EAAE,MAAM,EAAE;IAC9E;IACA,QAAQ,IAAI,CAAC,GAAG,IAAI,CAAC,sBAAsB,CAAC,SAAS,EAAEO,0BAAwB,CAAC,CAAC;AACjF;IACA,QAAQ,IAAI,CAACN,YAAO,CAAC,CAAC,CAAC,EAAE;IACzB,YAAY,OAAO,SAAS,CAAC;IAC7B,SAAS;AACT;IACA,QAAQ,IAAI,CAAC,GAAG,IAAI,CAAC,qBAAqB,CAAC,CAAC,EAAEK,0BAAwB,CAAC,CAAC;IACxE,QAAQ,IAAI,CAAC,GAAGN,qBAAU,CAAC,QAAQ,CAAC,SAAS,EAAE,CAAC,EAAEQ,0BAAwB,CAAC,CAAC;AAC5E;IACA,QAAQ,IAAI,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;IAC7C,QAAQ,IAAI,QAAQ,GAAG,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IACtC,QAAQ,IAAI,MAAM,GAAGL,qBAAU,CAAC,IAAI,CAACH,qBAAU,CAAC,GAAG,CAAC,CAAC,EAAE,SAAS,CAAC,CAAC,GAAGA,qBAAU,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;AAC7F;IACA,QAAQ,IAAI,CAACC,YAAO,CAAC,MAAM,CAAC,EAAE;IAC9B,YAAY,OAAO,IAAI,YAAY,CAAC,SAAS,EAAE,QAAQ,EAAE,MAAM,CAAC,CAAC;IACjE,SAAS;IACT,QAAQ,MAAM,CAAC,SAAS,GAAG,SAAS,CAAC;IACrC,QAAQ,MAAM,CAAC,QAAQ,GAAG,QAAQ,CAAC;IACnC,QAAQ,MAAM,CAAC,MAAM,GAAG,MAAM,CAAC;IAC/B,QAAQ,OAAO,MAAM,CAAC;IACtB,KAAK,CAAC;AACN;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,SAAS,CAAC,SAAS,CAAC,iCAAiC,GAAG,SAAS,UAAU,EAAE,MAAM,EAAE;IACzF;IACA,QAAQI,WAAK,CAAC,OAAO,CAAC,YAAY,EAAE,UAAU,CAAC,CAAC;IAChD;AACA;IACA,QAAQ,IAAI,MAAM,GAAG,UAAU,CAAC,MAAM,CAAC;IACvC,QAAQ,IAAI,CAACJ,YAAO,CAAC,MAAM,CAAC,EAAE;IAC9B,YAAY,MAAM,GAAG,IAAI,KAAK,CAAC,MAAM,CAAC,CAAC;IACvC,SAAS,MAAM;IACf,YAAY,MAAM,CAAC,MAAM,GAAG,MAAM,CAAC;IACnC,SAAS;IACT,QAAQ,MAAM,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,EAAE,EAAE,CAAC,EAAE;IAC1C,YAAY,MAAM,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,uBAAuB,CAAC,UAAU,CAAC,CAAC,CAAC,EAAE,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;IAC/E,SAAS;IACT,QAAQ,OAAO,MAAM,CAAC;IACtB,KAAK,CAAC;AACN;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,SAAS,CAAC,SAAS,CAAC,sBAAsB,GAAG,SAAS,SAAS,EAAE,MAAM,EAAE;IAC7E,QAAQ,OAAO,sBAAsB,CAAC,SAAS,EAAE,IAAI,CAAC,aAAa,EAAE,IAAI,CAAC,oBAAoB,EAAE,IAAI,CAAC,uBAAuB,EAAE,MAAM,CAAC,CAAC;IACtI,KAAK,CAAC;AACN;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,SAAS,CAAC,SAAS,CAAC,wBAAwB,GAAG,SAAS,SAAS,EAAE,MAAM,EAAE;IAC/E;IACA,QAAQI,WAAK,CAAC,MAAM,CAAC,MAAM,CAAC,WAAW,EAAE,SAAS,CAAC,CAAC;IACpD;AACA;IACA,QAAQ,IAAI,CAACJ,YAAO,CAAC,MAAM,CAAC,EAAE;IAC9B,YAAY,MAAM,GAAG,IAAID,qBAAU,EAAE,CAAC;IACtC,SAAS;AACT;IACA,QAAQ,IAAI,SAAS,GAAG,SAAS,CAAC,CAAC,CAAC;IACpC,QAAQ,IAAI,SAAS,GAAG,SAAS,CAAC,CAAC,CAAC;IACpC,QAAQ,IAAI,SAAS,GAAG,SAAS,CAAC,CAAC,CAAC;IACpC,QAAQ,IAAI,mBAAmB,GAAG,IAAI,CAAC,oBAAoB,CAAC;AAC5D;IACA,QAAQ,IAAI,IAAI,GAAG,GAAG,GAAG,IAAI,CAAC,IAAI,CAAC,CAAC,SAAS,GAAG,SAAS,IAAI,mBAAmB,CAAC,CAAC;IAClF,mCAAmC,CAAC,SAAS,GAAG,SAAS,IAAI,mBAAmB,CAAC,CAAC;IAClF,mCAAmC,CAAC,SAAS,GAAG,SAAS,IAAI,mBAAmB,CAAC,CAAC,CAAC,CAAC;AACpF;IACA,QAAQ,OAAOA,qBAAU,CAAC,gBAAgB,CAAC,SAAS,EAAE,IAAI,EAAE,MAAM,CAAC,CAAC;IACpE,KAAK,CAAC;AACN;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,SAAS,CAAC,SAAS,CAAC,8BAA8B,GAAG,SAAS,QAAQ,EAAE,MAAM,EAAE;IACpF,QAAQ,IAAI,CAACC,YAAO,CAAC,MAAM,CAAC,EAAE;IAC9B,YAAY,MAAM,GAAG,IAAID,qBAAU,EAAE,CAAC;IACtC,SAAS;AACT;IACA,QAAQ,OAAOA,qBAAU,CAAC,kBAAkB,CAAC,QAAQ,EAAE,IAAI,CAAC,aAAa,EAAE,MAAM,CAAC,CAAC;IACnF,KAAK,CAAC;AACN;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,SAAS,CAAC,SAAS,CAAC,gCAAgC,GAAG,SAAS,QAAQ,EAAE,MAAM,EAAE;IACtF,QAAQ,IAAI,CAACC,YAAO,CAAC,MAAM,CAAC,EAAE;IAC9B,YAAY,MAAM,GAAG,IAAID,qBAAU,EAAE,CAAC;IACtC,SAAS;AACT;IACA,QAAQ,OAAOA,qBAAU,CAAC,kBAAkB,CAAC,QAAQ,EAAE,IAAI,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;IAC5E,KAAK,CAAC;AACN;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,SAAS,CAAC,SAAS,CAAC,MAAM,GAAG,SAAS,KAAK,EAAE;IACjD,QAAQ,OAAO,CAAC,IAAI,KAAK,KAAK;IAC9B,gBAAgBC,YAAO,CAAC,KAAK,CAAC;IAC9B,gBAAgBD,qBAAU,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,EAAE,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC;IAC9D,KAAK,CAAC;AACN;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,SAAS,CAAC,SAAS,CAAC,QAAQ,GAAG,WAAW;IAC9C,QAAQ,OAAO,IAAI,CAAC,MAAM,CAAC,QAAQ,EAAE,CAAC;IACtC,KAAK,CAAC;AACN;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,SAAS,CAAC,SAAS,CAAC,qCAAqC,GAAG,SAAS,QAAQ,EAAE,MAAM,EAAE,MAAM,EAAE;IACnG;IACA,QAAQK,WAAK,CAAC,MAAM,CAAC,MAAM,CAAC,UAAU,EAAE,QAAQ,CAAC,CAAC;AAClD;IACA,QAAQ,IAAI,CAACF,qBAAU,CAAC,aAAa,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC,EAAEA,qBAAU,CAAC,SAAS,CAAC,EAAE;IAC3F,YAAY,MAAM,IAAID,oBAAc,CAAC,mEAAmE,CAAC,CAAC;IAC1G,SAAS;AACT;IACA,QAAQG,WAAK,CAAC,MAAM,CAAC,MAAM,CAAC,WAAW,CAAC,mBAAmB,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IAC/E;AACA;IACA,QAAQ,MAAM,GAAGD,iBAAY,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC;AAC3C;IACA,QAAQ,IAAI,oBAAoB,GAAG,IAAI,CAAC,qBAAqB,CAAC;AAC9D;IACA,QAAQ,IAAI,CAACH,YAAO,CAAC,MAAM,CAAC,EAAE;IAC9B,YAAY,MAAM,GAAG,IAAID,qBAAU,EAAE,CAAC;IACtC,SAAS;AACT;IACA,QAAQ,MAAM,CAAC,CAAC,GAAG,GAAG,CAAC;IACvB,QAAQ,MAAM,CAAC,CAAC,GAAG,GAAG,CAAC;IACvB,QAAQ,MAAM,CAAC,CAAC,GAAG,QAAQ,CAAC,CAAC,IAAI,CAAC,GAAG,oBAAoB,CAAC,CAAC;AAC3D;IACA,QAAQ,IAAI,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC,MAAM,CAAC,CAAC,GAAG,MAAM,EAAE;IAC1D,YAAY,OAAO,SAAS,CAAC;IAC7B,SAAS;AACT;IACA,QAAQ,OAAO,MAAM,CAAC;IACtB,KAAK,CAAC;;IClnBF;IACJ;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,SAAS,SAAS,CAAC,IAAI,EAAE,KAAK,EAAE,IAAI,EAAE,KAAK,EAAE;IACjD;IACA;IACA;IACA;IACA;IACA;IACA,QAAQ,IAAI,CAAC,IAAI,GAAGI,iBAAY,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC;AAC5C;IACA;IACA;IACA;IACA;IACA;IACA;IACA,QAAQ,IAAI,CAAC,KAAK,GAAGA,iBAAY,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;AAC9C;IACA;IACA;IACA;IACA;IACA;IACA;IACA,QAAQ,IAAI,CAAC,IAAI,GAAGA,iBAAY,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC;AAC5C;IACA;IACA;IACA;IACA;IACA;IACA;IACA,QAAQ,IAAI,CAAC,KAAK,GAAGA,iBAAY,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;IAC9C,KAAK;AACL;IACA,IAAI,MAAM,CAAC,gBAAgB,CAAC,SAAS,CAAC,SAAS,EAAE;IACjD;IACA;IACA;IACA;IACA;IACA,QAAQ,KAAK,GAAG;IAChB,YAAY,GAAG,GAAG,WAAW;IAC7B,gBAAgB,OAAO,SAAS,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC;IACpD,aAAa;IACb,SAAS;AACT;IACA;IACA;IACA;IACA;IACA;IACA,QAAQ,MAAM,GAAG;IACjB,YAAY,GAAG,GAAG,WAAW;IAC7B,gBAAgB,OAAO,SAAS,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;IACrD,aAAa;IACb,SAAS;IACT,KAAK,CAAC,CAAC;AACP;IACA;IACA;IACA;IACA;IACA,IAAI,SAAS,CAAC,YAAY,GAAG,CAAC,CAAC;AAC/B;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,SAAS,CAAC,IAAI,GAAG,SAAS,KAAK,EAAE,KAAK,EAAE,aAAa,EAAE;IAC3D,QAAQ,aAAa,GAAGA,iBAAY,CAAC,aAAa,EAAE,CAAC,CAAC,CAAC;AACvD;IACA,QAAQ,KAAK,CAAC,aAAa,EAAE,CAAC,GAAG,KAAK,CAAC,IAAI,CAAC;IAC5C,QAAQ,KAAK,CAAC,aAAa,EAAE,CAAC,GAAG,KAAK,CAAC,KAAK,CAAC;IAC7C,QAAQ,KAAK,CAAC,aAAa,EAAE,CAAC,GAAG,KAAK,CAAC,IAAI,CAAC;IAC5C,QAAQ,KAAK,CAAC,aAAa,CAAC,GAAG,KAAK,CAAC,KAAK,CAAC;AAC3C;IACA,QAAQ,OAAO,KAAK,CAAC;IACrB,KAAK,CAAC;AACN;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,SAAS,CAAC,MAAM,GAAG,SAAS,KAAK,EAAE,aAAa,EAAE,MAAM,EAAE;IAC9D,QAAQ,aAAa,GAAGA,iBAAY,CAAC,aAAa,EAAE,CAAC,CAAC,CAAC;AACvD;IACA,QAAQ,IAAI,CAACH,YAAO,CAAC,MAAM,CAAC,EAAE;IAC9B,YAAY,MAAM,GAAG,IAAI,SAAS,EAAE,CAAC;IACrC,SAAS;AACT;IACA,QAAQ,MAAM,CAAC,IAAI,GAAG,KAAK,CAAC,aAAa,EAAE,CAAC,CAAC;IAC7C,QAAQ,MAAM,CAAC,KAAK,GAAG,KAAK,CAAC,aAAa,EAAE,CAAC,CAAC;IAC9C,QAAQ,MAAM,CAAC,IAAI,GAAG,KAAK,CAAC,aAAa,EAAE,CAAC,CAAC;IAC7C,QAAQ,MAAM,CAAC,KAAK,GAAG,KAAK,CAAC,aAAa,CAAC,CAAC;IAC5C,QAAQ,OAAO,MAAM,CAAC;IACtB,KAAK,CAAC;AACN;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,SAAS,CAAC,YAAY,GAAG,SAAS,SAAS,EAAE;IACjD,QAAQ,IAAI,IAAI,GAAG,SAAS,CAAC,IAAI,CAAC;IAClC,QAAQ,IAAI,IAAI,GAAG,SAAS,CAAC,IAAI,CAAC;IAClC,QAAQ,IAAI,IAAI,GAAG,IAAI,EAAE;IACzB,YAAY,IAAI,IAAIE,qBAAU,CAAC,MAAM,CAAC;IACtC,SAAS;IACT,QAAQ,OAAO,IAAI,GAAG,IAAI,CAAC;IAC3B,KAAK,CAAC;AACN;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,SAAS,CAAC,aAAa,GAAG,SAAS,SAAS,EAAE;IAClD,QAAQ,OAAO,SAAS,CAAC,KAAK,GAAG,SAAS,CAAC,KAAK,CAAC;IACjD,KAAK,CAAC;AACN;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,SAAS,CAAC,WAAW,GAAG,SAAS,IAAI,EAAE,KAAK,EAAE,IAAI,EAAE,KAAK,EAAE,MAAM,EAAE;IACvE,QAAQ,IAAI,GAAGA,qBAAU,CAAC,SAAS,CAACC,iBAAY,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC,CAAC;IAC7D,QAAQ,KAAK,GAAGD,qBAAU,CAAC,SAAS,CAACC,iBAAY,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC,CAAC;IAC/D,QAAQ,IAAI,GAAGD,qBAAU,CAAC,SAAS,CAACC,iBAAY,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC,CAAC;IAC7D,QAAQ,KAAK,GAAGD,qBAAU,CAAC,SAAS,CAACC,iBAAY,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC,CAAC;AAC/D;IACA,QAAQ,IAAI,CAACH,YAAO,CAAC,MAAM,CAAC,EAAE;IAC9B,YAAY,OAAO,IAAI,SAAS,CAAC,IAAI,EAAE,KAAK,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;IAC3D,SAAS;AACT;IACA,QAAQ,MAAM,CAAC,IAAI,GAAG,IAAI,CAAC;IAC3B,QAAQ,MAAM,CAAC,KAAK,GAAG,KAAK,CAAC;IAC7B,QAAQ,MAAM,CAAC,IAAI,GAAG,IAAI,CAAC;IAC3B,QAAQ,MAAM,CAAC,KAAK,GAAG,KAAK,CAAC;AAC7B;IACA,QAAQ,OAAO,MAAM,CAAC;IACtB,KAAK,CAAC;AACN;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,SAAS,CAAC,WAAW,GAAG,SAAS,IAAI,EAAE,KAAK,EAAE,IAAI,EAAE,KAAK,EAAE,MAAM,EAAE;IACvE,QAAQ,IAAI,CAACA,YAAO,CAAC,MAAM,CAAC,EAAE;IAC9B,YAAY,OAAO,IAAI,SAAS,CAAC,IAAI,EAAE,KAAK,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;IAC3D,SAAS;AACT;IACA,QAAQ,MAAM,CAAC,IAAI,GAAGG,iBAAY,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC;IAC9C,QAAQ,MAAM,CAAC,KAAK,GAAGA,iBAAY,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;IAChD,QAAQ,MAAM,CAAC,IAAI,GAAGA,iBAAY,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC;IAC9C,QAAQ,MAAM,CAAC,KAAK,GAAGA,iBAAY,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;AAChD;IACA,QAAQ,OAAO,MAAM,CAAC;IACtB,KAAK,CAAC;AACN;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,SAAS,CAAC,qBAAqB,GAAG,SAAS,aAAa,EAAE,MAAM,EAAE;IACtE,QAAQ,IAAI,IAAI,GAAG,MAAM,CAAC,SAAS,CAAC;IACpC,QAAQ,IAAI,IAAI,GAAG,CAAC,MAAM,CAAC,SAAS,CAAC;IACrC,QAAQ,IAAI,WAAW,GAAG,MAAM,CAAC,SAAS,CAAC;IAC3C,QAAQ,IAAI,WAAW,GAAG,CAAC,MAAM,CAAC,SAAS,CAAC;IAC5C,QAAQ,IAAI,KAAK,GAAG,MAAM,CAAC,SAAS,CAAC;IACrC,QAAQ,IAAI,KAAK,GAAG,CAAC,MAAM,CAAC,SAAS,CAAC;AACtC;IACA,QAAQ,MAAM,IAAI,CAAC,GAAG,CAAC,EAAE,GAAG,GAAG,aAAa,CAAC,MAAM,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE;IACnE,YAAY,IAAI,QAAQ,GAAG,aAAa,CAAC,CAAC,CAAC,CAAC;IAC5C,YAAY,IAAI,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,QAAQ,CAAC,SAAS,CAAC,CAAC;IACtD,YAAY,IAAI,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,QAAQ,CAAC,SAAS,CAAC,CAAC;IACtD,YAAY,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,EAAE,QAAQ,CAAC,QAAQ,CAAC,CAAC;IACvD,YAAY,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,EAAE,QAAQ,CAAC,QAAQ,CAAC,CAAC;AACvD;IACA,YAAY,IAAI,WAAW,GAAG,QAAQ,CAAC,SAAS,IAAI,CAAC,IAAI,QAAQ,CAAC,SAAS,GAAG,QAAQ,CAAC,SAAS,IAAID,qBAAU,CAAC,MAAM,CAAC;IACtH,YAAY,WAAW,GAAG,IAAI,CAAC,GAAG,CAAC,WAAW,EAAE,WAAW,CAAC,CAAC;IAC7D,YAAY,WAAW,GAAG,IAAI,CAAC,GAAG,CAAC,WAAW,EAAE,WAAW,CAAC,CAAC;IAC7D,SAAS;AACT;IACA,QAAQ,GAAG,IAAI,GAAG,IAAI,GAAG,WAAW,GAAG,WAAW,EAAE;IACpD,YAAY,IAAI,GAAG,WAAW,CAAC;IAC/B,YAAY,IAAI,GAAG,WAAW,CAAC;AAC/B;IACA,YAAY,IAAI,IAAI,GAAGA,qBAAU,CAAC,EAAE,EAAE;IACtC,gBAAgB,IAAI,GAAG,IAAI,GAAGA,qBAAU,CAAC,MAAM,CAAC;IAChD,aAAa;IACb,YAAY,IAAI,IAAI,GAAGA,qBAAU,CAAC,EAAE,EAAE;IACtC,gBAAgB,IAAI,GAAG,IAAI,GAAGA,qBAAU,CAAC,MAAM,CAAC;IAChD,aAAa;IACb,SAAS;AACT;IACA,QAAQ,IAAI,CAACF,YAAO,CAAC,MAAM,CAAC,EAAE;IAC9B,YAAY,OAAO,IAAI,SAAS,CAAC,IAAI,EAAE,KAAK,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;IAC3D,SAAS;AACT;IACA,QAAQ,MAAM,CAAC,IAAI,GAAG,IAAI,CAAC;IAC3B,QAAQ,MAAM,CAAC,KAAK,GAAG,KAAK,CAAC;IAC7B,QAAQ,MAAM,CAAC,IAAI,GAAG,IAAI,CAAC;IAC3B,QAAQ,MAAM,CAAC,KAAK,GAAG,KAAK,CAAC;IAC7B,QAAQ,OAAO,MAAM,CAAC;IACtB,KAAK,CAAC;AACN;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,SAAS,CAAC,kBAAkB,GAAG,SAAS,UAAU,EAAE,SAAS,EAAE,MAAM,EAAE;IAC3E,QAAQ,SAAS,GAAGG,iBAAY,CAAC,SAAS,EAAE,SAAS,CAAC,KAAK,CAAC,CAAC;AAC7D;IACA,QAAQ,IAAI,IAAI,GAAG,MAAM,CAAC,SAAS,CAAC;IACpC,QAAQ,IAAI,IAAI,GAAG,CAAC,MAAM,CAAC,SAAS,CAAC;IACrC,QAAQ,IAAI,WAAW,GAAG,MAAM,CAAC,SAAS,CAAC;IAC3C,QAAQ,IAAI,WAAW,GAAG,CAAC,MAAM,CAAC,SAAS,CAAC;IAC5C,QAAQ,IAAI,KAAK,GAAG,MAAM,CAAC,SAAS,CAAC;IACrC,QAAQ,IAAI,KAAK,GAAG,CAAC,MAAM,CAAC,SAAS,CAAC;AACtC;IACA,QAAQ,MAAM,IAAI,CAAC,GAAG,CAAC,EAAE,GAAG,GAAG,UAAU,CAAC,MAAM,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE;IAChE,YAAY,IAAI,QAAQ,GAAG,SAAS,CAAC,uBAAuB,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC;IAC5E,YAAY,IAAI,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,QAAQ,CAAC,SAAS,CAAC,CAAC;IACtD,YAAY,IAAI,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,QAAQ,CAAC,SAAS,CAAC,CAAC;IACtD,YAAY,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,EAAE,QAAQ,CAAC,QAAQ,CAAC,CAAC;IACvD,YAAY,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,EAAE,QAAQ,CAAC,QAAQ,CAAC,CAAC;AACvD;IACA,YAAY,IAAI,WAAW,GAAG,QAAQ,CAAC,SAAS,IAAI,CAAC,IAAI,QAAQ,CAAC,SAAS,GAAG,QAAQ,CAAC,SAAS,IAAID,qBAAU,CAAC,MAAM,CAAC;IACtH,YAAY,WAAW,GAAG,IAAI,CAAC,GAAG,CAAC,WAAW,EAAE,WAAW,CAAC,CAAC;IAC7D,YAAY,WAAW,GAAG,IAAI,CAAC,GAAG,CAAC,WAAW,EAAE,WAAW,CAAC,CAAC;IAC7D,SAAS;AACT;IACA,QAAQ,GAAG,IAAI,GAAG,IAAI,GAAG,WAAW,GAAG,WAAW,EAAE;IACpD,YAAY,IAAI,GAAG,WAAW,CAAC;IAC/B,YAAY,IAAI,GAAG,WAAW,CAAC;AAC/B;IACA,YAAY,IAAI,IAAI,GAAGA,qBAAU,CAAC,EAAE,EAAE;IACtC,gBAAgB,IAAI,GAAG,IAAI,GAAGA,qBAAU,CAAC,MAAM,CAAC;IAChD,aAAa;IACb,YAAY,IAAI,IAAI,GAAGA,qBAAU,CAAC,EAAE,EAAE;IACtC,gBAAgB,IAAI,GAAG,IAAI,GAAGA,qBAAU,CAAC,MAAM,CAAC;IAChD,aAAa;IACb,SAAS;AACT;IACA,QAAQ,IAAI,CAACF,YAAO,CAAC,MAAM,CAAC,EAAE;IAC9B,YAAY,OAAO,IAAI,SAAS,CAAC,IAAI,EAAE,KAAK,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;IAC3D,SAAS;AACT;IACA,QAAQ,MAAM,CAAC,IAAI,GAAG,IAAI,CAAC;IAC3B,QAAQ,MAAM,CAAC,KAAK,GAAG,KAAK,CAAC;IAC7B,QAAQ,MAAM,CAAC,IAAI,GAAG,IAAI,CAAC;IAC3B,QAAQ,MAAM,CAAC,KAAK,GAAG,KAAK,CAAC;IAC7B,QAAQ,OAAO,MAAM,CAAC;IACtB,KAAK,CAAC;AACN;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,SAAS,CAAC,KAAK,GAAG,SAAS,SAAS,EAAE,MAAM,EAAE;IAClD,QAAQ,IAAI,CAACA,YAAO,CAAC,SAAS,CAAC,EAAE;IACjC,YAAY,OAAO,SAAS,CAAC;IAC7B,SAAS;AACT;IACA,QAAQ,IAAI,CAACA,YAAO,CAAC,MAAM,CAAC,EAAE;IAC9B,YAAY,OAAO,IAAI,SAAS,CAAC,SAAS,CAAC,IAAI,EAAE,SAAS,CAAC,KAAK,EAAE,SAAS,CAAC,IAAI,EAAE,SAAS,CAAC,KAAK,CAAC,CAAC;IACnG,SAAS;AACT;IACA,QAAQ,MAAM,CAAC,IAAI,GAAG,SAAS,CAAC,IAAI,CAAC;IACrC,QAAQ,MAAM,CAAC,KAAK,GAAG,SAAS,CAAC,KAAK,CAAC;IACvC,QAAQ,MAAM,CAAC,IAAI,GAAG,SAAS,CAAC,IAAI,CAAC;IACrC,QAAQ,MAAM,CAAC,KAAK,GAAG,SAAS,CAAC,KAAK,CAAC;IACvC,QAAQ,OAAO,MAAM,CAAC;IACtB,KAAK,CAAC;AACN;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,SAAS,CAAC,aAAa,GAAG,SAAS,IAAI,EAAE,KAAK,EAAE,eAAe,EAAE;IACrE,QAAQ,eAAe,GAAGG,iBAAY,CAAC,eAAe,EAAE,CAAC,CAAC,CAAC;AAC3D;IACA,QAAQ,OAAO,CAAC,IAAI,KAAK,KAAK;IAC9B,gBAAgBH,YAAO,CAAC,IAAI,CAAC;IAC7B,gBAAgBA,YAAO,CAAC,KAAK,CAAC;IAC9B,iBAAiB,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,GAAG,KAAK,CAAC,IAAI,CAAC,IAAI,eAAe,CAAC;IACrE,iBAAiB,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC,KAAK,CAAC,IAAI,eAAe,CAAC;IACvE,iBAAiB,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,GAAG,KAAK,CAAC,IAAI,CAAC,IAAI,eAAe,CAAC;IACrE,iBAAiB,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC,KAAK,CAAC,IAAI,eAAe,CAAC,CAAC,CAAC;IACzE,KAAK,CAAC;AACN;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,SAAS,CAAC,SAAS,CAAC,KAAK,GAAG,SAAS,MAAM,EAAE;IACjD,QAAQ,OAAO,SAAS,CAAC,KAAK,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;IAC7C,KAAK,CAAC;AACN;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,SAAS,CAAC,SAAS,CAAC,MAAM,GAAG,SAAS,KAAK,EAAE;IACjD,QAAQ,OAAO,SAAS,CAAC,MAAM,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;IAC7C,KAAK,CAAC;AACN;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,SAAS,CAAC,MAAM,GAAG,SAAS,IAAI,EAAE,KAAK,EAAE;IAC7C,QAAQ,OAAO,CAAC,IAAI,KAAK,KAAK;IAC9B,gBAAgB,CAACA,YAAO,CAAC,IAAI,CAAC;IAC9B,iBAAiBA,YAAO,CAAC,KAAK,CAAC,CAAC;IAChC,iBAAiB,IAAI,CAAC,IAAI,KAAK,KAAK,CAAC,IAAI,CAAC;IAC1C,iBAAiB,IAAI,CAAC,KAAK,KAAK,KAAK,CAAC,KAAK,CAAC;IAC5C,iBAAiB,IAAI,CAAC,IAAI,KAAK,KAAK,CAAC,IAAI,CAAC;IAC1C,iBAAiB,IAAI,CAAC,KAAK,KAAK,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC;IAC9C,KAAK,CAAC;AACN;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,SAAS,CAAC,SAAS,CAAC,aAAa,GAAG,SAAS,KAAK,EAAE,OAAO,EAAE;IACjE,QAAQ,OAAO,GAAGG,iBAAY,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC;AAC3C;IACA,QAAQ,OAAO,SAAS,CAAC,aAAa,CAAC,IAAI,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;IAC7D,KAAK,CAAC;AACN;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,SAAS,CAAC,QAAQ,GAAG,SAAS,SAAS,EAAE;IAC7C;IACA,QAAQC,WAAK,CAAC,MAAM,CAAC,MAAM,CAAC,WAAW,EAAE,SAAS,CAAC,CAAC;AACpD;IACA,QAAQ,IAAI,KAAK,GAAG,SAAS,CAAC,KAAK,CAAC;IACpC,QAAQA,WAAK,CAAC,MAAM,CAAC,MAAM,CAAC,mBAAmB,CAAC,OAAO,EAAE,KAAK,EAAE,CAACF,qBAAU,CAAC,WAAW,CAAC,CAAC;IACzF,QAAQE,WAAK,CAAC,MAAM,CAAC,MAAM,CAAC,gBAAgB,CAAC,OAAO,EAAE,KAAK,EAAEF,qBAAU,CAAC,WAAW,CAAC,CAAC;AACrF;IACA,QAAQ,IAAI,KAAK,GAAG,SAAS,CAAC,KAAK,CAAC;IACpC,QAAQE,WAAK,CAAC,MAAM,CAAC,MAAM,CAAC,mBAAmB,CAAC,OAAO,EAAE,KAAK,EAAE,CAACF,qBAAU,CAAC,WAAW,CAAC,CAAC;IACzF,QAAQE,WAAK,CAAC,MAAM,CAAC,MAAM,CAAC,gBAAgB,CAAC,OAAO,EAAE,KAAK,EAAEF,qBAAU,CAAC,WAAW,CAAC,CAAC;AACrF;IACA,QAAQ,IAAI,IAAI,GAAG,SAAS,CAAC,IAAI,CAAC;IAClC,QAAQE,WAAK,CAAC,MAAM,CAAC,MAAM,CAAC,mBAAmB,CAAC,MAAM,EAAE,IAAI,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;IACxE,QAAQA,WAAK,CAAC,MAAM,CAAC,MAAM,CAAC,gBAAgB,CAAC,MAAM,EAAE,IAAI,EAAE,IAAI,CAAC,EAAE,CAAC,CAAC;AACpE;IACA,QAAQ,IAAI,IAAI,GAAG,SAAS,CAAC,IAAI,CAAC;IAClC,QAAQA,WAAK,CAAC,MAAM,CAAC,MAAM,CAAC,mBAAmB,CAAC,MAAM,EAAE,IAAI,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;IACxE,QAAQA,WAAK,CAAC,MAAM,CAAC,MAAM,CAAC,gBAAgB,CAAC,MAAM,EAAE,IAAI,EAAE,IAAI,CAAC,EAAE,CAAC,CAAC;IACpE;IACA,KAAK,CAAC;AACN;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,SAAS,CAAC,SAAS,GAAG,SAAS,SAAS,EAAE,MAAM,EAAE;IACtD,QAAQ,IAAI,CAACJ,YAAO,CAAC,MAAM,CAAC,EAAE;IAC9B,YAAY,OAAO,IAAI,YAAY,CAAC,SAAS,CAAC,IAAI,EAAE,SAAS,CAAC,KAAK,CAAC,CAAC;IACrE,SAAS;IACT,QAAQ,MAAM,CAAC,SAAS,GAAG,SAAS,CAAC,IAAI,CAAC;IAC1C,QAAQ,MAAM,CAAC,QAAQ,GAAG,SAAS,CAAC,KAAK,CAAC;IAC1C,QAAQ,MAAM,CAAC,MAAM,GAAG,GAAG,CAAC;IAC5B,QAAQ,OAAO,MAAM,CAAC;IACtB,KAAK,CAAC;AACN;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,SAAS,CAAC,SAAS,GAAG,SAAS,SAAS,EAAE,MAAM,EAAE;IACtD,QAAQ,IAAI,CAACA,YAAO,CAAC,MAAM,CAAC,EAAE;IAC9B,YAAY,OAAO,IAAI,YAAY,CAAC,SAAS,CAAC,IAAI,EAAE,SAAS,CAAC,KAAK,CAAC,CAAC;IACrE,SAAS;IACT,QAAQ,MAAM,CAAC,SAAS,GAAG,SAAS,CAAC,IAAI,CAAC;IAC1C,QAAQ,MAAM,CAAC,QAAQ,GAAG,SAAS,CAAC,KAAK,CAAC;IAC1C,QAAQ,MAAM,CAAC,MAAM,GAAG,GAAG,CAAC;IAC5B,QAAQ,OAAO,MAAM,CAAC;IACtB,KAAK,CAAC;AACN;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,SAAS,CAAC,SAAS,GAAG,SAAS,SAAS,EAAE,MAAM,EAAE;IACtD,QAAQ,IAAI,CAACA,YAAO,CAAC,MAAM,CAAC,EAAE;IAC9B,YAAY,OAAO,IAAI,YAAY,CAAC,SAAS,CAAC,IAAI,EAAE,SAAS,CAAC,KAAK,CAAC,CAAC;IACrE,SAAS;IACT,QAAQ,MAAM,CAAC,SAAS,GAAG,SAAS,CAAC,IAAI,CAAC;IAC1C,QAAQ,MAAM,CAAC,QAAQ,GAAG,SAAS,CAAC,KAAK,CAAC;IAC1C,QAAQ,MAAM,CAAC,MAAM,GAAG,GAAG,CAAC;IAC5B,QAAQ,OAAO,MAAM,CAAC;IACtB,KAAK,CAAC;AACN;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,SAAS,CAAC,SAAS,GAAG,SAAS,SAAS,EAAE,MAAM,EAAE;IACtD,QAAQ,IAAI,CAACA,YAAO,CAAC,MAAM,CAAC,EAAE;IAC9B,YAAY,OAAO,IAAI,YAAY,CAAC,SAAS,CAAC,IAAI,EAAE,SAAS,CAAC,KAAK,CAAC,CAAC;IACrE,SAAS;IACT,QAAQ,MAAM,CAAC,SAAS,GAAG,SAAS,CAAC,IAAI,CAAC;IAC1C,QAAQ,MAAM,CAAC,QAAQ,GAAG,SAAS,CAAC,KAAK,CAAC;IAC1C,QAAQ,MAAM,CAAC,MAAM,GAAG,GAAG,CAAC;IAC5B,QAAQ,OAAO,MAAM,CAAC;IACtB,KAAK,CAAC;AACN;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,SAAS,CAAC,MAAM,GAAG,SAAS,SAAS,EAAE,MAAM,EAAE;IACnD,QAAQ,IAAI,IAAI,GAAG,SAAS,CAAC,IAAI,CAAC;IAClC,QAAQ,IAAI,IAAI,GAAG,SAAS,CAAC,IAAI,CAAC;AAClC;IACA,QAAQ,IAAI,IAAI,GAAG,IAAI,EAAE;IACzB,YAAY,IAAI,IAAIE,qBAAU,CAAC,MAAM,CAAC;IACtC,SAAS;AACT;IACA,QAAQ,IAAI,SAAS,GAAGA,qBAAU,CAAC,cAAc,CAAC,CAAC,IAAI,GAAG,IAAI,IAAI,GAAG,CAAC,CAAC;IACvE,QAAQ,IAAI,QAAQ,GAAG,CAAC,SAAS,CAAC,KAAK,GAAG,SAAS,CAAC,KAAK,IAAI,GAAG,CAAC;AACjE;IACA,QAAQ,IAAI,CAACF,YAAO,CAAC,MAAM,CAAC,EAAE;IAC9B,YAAY,OAAO,IAAI,YAAY,CAAC,SAAS,EAAE,QAAQ,CAAC,CAAC;IACzD,SAAS;AACT;IACA,QAAQ,MAAM,CAAC,SAAS,GAAG,SAAS,CAAC;IACrC,QAAQ,MAAM,CAAC,QAAQ,GAAG,QAAQ,CAAC;IACnC,QAAQ,MAAM,CAAC,MAAM,GAAG,GAAG,CAAC;IAC5B,QAAQ,OAAO,MAAM,CAAC;IACtB,KAAK,CAAC;AACN;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,SAAS,CAAC,YAAY,GAAG,SAAS,SAAS,EAAE,cAAc,EAAE,MAAM,EAAE;IACzE,QAAQ,IAAI,aAAa,GAAG,SAAS,CAAC,IAAI,CAAC;IAC3C,QAAQ,IAAI,aAAa,GAAG,SAAS,CAAC,IAAI,CAAC;AAC3C;IACA,QAAQ,IAAI,kBAAkB,GAAG,cAAc,CAAC,IAAI,CAAC;IACrD,QAAQ,IAAI,kBAAkB,GAAG,cAAc,CAAC,IAAI,CAAC;AACrD;IACA,QAAQ,IAAI,aAAa,GAAG,aAAa,IAAI,kBAAkB,GAAG,GAAG,EAAE;IACvE,YAAY,aAAa,IAAIE,qBAAU,CAAC,MAAM,CAAC;IAC/C,SAAS,MAAM,IAAI,kBAAkB,GAAG,kBAAkB,IAAI,aAAa,GAAG,GAAG,EAAE;IACnF,YAAY,kBAAkB,IAAIA,qBAAU,CAAC,MAAM,CAAC;IACpD,SAAS;AACT;IACA,QAAQ,IAAI,aAAa,GAAG,aAAa,IAAI,kBAAkB,GAAG,GAAG,EAAE;IACvE,YAAY,kBAAkB,IAAIA,qBAAU,CAAC,MAAM,CAAC;IACpD,SAAS,MAAM,IAAI,kBAAkB,GAAG,kBAAkB,IAAI,aAAa,GAAG,GAAG,EAAE;IACnF,YAAY,aAAa,IAAIA,qBAAU,CAAC,MAAM,CAAC;IAC/C,SAAS;AACT;IACA,QAAQ,IAAI,IAAI,GAAGA,qBAAU,CAAC,cAAc,CAAC,IAAI,CAAC,GAAG,CAAC,aAAa,EAAE,kBAAkB,CAAC,CAAC,CAAC;IAC1F,QAAQ,IAAI,IAAI,GAAGA,qBAAU,CAAC,cAAc,CAAC,IAAI,CAAC,GAAG,CAAC,aAAa,EAAE,kBAAkB,CAAC,CAAC,CAAC;AAC1F;IACA,QAAQ,IAAI,CAAC,SAAS,CAAC,IAAI,GAAG,SAAS,CAAC,IAAI,IAAI,cAAc,CAAC,IAAI,GAAG,cAAc,CAAC,IAAI,KAAK,IAAI,IAAI,IAAI,EAAE;IAC5G,YAAY,OAAO,SAAS,CAAC;IAC7B,SAAS;AACT;IACA,QAAQ,IAAI,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC,KAAK,EAAE,cAAc,CAAC,KAAK,CAAC,CAAC;IACpE,QAAQ,IAAI,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC,KAAK,EAAE,cAAc,CAAC,KAAK,CAAC,CAAC;AACpE;IACA,QAAQ,IAAI,KAAK,IAAI,KAAK,EAAE;IAC5B,YAAY,OAAO,SAAS,CAAC;IAC7B,SAAS;AACT;IACA,QAAQ,IAAI,CAACF,YAAO,CAAC,MAAM,CAAC,EAAE;IAC9B,YAAY,OAAO,IAAI,SAAS,CAAC,IAAI,EAAE,KAAK,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;IAC3D,SAAS;IACT,QAAQ,MAAM,CAAC,IAAI,GAAG,IAAI,CAAC;IAC3B,QAAQ,MAAM,CAAC,KAAK,GAAG,KAAK,CAAC;IAC7B,QAAQ,MAAM,CAAC,IAAI,GAAG,IAAI,CAAC;IAC3B,QAAQ,MAAM,CAAC,KAAK,GAAG,KAAK,CAAC;IAC7B,QAAQ,OAAO,MAAM,CAAC;IACtB,KAAK,CAAC;AACN;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,SAAS,CAAC,kBAAkB,GAAG,SAAS,SAAS,EAAE,cAAc,EAAE,MAAM,EAAE;IAC/E,QAAQ,IAAI,IAAI,GAAG,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC,IAAI,EAAE,cAAc,CAAC,IAAI,CAAC,CAAC;IACjE,QAAQ,IAAI,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC,KAAK,EAAE,cAAc,CAAC,KAAK,CAAC,CAAC;IACpE,QAAQ,IAAI,IAAI,GAAG,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC,IAAI,EAAE,cAAc,CAAC,IAAI,CAAC,CAAC;IACjE,QAAQ,IAAI,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC,KAAK,EAAE,cAAc,CAAC,KAAK,CAAC,CAAC;AACpE;IACA,QAAQ,IAAI,KAAK,IAAI,KAAK,IAAI,IAAI,IAAI,IAAI,EAAE;IAC5C,YAAY,OAAO,SAAS,CAAC;IAC7B,SAAS;AACT;IACA,QAAQ,IAAI,CAACA,YAAO,CAAC,MAAM,CAAC,EAAE;IAC9B,YAAY,OAAO,IAAI,SAAS,CAAC,IAAI,EAAE,KAAK,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;IAC3D,SAAS;AACT;IACA,QAAQ,MAAM,CAAC,IAAI,GAAG,IAAI,CAAC;IAC3B,QAAQ,MAAM,CAAC,KAAK,GAAG,KAAK,CAAC;IAC7B,QAAQ,MAAM,CAAC,IAAI,GAAG,IAAI,CAAC;IAC3B,QAAQ,MAAM,CAAC,KAAK,GAAG,KAAK,CAAC;IAC7B,QAAQ,OAAO,MAAM,CAAC;IACtB,KAAK,CAAC;AACN;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,SAAS,CAAC,KAAK,GAAG,SAAS,SAAS,EAAE,cAAc,EAAE,MAAM,EAAE;IAClE,QAAQ,IAAI,CAACA,YAAO,CAAC,MAAM,CAAC,EAAE;IAC9B,YAAY,MAAM,GAAG,IAAI,SAAS,EAAE,CAAC;IACrC,SAAS;AACT;IACA,QAAQ,IAAI,aAAa,GAAG,SAAS,CAAC,IAAI,CAAC;IAC3C,QAAQ,IAAI,aAAa,GAAG,SAAS,CAAC,IAAI,CAAC;AAC3C;IACA,QAAQ,IAAI,kBAAkB,GAAG,cAAc,CAAC,IAAI,CAAC;IACrD,QAAQ,IAAI,kBAAkB,GAAG,cAAc,CAAC,IAAI,CAAC;AACrD;IACA,QAAQ,IAAI,aAAa,GAAG,aAAa,IAAI,kBAAkB,GAAG,GAAG,EAAE;IACvE,YAAY,aAAa,IAAIE,qBAAU,CAAC,MAAM,CAAC;IAC/C,SAAS,MAAM,IAAI,kBAAkB,GAAG,kBAAkB,IAAI,aAAa,GAAG,GAAG,EAAE;IACnF,YAAY,kBAAkB,IAAIA,qBAAU,CAAC,MAAM,CAAC;IACpD,SAAS;AACT;IACA,QAAQ,IAAI,aAAa,GAAG,aAAa,IAAI,kBAAkB,GAAG,GAAG,EAAE;IACvE,YAAY,kBAAkB,IAAIA,qBAAU,CAAC,MAAM,CAAC;IACpD,SAAS,MAAM,IAAI,kBAAkB,GAAG,kBAAkB,IAAI,aAAa,GAAG,GAAG,EAAE;IACnF,YAAY,aAAa,IAAIA,qBAAU,CAAC,MAAM,CAAC;IAC/C,SAAS;AACT;IACA,QAAQ,IAAI,IAAI,GAAGA,qBAAU,CAAC,qBAAqB,CAAC,IAAI,CAAC,GAAG,CAAC,aAAa,EAAE,kBAAkB,CAAC,CAAC,CAAC;IACjG,QAAQ,IAAI,IAAI,GAAGA,qBAAU,CAAC,qBAAqB,CAAC,IAAI,CAAC,GAAG,CAAC,aAAa,EAAE,kBAAkB,CAAC,CAAC,CAAC;AACjG;IACA,QAAQ,MAAM,CAAC,IAAI,GAAG,IAAI,CAAC;IAC3B,QAAQ,MAAM,CAAC,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC,KAAK,EAAE,cAAc,CAAC,KAAK,CAAC,CAAC;IACvE,QAAQ,MAAM,CAAC,IAAI,GAAG,IAAI,CAAC;IAC3B,QAAQ,MAAM,CAAC,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC,KAAK,EAAE,cAAc,CAAC,KAAK,CAAC,CAAC;AACvE;IACA,QAAQ,OAAO,MAAM,CAAC;IACtB,KAAK,CAAC;AACN;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,SAAS,CAAC,MAAM,GAAG,SAAS,SAAS,EAAE,YAAY,EAAE,MAAM,EAAE;IACjE,QAAQ,IAAI,CAACF,YAAO,CAAC,MAAM,CAAC,EAAE;IAC9B,YAAY,MAAM,GAAG,IAAI,SAAS,EAAE,CAAC;IACrC,SAAS;AACT;IACA,QAAQ,MAAM,CAAC,IAAI,GAAG,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC,IAAI,EAAE,YAAY,CAAC,SAAS,CAAC,CAAC;IACvE,QAAQ,MAAM,CAAC,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC,KAAK,EAAE,YAAY,CAAC,QAAQ,CAAC,CAAC;IACxE,QAAQ,MAAM,CAAC,IAAI,GAAG,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC,IAAI,EAAE,YAAY,CAAC,SAAS,CAAC,CAAC;IACvE,QAAQ,MAAM,CAAC,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC,KAAK,EAAE,YAAY,CAAC,QAAQ,CAAC,CAAC;AACxE;IACA,QAAQ,OAAO,MAAM,CAAC;IACtB,KAAK,CAAC;AACN;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,SAAS,CAAC,QAAQ,GAAG,SAAS,SAAS,EAAE,YAAY,EAAE;IAC3D,QAAQ,IAAI,SAAS,GAAG,YAAY,CAAC,SAAS,CAAC;IAC/C,QAAQ,IAAI,QAAQ,GAAG,YAAY,CAAC,QAAQ,CAAC;AAC7C;IACA,QAAQ,IAAI,IAAI,GAAG,SAAS,CAAC,IAAI,CAAC;IAClC,QAAQ,IAAI,IAAI,GAAG,SAAS,CAAC,IAAI,CAAC;AAClC;IACA,QAAQ,IAAI,IAAI,GAAG,IAAI,EAAE;IACzB,YAAY,IAAI,IAAIE,qBAAU,CAAC,MAAM,CAAC;IACtC,YAAY,IAAI,SAAS,GAAG,GAAG,EAAE;IACjC,gBAAgB,SAAS,IAAIA,qBAAU,CAAC,MAAM,CAAC;IAC/C,aAAa;IACb,SAAS;IACT,QAAQ,OAAO,CAAC,SAAS,GAAG,IAAI,IAAIA,qBAAU,CAAC,aAAa,CAAC,SAAS,EAAE,IAAI,EAAEA,qBAAU,CAAC,SAAS,CAAC;IACnG,gBAAgB,SAAS,GAAG,IAAI,IAAIA,qBAAU,CAAC,aAAa,CAAC,SAAS,EAAE,IAAI,EAAEA,qBAAU,CAAC,SAAS,CAAC,CAAC;IACpG,eAAe,QAAQ,IAAI,SAAS,CAAC,KAAK;IAC1C,eAAe,QAAQ,IAAI,SAAS,CAAC,KAAK,CAAC;IAC3C,KAAK,CAAC;AACN;IACA,IAAI,IAAI,mBAAmB,GAAG,IAAI,YAAY,EAAE,CAAC;IACjD;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,SAAS,CAAC,SAAS,GAAG,SAAS,SAAS,EAAE,SAAS,EAAE,aAAa,EAAE,MAAM,EAAE;IAChF,QAAQ,SAAS,GAAGC,iBAAY,CAAC,SAAS,EAAE,SAAS,CAAC,KAAK,CAAC,CAAC;IAC7D,QAAQ,aAAa,GAAGA,iBAAY,CAAC,aAAa,EAAE,GAAG,CAAC,CAAC;AACzD;IACA,QAAQ,IAAI,CAACH,YAAO,CAAC,MAAM,CAAC,EAAE;IAC9B,YAAY,MAAM,GAAG,EAAE,CAAC;IACxB,SAAS;IACT,QAAQ,IAAI,MAAM,GAAG,CAAC,CAAC;AACvB;IACA,QAAQ,IAAI,KAAK,GAAG,SAAS,CAAC,KAAK,CAAC;IACpC,QAAQ,IAAI,KAAK,GAAG,SAAS,CAAC,KAAK,CAAC;IACpC,QAAQ,IAAI,IAAI,GAAG,SAAS,CAAC,IAAI,CAAC;IAClC,QAAQ,IAAI,IAAI,GAAG,SAAS,CAAC,IAAI,CAAC;AAClC;IACA,QAAQ,IAAI,GAAG,GAAG,mBAAmB,CAAC;IACtC,QAAQ,GAAG,CAAC,MAAM,GAAG,aAAa,CAAC;AACnC;IACA,QAAQ,GAAG,CAAC,SAAS,GAAG,IAAI,CAAC;IAC7B,QAAQ,GAAG,CAAC,QAAQ,GAAG,KAAK,CAAC;IAC7B,QAAQ,MAAM,CAAC,MAAM,CAAC,GAAG,SAAS,CAAC,uBAAuB,CAAC,GAAG,EAAE,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC;IAChF,QAAQ,MAAM,EAAE,CAAC;AACjB;IACA,QAAQ,GAAG,CAAC,SAAS,GAAG,IAAI,CAAC;IAC7B,QAAQ,MAAM,CAAC,MAAM,CAAC,GAAG,SAAS,CAAC,uBAAuB,CAAC,GAAG,EAAE,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC;IAChF,QAAQ,MAAM,EAAE,CAAC;AACjB;IACA,QAAQ,GAAG,CAAC,QAAQ,GAAG,KAAK,CAAC;IAC7B,QAAQ,MAAM,CAAC,MAAM,CAAC,GAAG,SAAS,CAAC,uBAAuB,CAAC,GAAG,EAAE,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC;IAChF,QAAQ,MAAM,EAAE,CAAC;AACjB;IACA,QAAQ,GAAG,CAAC,SAAS,GAAG,IAAI,CAAC;IAC7B,QAAQ,MAAM,CAAC,MAAM,CAAC,GAAG,SAAS,CAAC,uBAAuB,CAAC,GAAG,EAAE,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC;IAChF,QAAQ,MAAM,EAAE,CAAC;AACjB;IACA,QAAQ,IAAI,KAAK,GAAG,GAAG,EAAE;IACzB,YAAY,GAAG,CAAC,QAAQ,GAAG,KAAK,CAAC;IACjC,SAAS,MAAM,IAAI,KAAK,GAAG,GAAG,EAAE;IAChC,YAAY,GAAG,CAAC,QAAQ,GAAG,KAAK,CAAC;IACjC,SAAS,MAAM;IACf,YAAY,GAAG,CAAC,QAAQ,GAAG,GAAG,CAAC;IAC/B,SAAS;AACT;IACA,QAAQ,MAAM,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,EAAE,CAAC,EAAE;IACrC,YAAY,GAAG,CAAC,SAAS,GAAG,CAAC,IAAI,CAAC,EAAE,GAAG,CAAC,GAAGE,qBAAU,CAAC,WAAW,CAAC;IAClE,YAAY,IAAI,SAAS,CAAC,QAAQ,CAAC,SAAS,EAAE,GAAG,CAAC,EAAE;IACpD,gBAAgB,MAAM,CAAC,MAAM,CAAC,GAAG,SAAS,CAAC,uBAAuB,CAAC,GAAG,EAAE,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC;IACxF,gBAAgB,MAAM,EAAE,CAAC;IACzB,aAAa;IACb,SAAS;AACT;IACA,QAAQ,IAAI,GAAG,CAAC,QAAQ,KAAK,GAAG,EAAE;IAClC,YAAY,GAAG,CAAC,SAAS,GAAG,IAAI,CAAC;IACjC,YAAY,MAAM,CAAC,MAAM,CAAC,GAAG,SAAS,CAAC,uBAAuB,CAAC,GAAG,EAAE,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC;IACpF,YAAY,MAAM,EAAE,CAAC;IACrB,YAAY,GAAG,CAAC,SAAS,GAAG,IAAI,CAAC;IACjC,YAAY,MAAM,CAAC,MAAM,CAAC,GAAG,SAAS,CAAC,uBAAuB,CAAC,GAAG,EAAE,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC;IACpF,YAAY,MAAM,EAAE,CAAC;IACrB,SAAS;IACT,QAAQ,MAAM,CAAC,MAAM,GAAG,MAAM,CAAC;IAC/B,QAAQ,OAAO,MAAM,CAAC;IACtB,KAAK,CAAC;AACN;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,SAAS,CAAC,SAAS,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,SAAS,CAAC,CAAC,IAAI,CAAC,EAAE,EAAE,CAACA,qBAAU,CAAC,WAAW,EAAE,IAAI,CAAC,EAAE,EAAEA,qBAAU,CAAC,WAAW,CAAC,CAAC,CAAC;;;;;;;;;;"}