define(["./when-45f3d25d","./Check-34538dad","./Cartesian3-ef6ea826","./Cartesian2-a652b463","./BoundingSphere-038d5fbc","./Transforms-c8a82813","./Matrix4-f54b529f","./RuntimeError-86da6af2","./WebGLConstants-3660bc8f","./ComponentDatatype-d28c2e26","./GeometryAttribute-dfebcc43","./PrimitiveType-30fa6f85","./GeometryAttributes-9d45f9e2","./IndexDatatype-6d2070e9","./IntersectionTests-b186d985","./Plane-a0c58786","./VertexFormat-06aa4e32","./arrayRemoveDuplicates-e5b24eaf","./ArcType-39be7a32","./EllipsoidRhumbLine-0c6cd7c8","./EllipsoidGeodesic-1abfd38d","./PolylinePipeline-e4210f09","./Color-44055af0"],(function(e,t,r,a,o,n,i,l,s,p,d,c,u,y,m,f,h,v,C,g,_,A,E){"use strict";var P=[];function b(e,t,r,a,o){var n,i=P;i.length=o;var l=r.red,s=r.green,p=r.blue,d=r.alpha,c=a.red,u=a.green,y=a.blue,m=a.alpha;if(E.Color.equals(r,a)){for(n=0;n<o;n++)i[n]=E.Color.clone(r);return i}var f=(c-l)/o,h=(u-s)/o,v=(y-p)/o,C=(m-d)/o;for(n=0;n<o;n++)i[n]=new E.Color(l+n*f,s+n*h,p+n*v,d+n*C);return i}function w(t){var o=(t=e.defaultValue(t,e.defaultValue.EMPTY_OBJECT)).positions,n=t.colors,i=e.defaultValue(t.width,1),l=e.defaultValue(t.colorsPerVertex,!1);this._positions=o,this._colors=n,this._width=i,this._colorsPerVertex=l,this._vertexFormat=h.VertexFormat.clone(e.defaultValue(t.vertexFormat,h.VertexFormat.DEFAULT)),this._arcType=e.defaultValue(t.arcType,C.ArcType.GEODESIC),this._granularity=e.defaultValue(t.granularity,r.CesiumMath.RADIANS_PER_DEGREE),this._ellipsoid=a.Ellipsoid.clone(e.defaultValue(t.ellipsoid,a.Ellipsoid.WGS84)),this._workerName="createPolylineGeometry";var s=1+o.length*r.Cartesian3.packedLength;s+=e.defined(n)?1+n.length*E.Color.packedLength:1,this.packedLength=s+a.Ellipsoid.packedLength+h.VertexFormat.packedLength+4}w.pack=function(t,o,n){var i;n=e.defaultValue(n,0);var l=t._positions,s=l.length;for(o[n++]=s,i=0;i<s;++i,n+=r.Cartesian3.packedLength)r.Cartesian3.pack(l[i],o,n);var p=t._colors;for(s=e.defined(p)?p.length:0,o[n++]=s,i=0;i<s;++i,n+=E.Color.packedLength)E.Color.pack(p[i],o,n);return a.Ellipsoid.pack(t._ellipsoid,o,n),n+=a.Ellipsoid.packedLength,h.VertexFormat.pack(t._vertexFormat,o,n),n+=h.VertexFormat.packedLength,o[n++]=t._width,o[n++]=t._colorsPerVertex?1:0,o[n++]=t._arcType,o[n]=t._granularity,o};var T=a.Ellipsoid.clone(a.Ellipsoid.UNIT_SPHERE),x=new h.VertexFormat,k={positions:void 0,colors:void 0,ellipsoid:T,vertexFormat:x,width:void 0,colorsPerVertex:void 0,arcType:void 0,granularity:void 0};w.unpack=function(t,o,n){var i;o=e.defaultValue(o,0);var l=t[o++],s=new Array(l);for(i=0;i<l;++i,o+=r.Cartesian3.packedLength)s[i]=r.Cartesian3.unpack(t,o);var p=(l=t[o++])>0?new Array(l):void 0;for(i=0;i<l;++i,o+=E.Color.packedLength)p[i]=E.Color.unpack(t,o);var d=a.Ellipsoid.unpack(t,o,T);o+=a.Ellipsoid.packedLength;var c=h.VertexFormat.unpack(t,o,x);o+=h.VertexFormat.packedLength;var u=t[o++],y=1===t[o++],m=t[o++],f=t[o];return e.defined(n)?(n._positions=s,n._colors=p,n._ellipsoid=a.Ellipsoid.clone(d,n._ellipsoid),n._vertexFormat=h.VertexFormat.clone(c,n._vertexFormat),n._width=u,n._colorsPerVertex=y,n._arcType=m,n._granularity=f,n):(k.positions=s,k.colors=p,k.width=u,k.colorsPerVertex=y,k.arcType=m,k.granularity=f,new w(k))};var D=new r.Cartesian3,V=new r.Cartesian3,L=new r.Cartesian3,F=new r.Cartesian3;return w.createGeometry=function(t){var a,n,i,l=t._width,s=t._vertexFormat,m=t._colors,f=t._colorsPerVertex,h=t._arcType,g=t._granularity,_=t._ellipsoid,w=v.arrayRemoveDuplicates(t._positions,r.Cartesian3.equalsEpsilon),T=w.length;if(!(T<2||l<=0)){if(h===C.ArcType.GEODESIC||h===C.ArcType.RHUMB){var x,k;h===C.ArcType.GEODESIC?(x=r.CesiumMath.chordLength(g,_.maximumRadius),k=A.PolylinePipeline.numberOfPoints):(x=g,k=A.PolylinePipeline.numberOfPointsRhumbLine);var G=A.PolylinePipeline.extractHeights(w,_);if(e.defined(m)){var O=1;for(a=0;a<T-1;++a)O+=k(w[a],w[a+1],x);var R=new Array(O),S=0;for(a=0;a<T-1;++a){var B=w[a],I=w[a+1],U=m[a],N=k(B,I,x);if(f&&a<O){var M=b(0,0,U,m[a+1],N),H=M.length;for(n=0;n<H;++n)R[S++]=M[n]}else for(n=0;n<N;++n)R[S++]=E.Color.clone(U)}R[S]=E.Color.clone(m[m.length-1]),m=R,P.length=0}w=h===C.ArcType.GEODESIC?A.PolylinePipeline.generateCartesianArc({positions:w,minDistance:x,ellipsoid:_,height:G}):A.PolylinePipeline.generateCartesianRhumbArc({positions:w,granularity:x,ellipsoid:_,height:G})}var W,Y=4*(T=w.length)-4,q=new Float64Array(3*Y),z=new Float64Array(3*Y),J=new Float64Array(3*Y),j=new Float32Array(2*Y),K=s.st?new Float32Array(2*Y):void 0,Q=e.defined(m)?new Uint8Array(4*Y):void 0,X=0,Z=0,$=0,ee=0;for(n=0;n<T;++n){var te,re;0===n?(W=D,r.Cartesian3.subtract(w[0],w[1],W),r.Cartesian3.add(w[0],W,W)):W=w[n-1],r.Cartesian3.clone(W,L),r.Cartesian3.clone(w[n],V),n===T-1?(W=D,r.Cartesian3.subtract(w[T-1],w[T-2],W),r.Cartesian3.add(w[T-1],W,W)):W=w[n+1],r.Cartesian3.clone(W,F),e.defined(Q)&&(te=0===n||f?m[n]:m[n-1],n!==T-1&&(re=m[n]));var ae=n===T-1?2:4;for(i=0===n?2:0;i<ae;++i){r.Cartesian3.pack(V,q,X),r.Cartesian3.pack(L,z,X),r.Cartesian3.pack(F,J,X),X+=3;var oe=i-2<0?-1:1;if(j[Z++]=i%2*2-1,j[Z++]=oe*l,s.st&&(K[$++]=n/(T-1),K[$++]=Math.max(j[Z-2],0)),e.defined(Q)){var ne=i<2?te:re;Q[ee++]=E.Color.floatToByte(ne.red),Q[ee++]=E.Color.floatToByte(ne.green),Q[ee++]=E.Color.floatToByte(ne.blue),Q[ee++]=E.Color.floatToByte(ne.alpha)}}}var ie=new u.GeometryAttributes;ie.position=new d.GeometryAttribute({componentDatatype:p.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:q}),ie.prevPosition=new d.GeometryAttribute({componentDatatype:p.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:z}),ie.nextPosition=new d.GeometryAttribute({componentDatatype:p.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:J}),ie.expandAndWidth=new d.GeometryAttribute({componentDatatype:p.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:j}),s.st&&(ie.st=new d.GeometryAttribute({componentDatatype:p.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:K})),e.defined(Q)&&(ie.color=new d.GeometryAttribute({componentDatatype:p.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:4,values:Q,normalize:!0}));var le=y.IndexDatatype.createTypedArray(Y,6*T-6),se=0,pe=0,de=T-1;for(n=0;n<de;++n)le[pe++]=se,le[pe++]=se+2,le[pe++]=se+1,le[pe++]=se+1,le[pe++]=se+2,le[pe++]=se+3,se+=4;return new d.Geometry({attributes:ie,indices:le,primitiveType:c.PrimitiveType.TRIANGLES,boundingSphere:o.BoundingSphere.fromPoints(w),geometryType:d.GeometryType.POLYLINES})}},function(t,r){return e.defined(r)&&(t=w.unpack(t,r)),t._ellipsoid=a.Ellipsoid.clone(t._ellipsoid),w.createGeometry(t)}}));