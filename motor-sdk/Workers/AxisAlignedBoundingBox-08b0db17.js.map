{"version":3,"file":"AxisAlignedBoundingBox-08b0db17.js","sources":["../../Source/Core/AxisAlignedBoundingBox.js"],"sourcesContent":["import Cartesian3 from './Cartesian3.js';\r\nimport Matrix4 from './Matrix4.js';\r\nimport Check from './Check.js';\r\nimport defaultValue from './defaultValue.js';\r\nimport defined from './defined.js';\r\nimport Intersect from './Intersect.js';\r\n\r\n    /**\r\n     * Creates an instance of an AxisAlignedBoundingBox from the minimum and maximum points along the x, y, and z axes.\r\n     * @alias AxisAlignedBoundingBox\r\n     * @constructor\r\n     *\r\n     * @param {Cartesian3} [minimum=Cartesian3.ZERO] The minimum point along the x, y, and z axes.\r\n     * @param {Cartesian3} [maximum=Cartesian3.ZERO] The maximum point along the x, y, and z axes.\r\n     * @param {Cartesian3} [center] The center of the box; automatically computed if not supplied.\r\n     *\r\n     * @see BoundingSphere\r\n     * @see BoundingRectangle\r\n     */\r\n    function AxisAlignedBoundingBox(minimum, maximum, center) {\r\n        /**\r\n         * The minimum point defining the bounding box.\r\n         * @type {Cartesian3}\r\n         * @default {@link Cartesian3.ZERO}\r\n         */\r\n        this.minimum = Cartesian3.clone(defaultValue(minimum, Cartesian3.ZERO));\r\n\r\n        /**\r\n         * The maximum point defining the bounding box.\r\n         * @type {Cartesian3}\r\n         * @default {@link Cartesian3.ZERO}\r\n         */\r\n        this.maximum = Cartesian3.clone(defaultValue(maximum, Cartesian3.ZERO));\r\n\r\n        //If center was not defined, compute it.\r\n        if (!defined(center)) {\r\n            center = Cartesian3.midpoint(this.minimum, this.maximum, new Cartesian3());\r\n        } else {\r\n            center = Cartesian3.clone(center);\r\n        }\r\n\r\n        /**\r\n         * The center point of the bounding box.\r\n         * @type {Cartesian3}\r\n         */\r\n        this.center = center;\r\n    }\r\n\r\n    /**\r\n     * Computes an instance of an AxisAlignedBoundingBox. The box is determined by\r\n     * finding the points spaced the farthest apart on the x, y, and z axes.\r\n     *\r\n     * @param {Cartesian3[]} positions List of points that the bounding box will enclose.  Each point must have a <code>x</code>, <code>y</code>, and <code>z</code> properties.\r\n     * @param {AxisAlignedBoundingBox} [result] The object onto which to store the result.\r\n     * @returns {AxisAlignedBoundingBox} The modified result parameter or a new AxisAlignedBoundingBox instance if one was not provided.\r\n     *\r\n     * @example\r\n     * // Compute an axis aligned bounding box enclosing two points.\r\n     * var box = Cesium.AxisAlignedBoundingBox.fromPoints([new Cesium.Cartesian3(2, 0, 0), new Cesium.Cartesian3(-2, 0, 0)]);\r\n     */\r\n    AxisAlignedBoundingBox.fromPoints = function(positions, result) {\r\n        if (!defined(result)) {\r\n            result = new AxisAlignedBoundingBox();\r\n        }\r\n\r\n        if (!defined(positions) || positions.length === 0) {\r\n            result.minimum = Cartesian3.clone(Cartesian3.ZERO, result.minimum);\r\n            result.maximum = Cartesian3.clone(Cartesian3.ZERO, result.maximum);\r\n            result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);\r\n            return result;\r\n        }\r\n\r\n        var minimumX = positions[0].x;\r\n        var minimumY = positions[0].y;\r\n        var minimumZ = positions[0].z;\r\n\r\n        var maximumX = positions[0].x;\r\n        var maximumY = positions[0].y;\r\n        var maximumZ = positions[0].z;\r\n\r\n        var length = positions.length;\r\n        for ( var i = 1; i < length; i++) {\r\n            var p = positions[i];\r\n            var x = p.x;\r\n            var y = p.y;\r\n            var z = p.z;\r\n\r\n            minimumX = Math.min(x, minimumX);\r\n            maximumX = Math.max(x, maximumX);\r\n            minimumY = Math.min(y, minimumY);\r\n            maximumY = Math.max(y, maximumY);\r\n            minimumZ = Math.min(z, minimumZ);\r\n            maximumZ = Math.max(z, maximumZ);\r\n        }\r\n\r\n        var minimum = result.minimum;\r\n        minimum.x = minimumX;\r\n        minimum.y = minimumY;\r\n        minimum.z = minimumZ;\r\n\r\n        var maximum = result.maximum;\r\n        maximum.x = maximumX;\r\n        maximum.y = maximumY;\r\n        maximum.z = maximumZ;\r\n\r\n        result.center = Cartesian3.midpoint(minimum, maximum, result.center);\r\n\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Duplicates a AxisAlignedBoundingBox instance.\r\n     *\r\n     * @param {AxisAlignedBoundingBox} box The bounding box to duplicate.\r\n     * @param {AxisAlignedBoundingBox} [result] The object onto which to store the result.\r\n     * @returns {AxisAlignedBoundingBox} The modified result parameter or a new AxisAlignedBoundingBox instance if none was provided. (Returns undefined if box is undefined)\r\n     */\r\n    AxisAlignedBoundingBox.clone = function(box, result) {\r\n        if (!defined(box)) {\r\n            return undefined;\r\n        }\r\n\r\n        if (!defined(result)) {\r\n            return new AxisAlignedBoundingBox(box.minimum, box.maximum, box.center);\r\n        }\r\n\r\n        result.minimum = Cartesian3.clone(box.minimum, result.minimum);\r\n        result.maximum = Cartesian3.clone(box.maximum, result.maximum);\r\n        result.center = Cartesian3.clone(box.center, result.center);\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Compares the provided AxisAlignedBoundingBox componentwise and returns\r\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\r\n     *\r\n     * @param {AxisAlignedBoundingBox} [left] The first AxisAlignedBoundingBox.\r\n     * @param {AxisAlignedBoundingBox} [right] The second AxisAlignedBoundingBox.\r\n     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\r\n     */\r\n    AxisAlignedBoundingBox.equals = function(left, right) {\r\n        return (left === right) ||\r\n               ((defined(left)) &&\r\n                (defined(right)) &&\r\n                Cartesian3.equals(left.center, right.center) &&\r\n                Cartesian3.equals(left.minimum, right.minimum) &&\r\n                Cartesian3.equals(left.maximum, right.maximum));\r\n    };\r\n\r\n    var intersectScratch = new Cartesian3();\r\n    /**\r\n     * Determines which side of a plane a box is located.\r\n     *\r\n     * @param {AxisAlignedBoundingBox} box The bounding box to test.\r\n     * @param {Plane} plane The plane to test against.\r\n     * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane\r\n     *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is\r\n     *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box\r\n     *                      intersects the plane.\r\n     */\r\n    AxisAlignedBoundingBox.intersectPlane = function(box, plane) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('box', box);\r\n        Check.defined('plane', plane);\r\n        //>>includeEnd('debug');\r\n\r\n        intersectScratch = Cartesian3.subtract(box.maximum, box.minimum, intersectScratch);\r\n        var h = Cartesian3.multiplyByScalar(intersectScratch, 0.5, intersectScratch); //The positive half diagonal\r\n        var normal = plane.normal;\r\n        var e = h.x * Math.abs(normal.x) + h.y * Math.abs(normal.y) + h.z * Math.abs(normal.z);\r\n        var s = Cartesian3.dot(box.center, normal) + plane.distance; //signed distance from center\r\n\r\n        if (s - e > 0) {\r\n            return Intersect.INSIDE;\r\n        }\r\n\r\n        if (s + e < 0) {\r\n            //Not in front because normals point inward\r\n            return Intersect.OUTSIDE;\r\n        }\r\n\r\n        return Intersect.INTERSECTING;\r\n    };\r\n\r\n    /**\r\n     * Duplicates this AxisAlignedBoundingBox instance.\r\n     *\r\n     * @param {AxisAlignedBoundingBox} [result] The object onto which to store the result.\r\n     * @returns {AxisAlignedBoundingBox} The modified result parameter or a new AxisAlignedBoundingBox instance if one was not provided.\r\n     */\r\n    AxisAlignedBoundingBox.prototype.clone = function(result) {\r\n        return AxisAlignedBoundingBox.clone(this, result);\r\n    };\r\n\r\n    /**\r\n     * Determines which side of a plane this box is located.\r\n     *\r\n     * @param {Plane} plane The plane to test against.\r\n     * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane\r\n     *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is\r\n     *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box\r\n     *                      intersects the plane.\r\n     */\r\n    AxisAlignedBoundingBox.prototype.intersectPlane = function(plane) {\r\n        return AxisAlignedBoundingBox.intersectPlane(this, plane);\r\n    };\r\n\r\n    /**\r\n     * Compares this AxisAlignedBoundingBox against the provided AxisAlignedBoundingBox componentwise and returns\r\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\r\n     *\r\n     * @param {AxisAlignedBoundingBox} [right] The right hand side AxisAlignedBoundingBox.\r\n     * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\r\n     */\r\n    AxisAlignedBoundingBox.prototype.equals = function(right) {\r\n        return AxisAlignedBoundingBox.equals(this, right);\r\n    };\r\n\r\n    /**\r\n     * transformBy\r\n     *\r\n     * @param {Matrix4} matrix input.\r\n     * @returns {AxisAlignedBoundingBox} self.\r\n     */\r\n    AxisAlignedBoundingBox.prototype.transformBy = function(matrix) {\r\n        const vertices = this.getCornerAry();\r\n        vertices.forEach((vertex) => {\r\n            Matrix4.multiplyByPoint(matrix, vertex, vertex);\r\n        });\r\n        AxisAlignedBoundingBox.fromPoints(vertices, this);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * getLength\r\n     *\r\n     * @returns {Number} len\r\n     */\r\n    AxisAlignedBoundingBox.prototype.getLength = function() {\r\n        const l1 = (this.maximum.x - this.minimum.x) * (this.maximum.x - this.minimum.x);\r\n        const l2 = (this.maximum.y - this.minimum.y) * (this.maximum.y - this.minimum.y);\r\n        return Math.sqrt(l1 + l2);\r\n    }\r\n\r\n    /**\r\n     * get corner ary.\r\n     * @returns {Cartesian3[]} corner ary\r\n     */\r\n    AxisAlignedBoundingBox.prototype.getCornerAry = function() {\r\n        const vertices = [];\r\n        for (let i = 0; i < 2; ++i) {\r\n            for (let j = 0; j < 2; ++j) {\r\n                for (let k = 0; k < 2; ++k) {\r\n                    const x = i !== 0 ? this.maximum.x : this.minimum.x;\r\n                    const y = j !== 0 ? this.maximum.y : this.minimum.y;\r\n                    const z = k !== 0 ? this.maximum.z : this.minimum.z;\r\n                    const vertex = new Cartesian3(x, y, z);\r\n                    vertices.push(vertex);\r\n                }\r\n            }\r\n        }\r\n        return vertices;\r\n    }\r\n\r\n    /**\r\n     * addBox\r\n     *\r\n     * @param {AxisAlignedBoundingBox} box input.\r\n     */\r\n    AxisAlignedBoundingBox.prototype.addBox = function(box) {\r\n        const vertices = [this.minimum, this.maximum, box.minimum, box.maximum];\r\n        AxisAlignedBoundingBox.fromPoints(vertices, this);\r\n    }\r\n\r\n    /**\r\n     * addPt\r\n     *\r\n     * @param {Cartesian3} pt input.\r\n     */\r\n     AxisAlignedBoundingBox.prototype.addPt = function(pt) {\r\n        const vertices = [this.minimum, this.maximum, pt];\r\n        AxisAlignedBoundingBox.fromPoints(vertices, this);\r\n    }\r\n\r\n    /**\r\n     * isOverlap\r\n     *\r\n     * @param {AxisAlignedBoundingBox} box input.\r\n     * @returns {Boolean} isOverlap\r\n     */\r\n    AxisAlignedBoundingBox.prototype.isOverlap = function(cBox){\r\n        if (cBox.minimum.x - this.maximum.x > 1e-6 || this.minimum.x - cBox.maximum.x > 1e-6) {\r\n            return false;\r\n        }\r\n\r\n        if (cBox.minimum.y - this.maximum.y > 1e-6 || this.minimum.y - cBox.maximum.y > 1e-6) {\r\n            return false;\r\n        }\r\n\r\n        if (cBox.minimum.z - this.maximum.z > 1e-6 || this.minimum.z - cBox.maximum.z > 1e-6) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n\t}\r\n\r\n    /**\r\n     *\r\n     * @param {Cartesian3} center\r\n     * @param {Number} radius\r\n     * @returns {AxisAlignedBoundingBox}\r\n     */\r\n    AxisAlignedBoundingBox.fromBoundingSphere = function(center, radius){\r\n        let minimum = new Cartesian3(center.x - radius, center.y - radius, center.z - radius);\r\n        let maximum = new Cartesian3(center.x + radius, center.y + radius, center.z + radius);\r\n        return new AxisAlignedBoundingBox(minimum, maximum);\r\n    }\r\nexport default AxisAlignedBoundingBox;\r\n"],"names":["Cartesian3","defaultValue","defined","Check","Intersect","Matrix4"],"mappings":"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"}