define(["./when-45f3d25d","./Check-34538dad","./Cartesian3-ef6ea826","./Cartesian2-a652b463","./BoundingSphere-038d5fbc","./Transforms-c8a82813","./Matrix4-f54b529f","./RuntimeError-86da6af2","./WebGLConstants-3660bc8f","./ComponentDatatype-d28c2e26","./GeometryAttribute-dfebcc43","./PrimitiveType-30fa6f85","./GeometryAttributes-9d45f9e2","./AttributeCompression-20de7c5b","./GeometryPipeline-f4ca2db7","./EncodedCartesian3-f0b88724","./IndexDatatype-6d2070e9","./IntersectionTests-b186d985","./Plane-a0c58786","./VertexFormat-06aa4e32","./arrayRemoveDuplicates-e5b24eaf","./BoundingRectangle-13917389","./AxisAlignedBoundingBox-9187558e","./EllipsoidTangentPlane-dd3d1016","./EllipsoidRhumbLine-0c6cd7c8","./PolygonPipeline-28c8c9d7","./PolylineVolumeGeometryLibrary-78e26dc0","./EllipsoidGeodesic-1abfd38d","./PolylinePipeline-e4210f09"],(function(e,t,n,i,r,a,o,l,s,d,p,c,u,g,y,m,h,f,v,b,E,P,x,_,k,C,V,L,w){"use strict";var F={};function T(t,n){e.defined(F[t])||(F[t]=!0,console.warn(e.defaultValue(n,t)))}function A(t){var r=(t=e.defaultValue(t,e.defaultValue.EMPTY_OBJECT)).polylinePositions,a=t.shapePositions;this._positions=r,this._shape=a,this._ellipsoid=i.Ellipsoid.clone(e.defaultValue(t.ellipsoid,i.Ellipsoid.WGS84)),this._cornerType=e.defaultValue(t.cornerType,V.CornerType.ROUNDED),this._vertexFormat=b.VertexFormat.clone(e.defaultValue(t.vertexFormat,b.VertexFormat.DEFAULT)),this._granularity=e.defaultValue(t.granularity,n.CesiumMath.RADIANS_PER_DEGREE),this._workerName="createPolylineVolumeGeometry";var o=1+r.length*n.Cartesian3.packedLength;o+=1+a.length*i.Cartesian2.packedLength,this.packedLength=o+i.Ellipsoid.packedLength+b.VertexFormat.packedLength+2}T.geometryOutlines="Entity geometry outlines are unsupported on terrain. Outlines will be disabled. To enable outlines, disable geometry terrain clamping by explicitly setting height to 0.",T.geometryZIndex="Entity geometry with zIndex are unsupported when height or extrudedHeight are defined.  zIndex will be ignored",T.geometryHeightReference="Entity corridor, ellipse, polygon or rectangle with heightReference must also have a defined height.  heightReference will be ignored",T.geometryExtrudedHeightReference="Entity corridor, ellipse, polygon or rectangle with extrudedHeightReference must also have a defined extrudedHeight.  extrudedHeightReference will be ignored",A.pack=function(t,r,a){var o;a=e.defaultValue(a,0);var l=t._positions,s=l.length;for(r[a++]=s,o=0;o<s;++o,a+=n.Cartesian3.packedLength)n.Cartesian3.pack(l[o],r,a);var d=t._shape;for(s=d.length,r[a++]=s,o=0;o<s;++o,a+=i.Cartesian2.packedLength)i.Cartesian2.pack(d[o],r,a);return i.Ellipsoid.pack(t._ellipsoid,r,a),a+=i.Ellipsoid.packedLength,b.VertexFormat.pack(t._vertexFormat,r,a),a+=b.VertexFormat.packedLength,r[a++]=t._cornerType,r[a]=t._granularity,r};var G=i.Ellipsoid.clone(i.Ellipsoid.UNIT_SPHERE),R=new b.VertexFormat,D={polylinePositions:void 0,shapePositions:void 0,ellipsoid:G,vertexFormat:R,cornerType:void 0,granularity:void 0};A.unpack=function(t,r,a){var o;r=e.defaultValue(r,0);var l=t[r++],s=new Array(l);for(o=0;o<l;++o,r+=n.Cartesian3.packedLength)s[o]=n.Cartesian3.unpack(t,r);l=t[r++];var d=new Array(l);for(o=0;o<l;++o,r+=i.Cartesian2.packedLength)d[o]=i.Cartesian2.unpack(t,r);var p=i.Ellipsoid.unpack(t,r,G);r+=i.Ellipsoid.packedLength;var c=b.VertexFormat.unpack(t,r,R);r+=b.VertexFormat.packedLength;var u=t[r++],g=t[r];return e.defined(a)?(a._positions=s,a._shape=d,a._ellipsoid=i.Ellipsoid.clone(p,a._ellipsoid),a._vertexFormat=b.VertexFormat.clone(c,a._vertexFormat),a._cornerType=u,a._granularity=g,a):(D.polylinePositions=s,D.shapePositions=d,D.cornerType=u,D.granularity=g,new A(D))};var B=new P.BoundingRectangle;return A.createGeometry=function(e){var t=e._positions,i=E.arrayRemoveDuplicates(t,n.Cartesian3.equalsEpsilon),a=e._shape;if(a=V.PolylineVolumeGeometryLibrary.removeDuplicatesFromShape(a),!(i.length<2||a.length<3)){C.PolygonPipeline.computeWindingOrder2D(a)===C.WindingOrder.CLOCKWISE&&a.reverse();var o=P.BoundingRectangle.fromPoints(a,B);return function(e,t,n,i){var a=new u.GeometryAttributes;i.position&&(a.position=new p.GeometryAttribute({componentDatatype:d.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:e}));var o,l,s,g,m,f,v=t.length,b=e.length/3,E=(b-2*v)/(2*v),P=C.PolygonPipeline.triangulate(t),x=(E-1)*v*6+2*P.length,_=h.IndexDatatype.createTypedArray(b,x),k=2*v,V=0;for(o=0;o<E-1;o++){for(l=0;l<v-1;l++)f=(s=2*l+o*v*2)+k,m=(g=s+1)+k,_[V++]=g,_[V++]=s,_[V++]=m,_[V++]=m,_[V++]=s,_[V++]=f;m=(g=1+(s=2*v-2+o*v*2))+k,f=s+k,_[V++]=g,_[V++]=s,_[V++]=m,_[V++]=m,_[V++]=s,_[V++]=f}if(i.st||i.tangent||i.bitangent){var L,w,F=new Float32Array(2*b),A=1/(E-1),G=1/n.height,R=n.height/2,D=0;for(o=0;o<E;o++){for(L=o*A,w=G*(t[0].y+R),F[D++]=L,F[D++]=w,l=1;l<v;l++)w=G*(t[l].y+R),F[D++]=L,F[D++]=w,F[D++]=L,F[D++]=w;w=G*(t[0].y+R),F[D++]=L,F[D++]=w}for(l=0;l<v;l++)L=0,w=G*(t[l].y+R),F[D++]=L,F[D++]=w;for(l=0;l<v;l++)L=(E-1)*A,w=G*(t[l].y+R),F[D++]=L,F[D++]=w;a.st=new p.GeometryAttribute({componentDatatype:d.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:new Float32Array(F)})}var B=b-2*v;for(o=0;o<P.length;o+=3){var I=P[o]+B,O=P[o+1]+B,S=P[o+2]+B;_[V++]=I,_[V++]=O,_[V++]=S,_[V++]=S+v,_[V++]=O+v,_[V++]=I+v}var H=new p.Geometry({attributes:a,indices:_,boundingSphere:r.BoundingSphere.fromVertices(e),primitiveType:c.PrimitiveType.TRIANGLES});if(i.normal&&(H=y.GeometryPipeline.computeNormal(H)),i.tangent||i.bitangent){try{H=y.GeometryPipeline.computeTangentAndBitangent(H)}catch(e){T("polyline-volume-tangent-bitangent","Unable to compute tangents and bitangents for polyline volume geometry")}i.tangent||(H.attributes.tangent=void 0),i.bitangent||(H.attributes.bitangent=void 0),i.st||(H.attributes.st=void 0)}return H}(V.PolylineVolumeGeometryLibrary.computePositions(i,a,o,e,!0),a,o,e._vertexFormat)}},function(t,n){return e.defined(n)&&(t=A.unpack(t,n)),t._ellipsoid=i.Ellipsoid.clone(t._ellipsoid),A.createGeometry(t)}}));