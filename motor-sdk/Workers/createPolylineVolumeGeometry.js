define(["./when-45f3d25d","./Check-34538dad","./Cartesian3-e69091b9","./Cartesian2-7a44370a","./BoundingSphere-bacc5cb6","./Matrix4-c65e6a1b","./RuntimeError-86da6af2","./Rectangle-c7d55cfa","./WebGLConstants-3660bc8f","./ComponentDatatype-86703c58","./GeometryAttribute-70b679fd","./PrimitiveType-30fa6f85","./Transforms-7d49a8ab","./GeometryAttributes-9d45f9e2","./AttributeCompression-1e177d5e","./GeometryPipeline-7ef9305b","./EncodedCartesian3-7b803d4a","./IndexDatatype-e52361bd","./IntersectionTests-6b77277e","./Plane-b4c954eb","./VertexFormat-a00562ee","./arrayRemoveDuplicates-24a803e7","./BoundingRectangle-c7afec11","./EllipsoidTangentPlane-c567cc9c","./EllipsoidRhumbLine-4bc7760a","./PolygonPipeline-ac4549dc","./PolylineVolumeGeometryLibrary-7cf92acf","./EllipsoidGeodesic-1d7258d7","./PolylinePipeline-5cca45a5"],(function(e,t,r,i,n,o,a,l,s,d,p,c,u,g,y,h,m,f,v,b,E,w,P,_,x,k,C,V,D){"use strict";var L={};function F(r,i){if(!e.defined(r))throw new t.DeveloperError("identifier is required.");e.defined(L[r])||(L[r]=!0,console.warn(e.defaultValue(i,r)))}function T(e,t,r,i){var o=new g.GeometryAttributes;i.position&&(o.position=new p.GeometryAttribute({componentDatatype:d.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:e}));var a,l,s,u,y,m,v=t.length,b=e.length/3,E=(b-2*v)/(2*v),w=k.PolygonPipeline.triangulate(t),P=(E-1)*v*6+2*w.length,_=f.IndexDatatype.createTypedArray(b,P),x=2*v,C=0;for(a=0;a<E-1;a++){for(l=0;l<v-1;l++)s=2*l+a*v*2,m=s+x,u=s+1,y=u+x,_[C++]=u,_[C++]=s,_[C++]=y,_[C++]=y,_[C++]=s,_[C++]=m;s=2*v-2+a*v*2,u=s+1,y=u+x,m=s+x,_[C++]=u,_[C++]=s,_[C++]=y,_[C++]=y,_[C++]=s,_[C++]=m}if(i.st||i.tangent||i.bitangent){var V,D,L=new Float32Array(2*b),T=1/(E-1),G=1/r.height,R=r.height/2,A=0;for(a=0;a<E;a++){for(V=a*T,D=G*(t[0].y+R),L[A++]=V,L[A++]=D,l=1;l<v;l++)D=G*(t[l].y+R),L[A++]=V,L[A++]=D,L[A++]=V,L[A++]=D;D=G*(t[0].y+R),L[A++]=V,L[A++]=D}for(l=0;l<v;l++)V=0,D=G*(t[l].y+R),L[A++]=V,L[A++]=D;for(l=0;l<v;l++)V=(E-1)*T,D=G*(t[l].y+R),L[A++]=V,L[A++]=D;o.st=new p.GeometryAttribute({componentDatatype:d.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:new Float32Array(L)})}var I=b-2*v;for(a=0;a<w.length;a+=3){var O=w[a]+I,S=w[a+1]+I,B=w[a+2]+I;_[C++]=O,_[C++]=S,_[C++]=B,_[C++]=B+v,_[C++]=S+v,_[C++]=O+v}var q=new p.Geometry({attributes:o,indices:_,boundingSphere:n.BoundingSphere.fromVertices(e),primitiveType:c.PrimitiveType.TRIANGLES});if(i.normal&&(q=h.GeometryPipeline.computeNormal(q)),i.tangent||i.bitangent){try{q=h.GeometryPipeline.computeTangentAndBitangent(q)}catch(H){F("polyline-volume-tangent-bitangent","Unable to compute tangents and bitangents for polyline volume geometry")}i.tangent||(q.attributes.tangent=void 0),i.bitangent||(q.attributes.bitangent=void 0),i.st||(q.attributes.st=void 0)}return q}function G(n){n=e.defaultValue(n,e.defaultValue.EMPTY_OBJECT);var o=n.polylinePositions,a=n.shapePositions;if(!e.defined(o))throw new t.DeveloperError("options.polylinePositions is required.");if(!e.defined(a))throw new t.DeveloperError("options.shapePositions is required.");this._positions=o,this._shape=a,this._ellipsoid=i.Ellipsoid.clone(e.defaultValue(n.ellipsoid,i.Ellipsoid.WGS84)),this._cornerType=e.defaultValue(n.cornerType,C.CornerType.ROUNDED),this._vertexFormat=E.VertexFormat.clone(e.defaultValue(n.vertexFormat,E.VertexFormat.DEFAULT)),this._granularity=e.defaultValue(n.granularity,r.CesiumMath.RADIANS_PER_DEGREE),this._workerName="createPolylineVolumeGeometry";var l=1+o.length*r.Cartesian3.packedLength;l+=1+a.length*i.Cartesian2.packedLength,this.packedLength=l+i.Ellipsoid.packedLength+E.VertexFormat.packedLength+2}F.geometryOutlines="Entity geometry outlines are unsupported on terrain. Outlines will be disabled. To enable outlines, disable geometry terrain clamping by explicitly setting height to 0.",F.geometryZIndex="Entity geometry with zIndex are unsupported when height or extrudedHeight are defined.  zIndex will be ignored",F.geometryHeightReference="Entity corridor, ellipse, polygon or rectangle with heightReference must also have a defined height.  heightReference will be ignored",F.geometryExtrudedHeightReference="Entity corridor, ellipse, polygon or rectangle with extrudedHeightReference must also have a defined extrudedHeight.  extrudedHeightReference will be ignored",G.pack=function(n,o,a){if(!e.defined(n))throw new t.DeveloperError("value is required");if(!e.defined(o))throw new t.DeveloperError("array is required");var l;a=e.defaultValue(a,0);var s=n._positions,d=s.length;for(o[a++]=d,l=0;l<d;++l,a+=r.Cartesian3.packedLength)r.Cartesian3.pack(s[l],o,a);var p=n._shape;for(d=p.length,o[a++]=d,l=0;l<d;++l,a+=i.Cartesian2.packedLength)i.Cartesian2.pack(p[l],o,a);return i.Ellipsoid.pack(n._ellipsoid,o,a),a+=i.Ellipsoid.packedLength,E.VertexFormat.pack(n._vertexFormat,o,a),a+=E.VertexFormat.packedLength,o[a++]=n._cornerType,o[a]=n._granularity,o};var R=i.Ellipsoid.clone(i.Ellipsoid.UNIT_SPHERE),A=new E.VertexFormat,I={polylinePositions:void 0,shapePositions:void 0,ellipsoid:R,vertexFormat:A,cornerType:void 0,granularity:void 0};G.unpack=function(n,o,a){if(!e.defined(n))throw new t.DeveloperError("array is required");var l;o=e.defaultValue(o,0);var s=n[o++],d=new Array(s);for(l=0;l<s;++l,o+=r.Cartesian3.packedLength)d[l]=r.Cartesian3.unpack(n,o);s=n[o++];var p=new Array(s);for(l=0;l<s;++l,o+=i.Cartesian2.packedLength)p[l]=i.Cartesian2.unpack(n,o);var c=i.Ellipsoid.unpack(n,o,R);o+=i.Ellipsoid.packedLength;var u=E.VertexFormat.unpack(n,o,A);o+=E.VertexFormat.packedLength;var g=n[o++],y=n[o];return e.defined(a)?(a._positions=d,a._shape=p,a._ellipsoid=i.Ellipsoid.clone(c,a._ellipsoid),a._vertexFormat=E.VertexFormat.clone(u,a._vertexFormat),a._cornerType=g,a._granularity=y,a):(I.polylinePositions=d,I.shapePositions=p,I.cornerType=g,I.granularity=y,new G(I))};var O=new P.BoundingRectangle;function S(t,r){return e.defined(r)&&(t=G.unpack(t,r)),t._ellipsoid=i.Ellipsoid.clone(t._ellipsoid),G.createGeometry(t)}return G.createGeometry=function(e){var t=e._positions,i=w.arrayRemoveDuplicates(t,r.Cartesian3.equalsEpsilon),n=e._shape;if(n=C.PolylineVolumeGeometryLibrary.removeDuplicatesFromShape(n),!(i.length<2||n.length<3)){k.PolygonPipeline.computeWindingOrder2D(n)===k.WindingOrder.CLOCKWISE&&n.reverse();var o=P.BoundingRectangle.fromPoints(n,O),a=C.PolylineVolumeGeometryLibrary.computePositions(i,n,o,e,!0);return T(a,n,o,e._vertexFormat)}},S}));