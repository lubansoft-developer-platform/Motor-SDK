define(["exports","./when-52cea266","./Check-abb9b75f","./Cartesian2-7312ebeb","./BoundingSphere-ff324c2c","./ComponentDatatype-0d64f16b","./GeometryAttribute-55231797","./PrimitiveType-875d1f73","./GeometryAttributes-769ca2c2","./IndexDatatype-d59649f4","./GeometryOffsetAttribute-a996b2bf","./VertexFormat-b433634a","./CylinderGeometryLibrary-1f7885c4"],(function(e,t,r,a,o,n,i,s,u,f,m,d,p){"use strict";var l=new a.Cartesian2,y=new a.Cartesian3,b=new a.Cartesian3,c=new a.Cartesian3,v=new a.Cartesian3;function A(e){e=t.defaultValue(e,t.defaultValue.EMPTY_OBJECT);var a=e.length,o=e.topRadius,n=e.bottomRadius,i=t.defaultValue(e.vertexFormat,d.VertexFormat.DEFAULT),s=t.defaultValue(e.slices,128);if(!t.defined(a))throw new r.DeveloperError("options.length must be defined.");if(!t.defined(o))throw new r.DeveloperError("options.topRadius must be defined.");if(!t.defined(n))throw new r.DeveloperError("options.bottomRadius must be defined.");if(s<3)throw new r.DeveloperError("options.slices must be greater than or equal to 3.");if(t.defined(e.offsetAttribute)&&e.offsetAttribute===m.GeometryOffsetAttribute.TOP)throw new r.DeveloperError("GeometryOffsetAttribute.TOP is not a supported options.offsetAttribute for this geometry.");this._length=a,this._topRadius=o,this._bottomRadius=n,this._vertexFormat=d.VertexFormat.clone(i),this._slices=s,this._offsetAttribute=e.offsetAttribute,this._workerName="createCylinderGeometry"}A.packedLength=d.VertexFormat.packedLength+5,A.pack=function(e,a,o){if(!t.defined(e))throw new r.DeveloperError("value is required");if(!t.defined(a))throw new r.DeveloperError("array is required");return o=t.defaultValue(o,0),d.VertexFormat.pack(e._vertexFormat,a,o),o+=d.VertexFormat.packedLength,a[o++]=e._length,a[o++]=e._topRadius,a[o++]=e._bottomRadius,a[o++]=e._slices,a[o]=t.defaultValue(e._offsetAttribute,-1),a};var h,w=new d.VertexFormat,g={vertexFormat:w,length:void 0,topRadius:void 0,bottomRadius:void 0,slices:void 0,offsetAttribute:void 0};A.unpack=function(e,a,o){if(!t.defined(e))throw new r.DeveloperError("array is required");a=t.defaultValue(a,0);var n=d.VertexFormat.unpack(e,a,w);a+=d.VertexFormat.packedLength;var i=e[a++],s=e[a++],u=e[a++],f=e[a++],m=e[a];return t.defined(o)?(o._vertexFormat=d.VertexFormat.clone(n,o._vertexFormat),o._length=i,o._topRadius=s,o._bottomRadius=u,o._slices=f,o._offsetAttribute=-1===m?void 0:m,o):(g.length=i,g.topRadius=s,g.bottomRadius=u,g.slices=f,g.offsetAttribute=-1===m?void 0:m,new A(g))},A.createGeometry=function(e){var r=e._length,d=e._topRadius,A=e._bottomRadius,h=e._vertexFormat,w=e._slices;if(!(r<=0||d<0||A<0||0===d&&0===A)){var g,x=w+w,_=w+x,C=x+x,F=p.CylinderGeometryLibrary.computePositions(r,d,A,w,!0),D=h.st?new Float32Array(2*C):void 0,G=h.normal?new Float32Array(3*C):void 0,R=h.tangent?new Float32Array(3*C):void 0,O=h.bitangent?new Float32Array(3*C):void 0,T=h.normal||h.tangent||h.bitangent;if(T){var V=h.tangent||h.bitangent,E=0,L=0,P=0,k=Math.atan2(A-d,r),z=y;z.z=Math.sin(k);var M=Math.cos(k),N=c,I=b;for(g=0;g<w;g++){var S=g/w*a.CesiumMath.TWO_PI,U=M*Math.cos(S),B=M*Math.sin(S);T&&(z.x=U,z.y=B,V&&(N=a.Cartesian3.normalize(a.Cartesian3.cross(a.Cartesian3.UNIT_Z,z,N),N)),h.normal&&(G[E++]=z.x,G[E++]=z.y,G[E++]=z.z,G[E++]=z.x,G[E++]=z.y,G[E++]=z.z),h.tangent&&(R[L++]=N.x,R[L++]=N.y,R[L++]=N.z,R[L++]=N.x,R[L++]=N.y,R[L++]=N.z),h.bitangent&&(I=a.Cartesian3.normalize(a.Cartesian3.cross(z,N,I),I),O[P++]=I.x,O[P++]=I.y,O[P++]=I.z,O[P++]=I.x,O[P++]=I.y,O[P++]=I.z))}for(g=0;g<w;g++)h.normal&&(G[E++]=0,G[E++]=0,G[E++]=-1),h.tangent&&(R[L++]=1,R[L++]=0,R[L++]=0),h.bitangent&&(O[P++]=0,O[P++]=-1,O[P++]=0);for(g=0;g<w;g++)h.normal&&(G[E++]=0,G[E++]=0,G[E++]=1),h.tangent&&(R[L++]=1,R[L++]=0,R[L++]=0),h.bitangent&&(O[P++]=0,O[P++]=1,O[P++]=0)}var q=12*w-12,Y=f.IndexDatatype.createTypedArray(C,q),Z=0,J=0;for(g=0;g<w-1;g++)Y[Z++]=J,Y[Z++]=J+2,Y[Z++]=J+3,Y[Z++]=J,Y[Z++]=J+3,Y[Z++]=J+1,J+=2;for(Y[Z++]=x-2,Y[Z++]=0,Y[Z++]=1,Y[Z++]=x-2,Y[Z++]=1,Y[Z++]=x-1,g=1;g<w-1;g++)Y[Z++]=x+g+1,Y[Z++]=x+g,Y[Z++]=x;for(g=1;g<w-1;g++)Y[Z++]=_,Y[Z++]=_+g,Y[Z++]=_+g+1;var W=0;if(h.st){var j=Math.max(d,A);for(g=0;g<C;g++){var H=a.Cartesian3.fromArray(F,3*g,v);D[W++]=(H.x+j)/(2*j),D[W++]=(H.y+j)/(2*j)}}var K=new u.GeometryAttributes;h.position&&(K.position=new i.GeometryAttribute({componentDatatype:n.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:F})),h.normal&&(K.normal=new i.GeometryAttribute({componentDatatype:n.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:G})),h.tangent&&(K.tangent=new i.GeometryAttribute({componentDatatype:n.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:R})),h.bitangent&&(K.bitangent=new i.GeometryAttribute({componentDatatype:n.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:O})),h.st&&(K.st=new i.GeometryAttribute({componentDatatype:n.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:D})),l.x=.5*r,l.y=Math.max(A,d);var Q=new o.BoundingSphere(a.Cartesian3.ZERO,a.Cartesian2.magnitude(l));if(t.defined(e._offsetAttribute)){r=F.length;var X=new Uint8Array(r/3),$=e._offsetAttribute===m.GeometryOffsetAttribute.NONE?0:1;m.arrayFill(X,$),K.applyOffset=new i.GeometryAttribute({componentDatatype:n.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:X})}return new i.Geometry({attributes:K,indices:Y,primitiveType:s.PrimitiveType.TRIANGLES,boundingSphere:Q,offsetAttribute:e._offsetAttribute})}},A.getUnitCylinder=function(){return t.defined(h)||(h=A.createGeometry(new A({topRadius:1,bottomRadius:1,length:1,vertexFormat:d.VertexFormat.POSITION_ONLY}))),h},e.CylinderGeometry=A}));