{"version":3,"file":"BoundingSphere-f8921934.js","sources":["../../../../Source/Core/GeographicProjection.js","../../../../Source/Core/Interval.js","../../../../Source/Core/BoundingSphere.js"],"sourcesContent":["import Cartesian3 from './Cartesian3.js';\nimport Cartographic from './Cartographic.js';\nimport defaultValue from './defaultValue.js';\nimport defined from './defined.js';\nimport DeveloperError from './DeveloperError.js';\nimport Ellipsoid from './Ellipsoid.js';\n\n    /**\n     * A simple map projection where longitude and latitude are linearly mapped to X and Y by multiplying\n     * them by the {@link Ellipsoid#maximumRadius}.  This projection\n     * is commonly known as geographic, equirectangular, equidistant cylindrical, or plate carrÃ©e.  It\n     * is also known as EPSG:4326.\n     *\n     * @alias GeographicProjection\n     * @constructor\n     *\n     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid.\n     *\n     * @see WebMercatorProjection\n     */\n    function GeographicProjection(ellipsoid) {\n        this._ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n        this._semimajorAxis = this._ellipsoid.maximumRadius;\n        this._oneOverSemimajorAxis = 1.0 / this._semimajorAxis;\n    }\n\n    Object.defineProperties(GeographicProjection.prototype, {\n        /**\n         * Gets the {@link Ellipsoid}.\n         *\n         * @memberof GeographicProjection.prototype\n         *\n         * @type {Ellipsoid}\n         * @readonly\n         */\n        ellipsoid : {\n            get : function() {\n                return this._ellipsoid;\n            }\n        }\n    });\n\n    /**\n     * Projects a set of {@link Cartographic} coordinates, in radians, to map coordinates, in meters.\n     * X and Y are the longitude and latitude, respectively, multiplied by the maximum radius of the\n     * ellipsoid.  Z is the unmodified height.\n     *\n     * @param {Cartographic} cartographic The coordinates to project.\n     * @param {Cartesian3} [result] An instance into which to copy the result.  If this parameter is\n     *        undefined, a new instance is created and returned.\n     * @returns {Cartesian3} The projected coordinates.  If the result parameter is not undefined, the\n     *          coordinates are copied there and that instance is returned.  Otherwise, a new instance is\n     *          created and returned.\n     */\n    GeographicProjection.prototype.project = function(cartographic, result) {\n        // Actually this is the special case of equidistant cylindrical called the plate carree\n        var semimajorAxis = this._semimajorAxis;\n        var x = cartographic.longitude * semimajorAxis;\n        var y = cartographic.latitude * semimajorAxis;\n        var z = cartographic.height;\n\n        if (!defined(result)) {\n            return new Cartesian3(x, y, z);\n        }\n\n        result.x = x;\n        result.y = y;\n        result.z = z;\n        return result;\n    };\n\n    /**\n     * Unprojects a set of projected {@link Cartesian3} coordinates, in meters, to {@link Cartographic}\n     * coordinates, in radians.  Longitude and Latitude are the X and Y coordinates, respectively,\n     * divided by the maximum radius of the ellipsoid.  Height is the unmodified Z coordinate.\n     *\n     * @param {Cartesian3} cartesian The Cartesian position to unproject with height (z) in meters.\n     * @param {Cartographic} [result] An instance into which to copy the result.  If this parameter is\n     *        undefined, a new instance is created and returned.\n     * @returns {Cartographic} The unprojected coordinates.  If the result parameter is not undefined, the\n     *          coordinates are copied there and that instance is returned.  Otherwise, a new instance is\n     *          created and returned.\n     */\n    GeographicProjection.prototype.unproject = function(cartesian, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(cartesian)) {\n            throw new DeveloperError('cartesian is required');\n        }\n        //>>includeEnd('debug');\n\n        var oneOverEarthSemimajorAxis = this._oneOverSemimajorAxis;\n        var longitude = cartesian.x * oneOverEarthSemimajorAxis;\n        var latitude = cartesian.y * oneOverEarthSemimajorAxis;\n        var height = cartesian.z;\n\n        if (!defined(result)) {\n            return new Cartographic(longitude, latitude, height);\n        }\n\n        result.longitude = longitude;\n        result.latitude = latitude;\n        result.height = height;\n        return result;\n    };\nexport default GeographicProjection;\n","import defaultValue from './defaultValue.js';\n\n    /**\n     * Represents the closed interval [start, stop].\n     * @alias Interval\n     * @constructor\n     *\n     * @param {Number} [start=0.0] The beginning of the interval.\n     * @param {Number} [stop=0.0] The end of the interval.\n     */\n    function Interval(start, stop) {\n        /**\n         * The beginning of the interval.\n         * @type {Number}\n         * @default 0.0\n         */\n        this.start = defaultValue(start, 0.0);\n        /**\n         * The end of the interval.\n         * @type {Number}\n         * @default 0.0\n         */\n        this.stop = defaultValue(stop, 0.0);\n    }\nexport default Interval;\n","import Cartesian3 from './Cartesian3.js';\nimport Cartographic from './Cartographic.js';\nimport Check from './Check.js';\nimport defaultValue from './defaultValue.js';\nimport defined from './defined.js';\nimport Ellipsoid from './Ellipsoid.js';\nimport GeographicProjection from './GeographicProjection.js';\nimport Intersect from './Intersect.js';\nimport Interval from './Interval.js';\nimport CesiumMath from './Math.js';\nimport Matrix3 from './Matrix3.js';\nimport Matrix4 from './Matrix4.js';\nimport Rectangle from './Rectangle.js';\n\n    /**\n     * A bounding sphere with a center and a radius.\n     * @alias BoundingSphere\n     * @constructor\n     *\n     * @param {Cartesian3} [center=Cartesian3.ZERO] The center of the bounding sphere.\n     * @param {Number} [radius=0.0] The radius of the bounding sphere.\n     *\n     * @see AxisAlignedBoundingBox\n     * @see BoundingRectangle\n     * @see Packable\n     */\n    function BoundingSphere(center, radius) {\n        /**\n         * The center point of the sphere.\n         * @type {Cartesian3}\n         * @default {@link Cartesian3.ZERO}\n         */\n        this.center = Cartesian3.clone(defaultValue(center, Cartesian3.ZERO));\n\n        /**\n         * The radius of the sphere.\n         * @type {Number}\n         * @default 0.0\n         */\n        this.radius = defaultValue(radius, 0.0);\n    }\n\n    var fromPointsXMin = new Cartesian3();\n    var fromPointsYMin = new Cartesian3();\n    var fromPointsZMin = new Cartesian3();\n    var fromPointsXMax = new Cartesian3();\n    var fromPointsYMax = new Cartesian3();\n    var fromPointsZMax = new Cartesian3();\n    var fromPointsCurrentPos = new Cartesian3();\n    var fromPointsScratch = new Cartesian3();\n    var fromPointsRitterCenter = new Cartesian3();\n    var fromPointsMinBoxPt = new Cartesian3();\n    var fromPointsMaxBoxPt = new Cartesian3();\n    var fromPointsNaiveCenterScratch = new Cartesian3();\n    var volumeConstant = (4.0 / 3.0) * CesiumMath.PI;\n\n    /**\n     * Computes a tight-fitting bounding sphere enclosing a list of 3D Cartesian points.\n     * The bounding sphere is computed by running two algorithms, a naive algorithm and\n     * Ritter's algorithm. The smaller of the two spheres is used to ensure a tight fit.\n     *\n     * @param {Cartesian3[]} [positions] An array of points that the bounding sphere will enclose.  Each point must have <code>x</code>, <code>y</code>, and <code>z</code> properties.\n     * @param {BoundingSphere} [result] The object onto which to store the result.\n     * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if one was not provided.\n     *\n     * @see {@link http://help.agi.com/AGIComponents/html/BlogBoundingSphere.htm|Bounding Sphere computation article}\n     */\n    BoundingSphere.fromPoints = function(positions, result) {\n        if (!defined(result)) {\n            result = new BoundingSphere();\n        }\n\n        if (!defined(positions) || positions.length === 0) {\n            result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);\n            result.radius = 0.0;\n            return result;\n        }\n\n        var currentPos = Cartesian3.clone(positions[0], fromPointsCurrentPos);\n\n        var xMin = Cartesian3.clone(currentPos, fromPointsXMin);\n        var yMin = Cartesian3.clone(currentPos, fromPointsYMin);\n        var zMin = Cartesian3.clone(currentPos, fromPointsZMin);\n\n        var xMax = Cartesian3.clone(currentPos, fromPointsXMax);\n        var yMax = Cartesian3.clone(currentPos, fromPointsYMax);\n        var zMax = Cartesian3.clone(currentPos, fromPointsZMax);\n\n        var numPositions = positions.length;\n        var i;\n        for (i = 1; i < numPositions; i++) {\n            Cartesian3.clone(positions[i], currentPos);\n\n            var x = currentPos.x;\n            var y = currentPos.y;\n            var z = currentPos.z;\n\n            // Store points containing the the smallest and largest components\n            if (x < xMin.x) {\n                Cartesian3.clone(currentPos, xMin);\n            }\n\n            if (x > xMax.x) {\n                Cartesian3.clone(currentPos, xMax);\n            }\n\n            if (y < yMin.y) {\n                Cartesian3.clone(currentPos, yMin);\n            }\n\n            if (y > yMax.y) {\n                Cartesian3.clone(currentPos, yMax);\n            }\n\n            if (z < zMin.z) {\n                Cartesian3.clone(currentPos, zMin);\n            }\n\n            if (z > zMax.z) {\n                Cartesian3.clone(currentPos, zMax);\n            }\n        }\n\n        // Compute x-, y-, and z-spans (Squared distances b/n each component's min. and max.).\n        var xSpan = Cartesian3.magnitudeSquared(Cartesian3.subtract(xMax, xMin, fromPointsScratch));\n        var ySpan = Cartesian3.magnitudeSquared(Cartesian3.subtract(yMax, yMin, fromPointsScratch));\n        var zSpan = Cartesian3.magnitudeSquared(Cartesian3.subtract(zMax, zMin, fromPointsScratch));\n\n        // Set the diameter endpoints to the largest span.\n        var diameter1 = xMin;\n        var diameter2 = xMax;\n        var maxSpan = xSpan;\n        if (ySpan > maxSpan) {\n            maxSpan = ySpan;\n            diameter1 = yMin;\n            diameter2 = yMax;\n        }\n        if (zSpan > maxSpan) {\n            maxSpan = zSpan;\n            diameter1 = zMin;\n            diameter2 = zMax;\n        }\n\n        // Calculate the center of the initial sphere found by Ritter's algorithm\n        var ritterCenter = fromPointsRitterCenter;\n        ritterCenter.x = (diameter1.x + diameter2.x) * 0.5;\n        ritterCenter.y = (diameter1.y + diameter2.y) * 0.5;\n        ritterCenter.z = (diameter1.z + diameter2.z) * 0.5;\n\n        // Calculate the radius of the initial sphere found by Ritter's algorithm\n        var radiusSquared = Cartesian3.magnitudeSquared(Cartesian3.subtract(diameter2, ritterCenter, fromPointsScratch));\n        var ritterRadius = Math.sqrt(radiusSquared);\n\n        // Find the center of the sphere found using the Naive method.\n        var minBoxPt = fromPointsMinBoxPt;\n        minBoxPt.x = xMin.x;\n        minBoxPt.y = yMin.y;\n        minBoxPt.z = zMin.z;\n\n        var maxBoxPt = fromPointsMaxBoxPt;\n        maxBoxPt.x = xMax.x;\n        maxBoxPt.y = yMax.y;\n        maxBoxPt.z = zMax.z;\n\n        var naiveCenter = Cartesian3.midpoint(minBoxPt, maxBoxPt, fromPointsNaiveCenterScratch);\n\n        // Begin 2nd pass to find naive radius and modify the ritter sphere.\n        var naiveRadius = 0;\n        for (i = 0; i < numPositions; i++) {\n            Cartesian3.clone(positions[i], currentPos);\n\n            // Find the furthest point from the naive center to calculate the naive radius.\n            var r = Cartesian3.magnitude(Cartesian3.subtract(currentPos, naiveCenter, fromPointsScratch));\n            if (r > naiveRadius) {\n                naiveRadius = r;\n            }\n\n            // Make adjustments to the Ritter Sphere to include all points.\n            var oldCenterToPointSquared = Cartesian3.magnitudeSquared(Cartesian3.subtract(currentPos, ritterCenter, fromPointsScratch));\n            if (oldCenterToPointSquared > radiusSquared) {\n                var oldCenterToPoint = Math.sqrt(oldCenterToPointSquared);\n                // Calculate new radius to include the point that lies outside\n                ritterRadius = (ritterRadius + oldCenterToPoint) * 0.5;\n                radiusSquared = ritterRadius * ritterRadius;\n                // Calculate center of new Ritter sphere\n                var oldToNew = oldCenterToPoint - ritterRadius;\n                ritterCenter.x = (ritterRadius * ritterCenter.x + oldToNew * currentPos.x) / oldCenterToPoint;\n                ritterCenter.y = (ritterRadius * ritterCenter.y + oldToNew * currentPos.y) / oldCenterToPoint;\n                ritterCenter.z = (ritterRadius * ritterCenter.z + oldToNew * currentPos.z) / oldCenterToPoint;\n            }\n        }\n\n        if (ritterRadius < naiveRadius) {\n            Cartesian3.clone(ritterCenter, result.center);\n            result.radius = ritterRadius;\n        } else {\n            Cartesian3.clone(naiveCenter, result.center);\n            result.radius = naiveRadius;\n        }\n\n        return result;\n    };\n\n    BoundingSphere.fromInstancePoints = function(positions, result, numPositions) {\n    if (!defined(result)) {\n        result = new BoundingSphere();\n    }\n\n    if (!defined(positions) || numPositions === 0) {\n        result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);\n        result.radius = 0.0;\n        return result;\n    }\n\n    var currentPos = Cartesian3.clone(positions[0], fromPointsCurrentPos);\n\n    var xMin = Cartesian3.clone(currentPos, fromPointsXMin);\n    var yMin = Cartesian3.clone(currentPos, fromPointsYMin);\n    var zMin = Cartesian3.clone(currentPos, fromPointsZMin);\n\n    var xMax = Cartesian3.clone(currentPos, fromPointsXMax);\n    var yMax = Cartesian3.clone(currentPos, fromPointsYMax);\n    var zMax = Cartesian3.clone(currentPos, fromPointsZMax);\n\n    var i;\n    for (i = 1; i < numPositions; i++) {\n        Cartesian3.clone(positions[i], currentPos);\n\n        var x = currentPos.x;\n        var y = currentPos.y;\n        var z = currentPos.z;\n\n        // Store points containing the the smallest and largest components\n        if (x < xMin.x) {\n            Cartesian3.clone(currentPos, xMin);\n        }\n\n        if (x > xMax.x) {\n            Cartesian3.clone(currentPos, xMax);\n        }\n\n        if (y < yMin.y) {\n            Cartesian3.clone(currentPos, yMin);\n        }\n\n        if (y > yMax.y) {\n            Cartesian3.clone(currentPos, yMax);\n        }\n\n        if (z < zMin.z) {\n            Cartesian3.clone(currentPos, zMin);\n        }\n\n        if (z > zMax.z) {\n            Cartesian3.clone(currentPos, zMax);\n        }\n    }\n\n    // Compute x-, y-, and z-spans (Squared distances b/n each component's min. and max.).\n    var xSpan = Cartesian3.magnitudeSquared(Cartesian3.subtract(xMax, xMin, fromPointsScratch));\n    var ySpan = Cartesian3.magnitudeSquared(Cartesian3.subtract(yMax, yMin, fromPointsScratch));\n    var zSpan = Cartesian3.magnitudeSquared(Cartesian3.subtract(zMax, zMin, fromPointsScratch));\n\n    // Set the diameter endpoints to the largest span.\n    var diameter1 = xMin;\n    var diameter2 = xMax;\n    var maxSpan = xSpan;\n    if (ySpan > maxSpan) {\n        maxSpan = ySpan;\n        diameter1 = yMin;\n        diameter2 = yMax;\n    }\n    if (zSpan > maxSpan) {\n        maxSpan = zSpan;\n        diameter1 = zMin;\n        diameter2 = zMax;\n    }\n\n    // Calculate the center of the initial sphere found by Ritter's algorithm\n    var ritterCenter = fromPointsRitterCenter;\n    ritterCenter.x = (diameter1.x + diameter2.x) * 0.5;\n    ritterCenter.y = (diameter1.y + diameter2.y) * 0.5;\n    ritterCenter.z = (diameter1.z + diameter2.z) * 0.5;\n\n    // Calculate the radius of the initial sphere found by Ritter's algorithm\n    var radiusSquared = Cartesian3.magnitudeSquared(Cartesian3.subtract(diameter2, ritterCenter, fromPointsScratch));\n    var ritterRadius = Math.sqrt(radiusSquared);\n\n    // Find the center of the sphere found using the Naive method.\n    var minBoxPt = fromPointsMinBoxPt;\n    minBoxPt.x = xMin.x;\n    minBoxPt.y = yMin.y;\n    minBoxPt.z = zMin.z;\n\n    var maxBoxPt = fromPointsMaxBoxPt;\n    maxBoxPt.x = xMax.x;\n    maxBoxPt.y = yMax.y;\n    maxBoxPt.z = zMax.z;\n\n    var naiveCenter = Cartesian3.midpoint(minBoxPt, maxBoxPt, fromPointsNaiveCenterScratch);\n\n    // Begin 2nd pass to find naive radius and modify the ritter sphere.\n    var naiveRadius = 0;\n    for (i = 0; i < numPositions; i++) {\n        Cartesian3.clone(positions[i], currentPos);\n\n        // Find the furthest point from the naive center to calculate the naive radius.\n        var r = Cartesian3.magnitude(Cartesian3.subtract(currentPos, naiveCenter, fromPointsScratch));\n        if (r > naiveRadius) {\n            naiveRadius = r;\n        }\n\n        // Make adjustments to the Ritter Sphere to include all points.\n        var oldCenterToPointSquared = Cartesian3.magnitudeSquared(Cartesian3.subtract(currentPos, ritterCenter, fromPointsScratch));\n        if (oldCenterToPointSquared > radiusSquared) {\n            var oldCenterToPoint = Math.sqrt(oldCenterToPointSquared);\n            // Calculate new radius to include the point that lies outside\n            ritterRadius = (ritterRadius + oldCenterToPoint) * 0.5;\n            radiusSquared = ritterRadius * ritterRadius;\n            // Calculate center of new Ritter sphere\n            var oldToNew = oldCenterToPoint - ritterRadius;\n            ritterCenter.x = (ritterRadius * ritterCenter.x + oldToNew * currentPos.x) / oldCenterToPoint;\n            ritterCenter.y = (ritterRadius * ritterCenter.y + oldToNew * currentPos.y) / oldCenterToPoint;\n            ritterCenter.z = (ritterRadius * ritterCenter.z + oldToNew * currentPos.z) / oldCenterToPoint;\n        }\n    }\n\n    if (ritterRadius < naiveRadius) {\n        Cartesian3.clone(ritterCenter, result.center);\n        result.radius = ritterRadius;\n    } else {\n        Cartesian3.clone(naiveCenter, result.center);\n        result.radius = naiveRadius;\n    }\n\n    return result;\n};\n\n/**\n * å¤æ­ä¸¤ä¸ªç¹æ¯å¦ç¸äº¤\n * @param {BoundingSphere} boundingLeft\n * @param {BoundingSphere} boundingRight\n * @returns {Boolean}\n */\n    BoundingSphere.isIntersect = function(boundingLeft, boundingRight){\n        let distance = Cartesian3.distance(boundingLeft.center, boundingRight.center);\n        if (distance > boundingLeft.radius + boundingRight.radius){\n            return false;\n        }\n        return true;\n    };\n/**\n * åä¸ä¸ªåå´çæ¯å¦å¨åä¸ä¸ªåå´çåé¨\n * @param {BoundingSphere} boundingOuter\n * @param {BoundingSphere} boundingInner\n * @returns {Boolean}\n */\n    BoundingSphere.isInclude = function(boundingOuter, boundingInner){\n        let distance = Cartesian3.distance(boundingOuter.center, boundingInner.center);\n        if ( boundingOuter.radius > distance + boundingInner.radius){\n            return true;\n        }\n        return false;\n    };\n\n    var defaultProjection = new GeographicProjection();\n    var fromRectangle2DLowerLeft = new Cartesian3();\n    var fromRectangle2DUpperRight = new Cartesian3();\n    var fromRectangle2DSouthwest = new Cartographic();\n    var fromRectangle2DNortheast = new Cartographic();\n\n    /**\n     * Computes a bounding sphere from a rectangle projected in 2D.\n     *\n     * @param {Rectangle} [rectangle] The rectangle around which to create a bounding sphere.\n     * @param {Object} [projection=GeographicProjection] The projection used to project the rectangle into 2D.\n     * @param {BoundingSphere} [result] The object onto which to store the result.\n     * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n     */\n    BoundingSphere.fromRectangle2D = function(rectangle, projection, result) {\n        return BoundingSphere.fromRectangleWithHeights2D(rectangle, projection, 0.0, 0.0, result);\n    };\n\n    /**\n     * Computes a bounding sphere from a rectangle projected in 2D.  The bounding sphere accounts for the\n     * object's minimum and maximum heights over the rectangle.\n     *\n     * @param {Rectangle} [rectangle] The rectangle around which to create a bounding sphere.\n     * @param {Object} [projection=GeographicProjection] The projection used to project the rectangle into 2D.\n     * @param {Number} [minimumHeight=0.0] The minimum height over the rectangle.\n     * @param {Number} [maximumHeight=0.0] The maximum height over the rectangle.\n     * @param {BoundingSphere} [result] The object onto which to store the result.\n     * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n     */\n    BoundingSphere.fromRectangleWithHeights2D = function(rectangle, projection, minimumHeight, maximumHeight, result) {\n        if (!defined(result)) {\n            result = new BoundingSphere();\n        }\n\n        if (!defined(rectangle)) {\n            result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);\n            result.radius = 0.0;\n            return result;\n        }\n\n        projection = defaultValue(projection, defaultProjection);\n\n        Rectangle.southwest(rectangle, fromRectangle2DSouthwest);\n        fromRectangle2DSouthwest.height = minimumHeight;\n        Rectangle.northeast(rectangle, fromRectangle2DNortheast);\n        fromRectangle2DNortheast.height = maximumHeight;\n\n        var lowerLeft = projection.project(fromRectangle2DSouthwest, fromRectangle2DLowerLeft);\n        var upperRight = projection.project(fromRectangle2DNortheast, fromRectangle2DUpperRight);\n\n        var width = upperRight.x - lowerLeft.x;\n        var height = upperRight.y - lowerLeft.y;\n        var elevation = upperRight.z - lowerLeft.z;\n\n        result.radius = Math.sqrt(width * width + height * height + elevation * elevation) * 0.5;\n        var center = result.center;\n        center.x = lowerLeft.x + width * 0.5;\n        center.y = lowerLeft.y + height * 0.5;\n        center.z = lowerLeft.z + elevation * 0.5;\n        return result;\n    };\n\n    var fromRectangle3DScratch = [];\n\n    /**\n     * Computes a bounding sphere from a rectangle in 3D. The bounding sphere is created using a subsample of points\n     * on the ellipsoid and contained in the rectangle. It may not be accurate for all rectangles on all types of ellipsoids.\n     *\n     * @param {Rectangle} [rectangle] The valid rectangle used to create a bounding sphere.\n     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid used to determine positions of the rectangle.\n     * @param {Number} [surfaceHeight=0.0] The height above the surface of the ellipsoid.\n     * @param {BoundingSphere} [result] The object onto which to store the result.\n     * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n     */\n    BoundingSphere.fromRectangle3D = function(rectangle, ellipsoid, surfaceHeight, result) {\n        ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n        surfaceHeight = defaultValue(surfaceHeight, 0.0);\n\n        if (!defined(result)) {\n            result = new BoundingSphere();\n        }\n\n        if (!defined(rectangle)) {\n            result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);\n            result.radius = 0.0;\n            return result;\n        }\n\n        var positions = Rectangle.subsample(rectangle, ellipsoid, surfaceHeight, fromRectangle3DScratch);\n        return BoundingSphere.fromPoints(positions, result);\n    };\n\n    /**\n     * Computes a tight-fitting bounding sphere enclosing a list of 3D points, where the points are\n     * stored in a flat array in X, Y, Z, order.  The bounding sphere is computed by running two\n     * algorithms, a naive algorithm and Ritter's algorithm. The smaller of the two spheres is used to\n     * ensure a tight fit.\n     *\n     * @param {Number[]} [positions] An array of points that the bounding sphere will enclose.  Each point\n     *        is formed from three elements in the array in the order X, Y, Z.\n     * @param {Cartesian3} [center=Cartesian3.ZERO] The position to which the positions are relative, which need not be the\n     *        origin of the coordinate system.  This is useful when the positions are to be used for\n     *        relative-to-center (RTC) rendering.\n     * @param {Number} [stride=3] The number of array elements per vertex.  It must be at least 3, but it may\n     *        be higher.  Regardless of the value of this parameter, the X coordinate of the first position\n     *        is at array index 0, the Y coordinate is at array index 1, and the Z coordinate is at array index\n     *        2.  When stride is 3, the X coordinate of the next position then begins at array index 3.  If\n     *        the stride is 5, however, two array elements are skipped and the next position begins at array\n     *        index 5.\n     * @param {BoundingSphere} [result] The object onto which to store the result.\n     * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if one was not provided.\n     *\n     * @example\n     * // Compute the bounding sphere from 3 positions, each specified relative to a center.\n     * // In addition to the X, Y, and Z coordinates, the points array contains two additional\n     * // elements per point which are ignored for the purpose of computing the bounding sphere.\n     * var center = new Cesium.Cartesian3(1.0, 2.0, 3.0);\n     * var points = [1.0, 2.0, 3.0, 0.1, 0.2,\n     *               4.0, 5.0, 6.0, 0.1, 0.2,\n     *               7.0, 8.0, 9.0, 0.1, 0.2];\n     * var sphere = Cesium.BoundingSphere.fromVertices(points, center, 5);\n     *\n     * @see {@link http://blogs.agi.com/insight3d/index.php/2008/02/04/a-bounding/|Bounding Sphere computation article}\n     */\n    BoundingSphere.fromVertices = function(positions, center, stride, result) {\n        if (!defined(result)) {\n            result = new BoundingSphere();\n        }\n\n        if (!defined(positions) || positions.length === 0) {\n            result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);\n            result.radius = 0.0;\n            return result;\n        }\n\n        center = defaultValue(center, Cartesian3.ZERO);\n\n        stride = defaultValue(stride, 3);\n\n        //>>includeStart('debug', pragmas.debug);\n        Check.typeOf.number.greaterThanOrEquals('stride', stride, 3);\n        //>>includeEnd('debug');\n\n        var currentPos = fromPointsCurrentPos;\n        currentPos.x = positions[0] + center.x;\n        currentPos.y = positions[1] + center.y;\n        currentPos.z = positions[2] + center.z;\n\n        var xMin = Cartesian3.clone(currentPos, fromPointsXMin);\n        var yMin = Cartesian3.clone(currentPos, fromPointsYMin);\n        var zMin = Cartesian3.clone(currentPos, fromPointsZMin);\n\n        var xMax = Cartesian3.clone(currentPos, fromPointsXMax);\n        var yMax = Cartesian3.clone(currentPos, fromPointsYMax);\n        var zMax = Cartesian3.clone(currentPos, fromPointsZMax);\n\n        var numElements = positions.length;\n        var i;\n        for (i = 0; i < numElements; i += stride) {\n            var x = positions[i] + center.x;\n            var y = positions[i + 1] + center.y;\n            var z = positions[i + 2] + center.z;\n\n            currentPos.x = x;\n            currentPos.y = y;\n            currentPos.z = z;\n\n            // Store points containing the the smallest and largest components\n            if (x < xMin.x) {\n                Cartesian3.clone(currentPos, xMin);\n            }\n\n            if (x > xMax.x) {\n                Cartesian3.clone(currentPos, xMax);\n            }\n\n            if (y < yMin.y) {\n                Cartesian3.clone(currentPos, yMin);\n            }\n\n            if (y > yMax.y) {\n                Cartesian3.clone(currentPos, yMax);\n            }\n\n            if (z < zMin.z) {\n                Cartesian3.clone(currentPos, zMin);\n            }\n\n            if (z > zMax.z) {\n                Cartesian3.clone(currentPos, zMax);\n            }\n        }\n\n        // Compute x-, y-, and z-spans (Squared distances b/n each component's min. and max.).\n        var xSpan = Cartesian3.magnitudeSquared(Cartesian3.subtract(xMax, xMin, fromPointsScratch));\n        var ySpan = Cartesian3.magnitudeSquared(Cartesian3.subtract(yMax, yMin, fromPointsScratch));\n        var zSpan = Cartesian3.magnitudeSquared(Cartesian3.subtract(zMax, zMin, fromPointsScratch));\n\n        // Set the diameter endpoints to the largest span.\n        var diameter1 = xMin;\n        var diameter2 = xMax;\n        var maxSpan = xSpan;\n        if (ySpan > maxSpan) {\n            maxSpan = ySpan;\n            diameter1 = yMin;\n            diameter2 = yMax;\n        }\n        if (zSpan > maxSpan) {\n            maxSpan = zSpan;\n            diameter1 = zMin;\n            diameter2 = zMax;\n        }\n\n        // Calculate the center of the initial sphere found by Ritter's algorithm\n        var ritterCenter = fromPointsRitterCenter;\n        ritterCenter.x = (diameter1.x + diameter2.x) * 0.5;\n        ritterCenter.y = (diameter1.y + diameter2.y) * 0.5;\n        ritterCenter.z = (diameter1.z + diameter2.z) * 0.5;\n\n        // Calculate the radius of the initial sphere found by Ritter's algorithm\n        var radiusSquared = Cartesian3.magnitudeSquared(Cartesian3.subtract(diameter2, ritterCenter, fromPointsScratch));\n        var ritterRadius = Math.sqrt(radiusSquared);\n\n        // Find the center of the sphere found using the Naive method.\n        var minBoxPt = fromPointsMinBoxPt;\n        minBoxPt.x = xMin.x;\n        minBoxPt.y = yMin.y;\n        minBoxPt.z = zMin.z;\n\n        var maxBoxPt = fromPointsMaxBoxPt;\n        maxBoxPt.x = xMax.x;\n        maxBoxPt.y = yMax.y;\n        maxBoxPt.z = zMax.z;\n\n        var naiveCenter = Cartesian3.midpoint(minBoxPt, maxBoxPt, fromPointsNaiveCenterScratch);\n\n        // Begin 2nd pass to find naive radius and modify the ritter sphere.\n        var naiveRadius = 0;\n        for (i = 0; i < numElements; i += stride) {\n            currentPos.x = positions[i] + center.x;\n            currentPos.y = positions[i + 1] + center.y;\n            currentPos.z = positions[i + 2] + center.z;\n\n            // Find the furthest point from the naive center to calculate the naive radius.\n            var r = Cartesian3.magnitude(Cartesian3.subtract(currentPos, naiveCenter, fromPointsScratch));\n            if (r > naiveRadius) {\n                naiveRadius = r;\n            }\n\n            // Make adjustments to the Ritter Sphere to include all points.\n            var oldCenterToPointSquared = Cartesian3.magnitudeSquared(Cartesian3.subtract(currentPos, ritterCenter, fromPointsScratch));\n            if (oldCenterToPointSquared > radiusSquared) {\n                var oldCenterToPoint = Math.sqrt(oldCenterToPointSquared);\n                // Calculate new radius to include the point that lies outside\n                ritterRadius = (ritterRadius + oldCenterToPoint) * 0.5;\n                radiusSquared = ritterRadius * ritterRadius;\n                // Calculate center of new Ritter sphere\n                var oldToNew = oldCenterToPoint - ritterRadius;\n                ritterCenter.x = (ritterRadius * ritterCenter.x + oldToNew * currentPos.x) / oldCenterToPoint;\n                ritterCenter.y = (ritterRadius * ritterCenter.y + oldToNew * currentPos.y) / oldCenterToPoint;\n                ritterCenter.z = (ritterRadius * ritterCenter.z + oldToNew * currentPos.z) / oldCenterToPoint;\n            }\n        }\n\n        if (ritterRadius < naiveRadius) {\n            Cartesian3.clone(ritterCenter, result.center);\n            result.radius = ritterRadius;\n        } else {\n            Cartesian3.clone(naiveCenter, result.center);\n            result.radius = naiveRadius;\n        }\n\n        return result;\n    };\n\n    /**\n     * Computes a tight-fitting bounding sphere enclosing a list of EncodedCartesian3s, where the points are\n     * stored in parallel flat arrays in X, Y, Z, order.  The bounding sphere is computed by running two\n     * algorithms, a naive algorithm and Ritter's algorithm. The smaller of the two spheres is used to\n     * ensure a tight fit.\n     *\n     * @param {Number[]} [positionsHigh] An array of high bits of the encoded cartesians that the bounding sphere will enclose.  Each point\n     *        is formed from three elements in the array in the order X, Y, Z.\n     * @param {Number[]} [positionsLow] An array of low bits of the encoded cartesians that the bounding sphere will enclose.  Each point\n     *        is formed from three elements in the array in the order X, Y, Z.\n     * @param {BoundingSphere} [result] The object onto which to store the result.\n     * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if one was not provided.\n     *\n     * @see {@link http://blogs.agi.com/insight3d/index.php/2008/02/04/a-bounding/|Bounding Sphere computation article}\n     */\n    BoundingSphere.fromEncodedCartesianVertices = function(positionsHigh, positionsLow, result) {\n        if (!defined(result)) {\n            result = new BoundingSphere();\n        }\n\n        if (!defined(positionsHigh) || !defined(positionsLow) || positionsHigh.length !== positionsLow.length || positionsHigh.length === 0) {\n            result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);\n            result.radius = 0.0;\n            return result;\n        }\n\n        var currentPos = fromPointsCurrentPos;\n        currentPos.x = positionsHigh[0] + positionsLow[0];\n        currentPos.y = positionsHigh[1] + positionsLow[1];\n        currentPos.z = positionsHigh[2] + positionsLow[2];\n\n        var xMin = Cartesian3.clone(currentPos, fromPointsXMin);\n        var yMin = Cartesian3.clone(currentPos, fromPointsYMin);\n        var zMin = Cartesian3.clone(currentPos, fromPointsZMin);\n\n        var xMax = Cartesian3.clone(currentPos, fromPointsXMax);\n        var yMax = Cartesian3.clone(currentPos, fromPointsYMax);\n        var zMax = Cartesian3.clone(currentPos, fromPointsZMax);\n\n        var numElements = positionsHigh.length;\n        var i;\n        for (i = 0; i < numElements; i += 3) {\n            var x = positionsHigh[i] + positionsLow[i];\n            var y = positionsHigh[i + 1] + positionsLow[i + 1];\n            var z = positionsHigh[i + 2] + positionsLow[i + 2];\n\n            currentPos.x = x;\n            currentPos.y = y;\n            currentPos.z = z;\n\n            // Store points containing the the smallest and largest components\n            if (x < xMin.x) {\n                Cartesian3.clone(currentPos, xMin);\n            }\n\n            if (x > xMax.x) {\n                Cartesian3.clone(currentPos, xMax);\n            }\n\n            if (y < yMin.y) {\n                Cartesian3.clone(currentPos, yMin);\n            }\n\n            if (y > yMax.y) {\n                Cartesian3.clone(currentPos, yMax);\n            }\n\n            if (z < zMin.z) {\n                Cartesian3.clone(currentPos, zMin);\n            }\n\n            if (z > zMax.z) {\n                Cartesian3.clone(currentPos, zMax);\n            }\n        }\n\n        // Compute x-, y-, and z-spans (Squared distances b/n each component's min. and max.).\n        var xSpan = Cartesian3.magnitudeSquared(Cartesian3.subtract(xMax, xMin, fromPointsScratch));\n        var ySpan = Cartesian3.magnitudeSquared(Cartesian3.subtract(yMax, yMin, fromPointsScratch));\n        var zSpan = Cartesian3.magnitudeSquared(Cartesian3.subtract(zMax, zMin, fromPointsScratch));\n\n        // Set the diameter endpoints to the largest span.\n        var diameter1 = xMin;\n        var diameter2 = xMax;\n        var maxSpan = xSpan;\n        if (ySpan > maxSpan) {\n            maxSpan = ySpan;\n            diameter1 = yMin;\n            diameter2 = yMax;\n        }\n        if (zSpan > maxSpan) {\n            maxSpan = zSpan;\n            diameter1 = zMin;\n            diameter2 = zMax;\n        }\n\n        // Calculate the center of the initial sphere found by Ritter's algorithm\n        var ritterCenter = fromPointsRitterCenter;\n        ritterCenter.x = (diameter1.x + diameter2.x) * 0.5;\n        ritterCenter.y = (diameter1.y + diameter2.y) * 0.5;\n        ritterCenter.z = (diameter1.z + diameter2.z) * 0.5;\n\n        // Calculate the radius of the initial sphere found by Ritter's algorithm\n        var radiusSquared = Cartesian3.magnitudeSquared(Cartesian3.subtract(diameter2, ritterCenter, fromPointsScratch));\n        var ritterRadius = Math.sqrt(radiusSquared);\n\n        // Find the center of the sphere found using the Naive method.\n        var minBoxPt = fromPointsMinBoxPt;\n        minBoxPt.x = xMin.x;\n        minBoxPt.y = yMin.y;\n        minBoxPt.z = zMin.z;\n\n        var maxBoxPt = fromPointsMaxBoxPt;\n        maxBoxPt.x = xMax.x;\n        maxBoxPt.y = yMax.y;\n        maxBoxPt.z = zMax.z;\n\n        var naiveCenter = Cartesian3.midpoint(minBoxPt, maxBoxPt, fromPointsNaiveCenterScratch);\n\n        // Begin 2nd pass to find naive radius and modify the ritter sphere.\n        var naiveRadius = 0;\n        for (i = 0; i < numElements; i += 3) {\n            currentPos.x = positionsHigh[i] + positionsLow[i];\n            currentPos.y = positionsHigh[i + 1] + positionsLow[i + 1];\n            currentPos.z = positionsHigh[i + 2] + positionsLow[i + 2];\n\n            // Find the furthest point from the naive center to calculate the naive radius.\n            var r = Cartesian3.magnitude(Cartesian3.subtract(currentPos, naiveCenter, fromPointsScratch));\n            if (r > naiveRadius) {\n                naiveRadius = r;\n            }\n\n            // Make adjustments to the Ritter Sphere to include all points.\n            var oldCenterToPointSquared = Cartesian3.magnitudeSquared(Cartesian3.subtract(currentPos, ritterCenter, fromPointsScratch));\n            if (oldCenterToPointSquared > radiusSquared) {\n                var oldCenterToPoint = Math.sqrt(oldCenterToPointSquared);\n                // Calculate new radius to include the point that lies outside\n                ritterRadius = (ritterRadius + oldCenterToPoint) * 0.5;\n                radiusSquared = ritterRadius * ritterRadius;\n                // Calculate center of new Ritter sphere\n                var oldToNew = oldCenterToPoint - ritterRadius;\n                ritterCenter.x = (ritterRadius * ritterCenter.x + oldToNew * currentPos.x) / oldCenterToPoint;\n                ritterCenter.y = (ritterRadius * ritterCenter.y + oldToNew * currentPos.y) / oldCenterToPoint;\n                ritterCenter.z = (ritterRadius * ritterCenter.z + oldToNew * currentPos.z) / oldCenterToPoint;\n            }\n        }\n\n        if (ritterRadius < naiveRadius) {\n            Cartesian3.clone(ritterCenter, result.center);\n            result.radius = ritterRadius;\n        } else {\n            Cartesian3.clone(naiveCenter, result.center);\n            result.radius = naiveRadius;\n        }\n\n        return result;\n    };\n\n    /**\n     * Computes a bounding sphere from the corner points of an axis-aligned bounding box.  The sphere\n     * tighly and fully encompases the box.\n     *\n     * @param {Cartesian3} [corner] The minimum height over the rectangle.\n     * @param {Cartesian3} [oppositeCorner] The maximum height over the rectangle.\n     * @param {BoundingSphere} [result] The object onto which to store the result.\n     * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n     *\n     * @example\n     * // Create a bounding sphere around the unit cube\n     * var sphere = Cesium.BoundingSphere.fromCornerPoints(new Cesium.Cartesian3(-0.5, -0.5, -0.5), new Cesium.Cartesian3(0.5, 0.5, 0.5));\n     */\n    BoundingSphere.fromCornerPoints = function(corner, oppositeCorner, result) {\n        //>>includeStart('debug', pragmas.debug);\n        Check.typeOf.object('corner', corner);\n        Check.typeOf.object('oppositeCorner', oppositeCorner);\n        //>>includeEnd('debug');\n\n        if (!defined(result)) {\n            result = new BoundingSphere();\n        }\n\n        var center = Cartesian3.midpoint(corner, oppositeCorner, result.center);\n        result.radius = Cartesian3.distance(center, oppositeCorner);\n        return result;\n    };\n\n    /**\n     * Creates a bounding sphere encompassing an ellipsoid.\n     *\n     * @param {Ellipsoid} ellipsoid The ellipsoid around which to create a bounding sphere.\n     * @param {BoundingSphere} [result] The object onto which to store the result.\n     * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n     *\n     * @example\n     * var boundingSphere = Cesium.BoundingSphere.fromEllipsoid(ellipsoid);\n     */\n    BoundingSphere.fromEllipsoid = function(ellipsoid, result) {\n        //>>includeStart('debug', pragmas.debug);\n        Check.typeOf.object('ellipsoid', ellipsoid);\n        //>>includeEnd('debug');\n\n        if (!defined(result)) {\n            result = new BoundingSphere();\n        }\n\n        Cartesian3.clone(Cartesian3.ZERO, result.center);\n        result.radius = ellipsoid.maximumRadius;\n        return result;\n    };\n\n    var fromBoundingSpheresScratch = new Cartesian3();\n\n    /**\n     * Computes a tight-fitting bounding sphere enclosing the provided array of bounding spheres.\n     *\n     * @param {BoundingSphere[]} [boundingSpheres] The array of bounding spheres.\n     * @param {BoundingSphere} [result] The object onto which to store the result.\n     * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n     */\n    BoundingSphere.fromBoundingSpheres = function(boundingSpheres, result) {\n        if (!defined(result)) {\n            result = new BoundingSphere();\n        }\n\n        if (!defined(boundingSpheres) || boundingSpheres.length === 0) {\n            result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);\n            result.radius = 0.0;\n            return result;\n        }\n\n        var length = boundingSpheres.length;\n        if (length === 1) {\n            return BoundingSphere.clone(boundingSpheres[0], result);\n        }\n\n        if (length === 2) {\n            return BoundingSphere.union(boundingSpheres[0], boundingSpheres[1], result);\n        }\n\n        var positions = [];\n        var i;\n        for (i = 0; i < length; i++) {\n            positions.push(boundingSpheres[i].center);\n        }\n\n        result = BoundingSphere.fromPoints(positions, result);\n\n        var center = result.center;\n        var radius = result.radius;\n        for (i = 0; i < length; i++) {\n            var tmp = boundingSpheres[i];\n            radius = Math.max(radius, Cartesian3.distance(center, tmp.center, fromBoundingSpheresScratch) + tmp.radius);\n        }\n        result.radius = radius;\n\n        return result;\n    };\n\n    var fromOrientedBoundingBoxScratchU = new Cartesian3();\n    var fromOrientedBoundingBoxScratchV = new Cartesian3();\n    var fromOrientedBoundingBoxScratchW = new Cartesian3();\n\n    /**\n     * Computes a tight-fitting bounding sphere enclosing the provided oriented bounding box.\n     *\n     * @param {OrientedBoundingBox} orientedBoundingBox The oriented bounding box.\n     * @param {BoundingSphere} [result] The object onto which to store the result.\n     * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n     */\n    BoundingSphere.fromOrientedBoundingBox = function(orientedBoundingBox, result) {\n        //>>includeStart('debug', pragmas.debug);\n        Check.defined('orientedBoundingBox', orientedBoundingBox);\n        //>>includeEnd('debug');\n\n        if (!defined(result)) {\n            result = new BoundingSphere();\n        }\n\n        var halfAxes = orientedBoundingBox.halfAxes;\n        var u = Matrix3.getColumn(halfAxes, 0, fromOrientedBoundingBoxScratchU);\n        var v = Matrix3.getColumn(halfAxes, 1, fromOrientedBoundingBoxScratchV);\n        var w = Matrix3.getColumn(halfAxes, 2, fromOrientedBoundingBoxScratchW);\n\n        Cartesian3.add(u, v, u);\n        Cartesian3.add(u, w, u);\n\n        result.center = Cartesian3.clone(orientedBoundingBox.center, result.center);\n        result.radius = Cartesian3.magnitude(u);\n\n        return result;\n    };\n\n    /**\n     * Duplicates a BoundingSphere instance.\n     *\n     * @param {BoundingSphere} sphere The bounding sphere to duplicate.\n     * @param {BoundingSphere} [result] The object onto which to store the result.\n     * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided. (Returns undefined if sphere is undefined)\n     */\n    BoundingSphere.clone = function(sphere, result) {\n        if (!defined(sphere)) {\n            return undefined;\n        }\n\n        if (!defined(result)) {\n            return new BoundingSphere(sphere.center, sphere.radius);\n        }\n\n        result.center = Cartesian3.clone(sphere.center, result.center);\n        result.radius = sphere.radius;\n        return result;\n    };\n\n    /**\n     * The number of elements used to pack the object into an array.\n     * @type {Number}\n     */\n    BoundingSphere.packedLength = 4;\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {BoundingSphere} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    BoundingSphere.pack = function(value, array, startingIndex) {\n        //>>includeStart('debug', pragmas.debug);\n        Check.typeOf.object('value', value);\n        Check.defined('array', array);\n        //>>includeEnd('debug');\n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var center = value.center;\n        array[startingIndex++] = center.x;\n        array[startingIndex++] = center.y;\n        array[startingIndex++] = center.z;\n        array[startingIndex] = value.radius;\n\n        return array;\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {BoundingSphere} [result] The object into which to store the result.\n     * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if one was not provided.\n     */\n    BoundingSphere.unpack = function(array, startingIndex, result) {\n        //>>includeStart('debug', pragmas.debug);\n        Check.defined('array', array);\n        //>>includeEnd('debug');\n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        if (!defined(result)) {\n            result = new BoundingSphere();\n        }\n\n        var center = result.center;\n        center.x = array[startingIndex++];\n        center.y = array[startingIndex++];\n        center.z = array[startingIndex++];\n        result.radius = array[startingIndex];\n        return result;\n    };\n\n    var unionScratch = new Cartesian3();\n    var unionScratchCenter = new Cartesian3();\n    /**\n     * Computes a bounding sphere that contains both the left and right bounding spheres.\n     *\n     * @param {BoundingSphere} left A sphere to enclose in a bounding sphere.\n     * @param {BoundingSphere} right A sphere to enclose in a bounding sphere.\n     * @param {BoundingSphere} [result] The object onto which to store the result.\n     * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n     */\n    BoundingSphere.union = function(left, right, result) {\n        //>>includeStart('debug', pragmas.debug);\n        Check.typeOf.object('left', left);\n        Check.typeOf.object('right', right);\n        //>>includeEnd('debug');\n\n        if (!defined(result)) {\n            result = new BoundingSphere();\n        }\n\n        var leftCenter = left.center;\n        var leftRadius = left.radius;\n        var rightCenter = right.center;\n        var rightRadius = right.radius;\n\n        var toRightCenter = Cartesian3.subtract(rightCenter, leftCenter, unionScratch);\n        var centerSeparation = Cartesian3.magnitude(toRightCenter);\n\n        if (leftRadius >= (centerSeparation + rightRadius)) {\n            // Left sphere wins.\n            left.clone(result);\n            return result;\n        }\n\n        if (rightRadius >= (centerSeparation + leftRadius)) {\n            // Right sphere wins.\n            right.clone(result);\n            return result;\n        }\n\n        // There are two tangent points, one on far side of each sphere.\n        var halfDistanceBetweenTangentPoints = (leftRadius + centerSeparation + rightRadius) * 0.5;\n\n        // Compute the center point halfway between the two tangent points.\n        var center = Cartesian3.multiplyByScalar(toRightCenter,\n                (-leftRadius + halfDistanceBetweenTangentPoints) / centerSeparation, unionScratchCenter);\n        Cartesian3.add(center, leftCenter, center);\n        Cartesian3.clone(center, result.center);\n        result.radius = halfDistanceBetweenTangentPoints;\n\n        return result;\n    };\n\n    var expandScratch = new Cartesian3();\n    /**\n     * å°boundingSphereåä¸ä¸ªæ¹åè¿è¡ç§»å¨ï¼åæ¶æ©å¤§å¶åå¾ï¼ä½¿å¶ä¸­å¿ç¹è¾¾å°è¿ä¸ªæ¹ååè·ç¦»çä¸­å¿ï¼åæ¶åæ¬ä¹åçä½ç½®\n     *\n     * @param {BoundingSphere} sphere A sphere to expand.\n     * @param {number} distance A distance to expand.\n     * @param {Cartesian3} direction A point to enclose in a bounding sphere.\n     * @param {BoundingSphere} [result] The object onto which to store the result.\n     * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n     */\n    BoundingSphere.expandDistance = function(sphere, distance, direction, result) {\n        Cartesian3.multiplyByScalar(direction, distance, expandScratch);\n        let center = result.center;\n        Cartesian3.add(center, expandScratch, center);\n        result.radius = Math.sqrt(sphere.radius * sphere.radius + distance * distance);\n        return result;\n    };\n\n    /**\n     * Computes a bounding sphere by enlarging the provided sphere to contain the provided point.\n     *\n     * @param {BoundingSphere} sphere A sphere to expand.\n     * @param {Cartesian3} point A point to enclose in a bounding sphere.\n     * @param {BoundingSphere} [result] The object onto which to store the result.\n     * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n     */\n    BoundingSphere.expand = function(sphere, point, result) {\n        //>>includeStart('debug', pragmas.debug);\n        Check.typeOf.object('sphere', sphere);\n        Check.typeOf.object('point', point);\n        //>>includeEnd('debug');\n\n        result = BoundingSphere.clone(sphere, result);\n\n        var radius = Cartesian3.magnitude(Cartesian3.subtract(point, result.center, expandScratch));\n        if (radius > result.radius) {\n            result.radius = radius;\n        }\n\n        return result;\n    };\n\n    /**\n     * Determines which side of a plane a sphere is located.\n     *\n     * @param {BoundingSphere} sphere The bounding sphere to test.\n     * @param {Plane} plane The plane to test against.\n     * @returns {Intersect} {@link Intersect.INSIDE} if the entire sphere is on the side of the plane\n     *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire sphere is\n     *                      on the opposite side, and {@link Intersect.INTERSECTING} if the sphere\n     *                      intersects the plane.\n     */\n    BoundingSphere.intersectPlane = function(sphere, plane) {\n        //>>includeStart('debug', pragmas.debug);\n        Check.typeOf.object('sphere', sphere);\n        Check.typeOf.object('plane', plane);\n        //>>includeEnd('debug');\n\n        var center = sphere.center;\n        var radius = sphere.radius;\n        var normal = plane.normal;\n        var distanceToPlane = Cartesian3.dot(normal, center) + plane.distance;\n\n        if (distanceToPlane < -radius) {\n            // The center point is negative side of the plane normal\n            return Intersect.OUTSIDE;\n        } else if (distanceToPlane < radius) {\n            // The center point is positive side of the plane, but radius extends beyond it; partial overlap\n            return Intersect.INTERSECTING;\n        }\n        return Intersect.INSIDE;\n    };\n\n    /**\n     * Applies a 4x4 affine transformation matrix to a bounding sphere.\n     *\n     * @param {BoundingSphere} sphere The bounding sphere to apply the transformation to.\n     * @param {Matrix4} transform The transformation matrix to apply to the bounding sphere.\n     * @param {BoundingSphere} [result] The object onto which to store the result.\n     * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n     */\n    BoundingSphere.transform = function(sphere, transform, result) {\n        //>>includeStart('debug', pragmas.debug);\n        Check.typeOf.object('sphere', sphere);\n        Check.typeOf.object('transform', transform);\n        //>>includeEnd('debug');\n\n        if (!defined(result)) {\n            result = new BoundingSphere();\n        }\n\n        result.center = Matrix4.multiplyByPoint(transform, sphere.center, result.center);\n        result.radius = Matrix4.getMaximumScale(transform) * sphere.radius;\n\n        return result;\n    };\n\n    var distanceSquaredToScratch = new Cartesian3();\n\n    /**\n     * Computes the estimated distance squared from the closest point on a bounding sphere to a point.\n     *\n     * @param {BoundingSphere} sphere The sphere.\n     * @param {Cartesian3} cartesian The point\n     * @returns {Number} The estimated distance squared from the bounding sphere to the point.\n     *\n     * @example\n     * // Sort bounding spheres from back to front\n     * spheres.sort(function(a, b) {\n     *     return Cesium.BoundingSphere.distanceSquaredTo(b, camera.positionWC) - Cesium.BoundingSphere.distanceSquaredTo(a, camera.positionWC);\n     * });\n     */\n    BoundingSphere.distanceSquaredTo = function(sphere, cartesian) {\n        //>>includeStart('debug', pragmas.debug);\n        Check.typeOf.object('sphere', sphere);\n        Check.typeOf.object('cartesian', cartesian);\n        //>>includeEnd('debug');\n\n        var diff = Cartesian3.subtract(sphere.center, cartesian, distanceSquaredToScratch);\n        return Cartesian3.magnitudeSquared(diff) - sphere.radius * sphere.radius;\n    };\n\n    /**\n     * Applies a 4x4 affine transformation matrix to a bounding sphere where there is no scale\n     * The transformation matrix is not verified to have a uniform scale of 1.\n     * This method is faster than computing the general bounding sphere transform using {@link BoundingSphere.transform}.\n     *\n     * @param {BoundingSphere} sphere The bounding sphere to apply the transformation to.\n     * @param {Matrix4} transform The transformation matrix to apply to the bounding sphere.\n     * @param {BoundingSphere} [result] The object onto which to store the result.\n     * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n     *\n     * @example\n     * var modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(positionOnEllipsoid);\n     * var boundingSphere = new Cesium.BoundingSphere();\n     * var newBoundingSphere = Cesium.BoundingSphere.transformWithoutScale(boundingSphere, modelMatrix);\n     */\n    BoundingSphere.transformWithoutScale = function(sphere, transform, result) {\n        //>>includeStart('debug', pragmas.debug);\n        Check.typeOf.object('sphere', sphere);\n        Check.typeOf.object('transform', transform);\n        //>>includeEnd('debug');\n\n        if (!defined(result)) {\n            result = new BoundingSphere();\n        }\n\n        result.center = Matrix4.multiplyByPoint(transform, sphere.center, result.center);\n        result.radius = sphere.radius;\n\n        return result;\n    };\n\n    var scratchCartesian3 = new Cartesian3();\n    /**\n     * The distances calculated by the vector from the center of the bounding sphere to position projected onto direction\n     * plus/minus the radius of the bounding sphere.\n     * <br>\n     * If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the\n     * closest and farthest planes from position that intersect the bounding sphere.\n     *\n     * @param {BoundingSphere} sphere The bounding sphere to calculate the distance to.\n     * @param {Cartesian3} position The position to calculate the distance from.\n     * @param {Cartesian3} direction The direction from position.\n     * @param {Interval} [result] A Interval to store the nearest and farthest distances.\n     * @returns {Interval} The nearest and farthest distances on the bounding sphere from position in direction.\n     */\n    BoundingSphere.computePlaneDistances = function(sphere, position, direction, result) {\n        //>>includeStart('debug', pragmas.debug);\n        Check.typeOf.object('sphere', sphere);\n        Check.typeOf.object('position', position);\n        Check.typeOf.object('direction', direction);\n        //>>includeEnd('debug');\n\n        if (!defined(result)) {\n            result = new Interval();\n        }\n\n        var toCenter = Cartesian3.subtract(sphere.center, position, scratchCartesian3);\n        var mag = Cartesian3.dot(direction, toCenter);\n\n        result.start = mag - sphere.radius;\n        result.stop = mag + sphere.radius;\n        return result;\n    };\n\n    var projectTo2DNormalScratch = new Cartesian3();\n    var projectTo2DEastScratch = new Cartesian3();\n    var projectTo2DNorthScratch = new Cartesian3();\n    var projectTo2DWestScratch = new Cartesian3();\n    var projectTo2DSouthScratch = new Cartesian3();\n    var projectTo2DCartographicScratch = new Cartographic();\n    var projectTo2DPositionsScratch = new Array(8);\n    for (var n = 0; n < 8; ++n) {\n        projectTo2DPositionsScratch[n] = new Cartesian3();\n    }\n\n    var projectTo2DProjection = new GeographicProjection();\n    /**\n     * Creates a bounding sphere in 2D from a bounding sphere in 3D world coordinates.\n     *\n     * @param {BoundingSphere} sphere The bounding sphere to transform to 2D.\n     * @param {Object} [projection=GeographicProjection] The projection to 2D.\n     * @param {BoundingSphere} [result] The object onto which to store the result.\n     * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n     */\n    BoundingSphere.projectTo2D = function(sphere, projection, result) {\n        //>>includeStart('debug', pragmas.debug);\n        Check.typeOf.object('sphere', sphere);\n        //>>includeEnd('debug');\n\n        projection = defaultValue(projection, projectTo2DProjection);\n\n        var ellipsoid = projection.ellipsoid;\n        var center = sphere.center;\n        var radius = sphere.radius;\n\n        var normal;\n        if (Cartesian3.equals(center, Cartesian3.ZERO)) {\n            // Bounding sphere is at the center. The geodetic surface normal is not\n            // defined here so pick the x-axis as a fallback.\n            normal = Cartesian3.clone(Cartesian3.UNIT_X, projectTo2DNormalScratch);\n        } else {\n            normal = ellipsoid.geodeticSurfaceNormal(center, projectTo2DNormalScratch);\n        }\n        var east = Cartesian3.cross(Cartesian3.UNIT_Z, normal, projectTo2DEastScratch);\n        Cartesian3.normalize(east, east);\n        var north = Cartesian3.cross(normal, east, projectTo2DNorthScratch);\n        Cartesian3.normalize(north, north);\n\n        Cartesian3.multiplyByScalar(normal, radius, normal);\n        Cartesian3.multiplyByScalar(north, radius, north);\n        Cartesian3.multiplyByScalar(east, radius, east);\n\n        var south = Cartesian3.negate(north, projectTo2DSouthScratch);\n        var west = Cartesian3.negate(east, projectTo2DWestScratch);\n\n        var positions = projectTo2DPositionsScratch;\n\n        // top NE corner\n        var corner = positions[0];\n        Cartesian3.add(normal, north, corner);\n        Cartesian3.add(corner, east, corner);\n\n        // top NW corner\n        corner = positions[1];\n        Cartesian3.add(normal, north, corner);\n        Cartesian3.add(corner, west, corner);\n\n        // top SW corner\n        corner = positions[2];\n        Cartesian3.add(normal, south, corner);\n        Cartesian3.add(corner, west, corner);\n\n        // top SE corner\n        corner = positions[3];\n        Cartesian3.add(normal, south, corner);\n        Cartesian3.add(corner, east, corner);\n\n        Cartesian3.negate(normal, normal);\n\n        // bottom NE corner\n        corner = positions[4];\n        Cartesian3.add(normal, north, corner);\n        Cartesian3.add(corner, east, corner);\n\n        // bottom NW corner\n        corner = positions[5];\n        Cartesian3.add(normal, north, corner);\n        Cartesian3.add(corner, west, corner);\n\n        // bottom SW corner\n        corner = positions[6];\n        Cartesian3.add(normal, south, corner);\n        Cartesian3.add(corner, west, corner);\n\n        // bottom SE corner\n        corner = positions[7];\n        Cartesian3.add(normal, south, corner);\n        Cartesian3.add(corner, east, corner);\n\n        var length = positions.length;\n        for (var i = 0; i < length; ++i) {\n            var position = positions[i];\n            Cartesian3.add(center, position, position);\n            var cartographic = ellipsoid.cartesianToCartographic(position, projectTo2DCartographicScratch);\n            projection.project(cartographic, position);\n        }\n\n        result = BoundingSphere.fromPoints(positions, result);\n\n        // swizzle center components\n        center = result.center;\n        var x = center.x;\n        var y = center.y;\n        var z = center.z;\n        center.x = z;\n        center.y = x;\n        center.z = y;\n\n        return result;\n    };\n\n    /**\n     * Determines whether or not a sphere is hidden from view by the occluder.\n     *\n     * @param {BoundingSphere} sphere The bounding sphere surrounding the occludee object.\n     * @param {Occluder} occluder The occluder.\n     * @returns {Boolean} <code>true</code> if the sphere is not visible; otherwise <code>false</code>.\n     */\n    BoundingSphere.isOccluded = function(sphere, occluder) {\n        //>>includeStart('debug', pragmas.debug);\n        Check.typeOf.object('sphere', sphere);\n        Check.typeOf.object('occluder', occluder);\n        //>>includeEnd('debug');\n        return !occluder.isBoundingSphereVisible(sphere);\n    };\n\n    /**\n     * Compares the provided BoundingSphere componentwise and returns\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\n     *\n     * @param {BoundingSphere} [left] The first BoundingSphere.\n     * @param {BoundingSphere} [right] The second BoundingSphere.\n     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n     */\n    BoundingSphere.equals = function(left, right) {\n        return (left === right) ||\n               ((defined(left)) &&\n                (defined(right)) &&\n                Cartesian3.equals(left.center, right.center) &&\n                left.radius === right.radius);\n    };\n\n    /**\n     * Determines which side of a plane the sphere is located.\n     *\n     * @param {Plane} plane The plane to test against.\n     * @returns {Intersect} {@link Intersect.INSIDE} if the entire sphere is on the side of the plane\n     *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire sphere is\n     *                      on the opposite side, and {@link Intersect.INTERSECTING} if the sphere\n     *                      intersects the plane.\n     */\n    BoundingSphere.prototype.intersectPlane = function(plane) {\n        return BoundingSphere.intersectPlane(this, plane);\n    };\n\n    /**\n     * Computes the estimated distance squared from the closest point on a bounding sphere to a point.\n     *\n     * @param {Cartesian3} cartesian The point\n     * @returns {Number} The estimated distance squared from the bounding sphere to the point.\n     *\n     * @example\n     * // Sort bounding spheres from back to front\n     * spheres.sort(function(a, b) {\n     *     return b.distanceSquaredTo(camera.positionWC) - a.distanceSquaredTo(camera.positionWC);\n     * });\n     */\n    BoundingSphere.prototype.distanceSquaredTo = function(cartesian) {\n        return BoundingSphere.distanceSquaredTo(this, cartesian);\n    };\n\n    /**\n     * The distances calculated by the vector from the center of the bounding sphere to position projected onto direction\n     * plus/minus the radius of the bounding sphere.\n     * <br>\n     * If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the\n     * closest and farthest planes from position that intersect the bounding sphere.\n     *\n     * @param {Cartesian3} position The position to calculate the distance from.\n     * @param {Cartesian3} direction The direction from position.\n     * @param {Interval} [result] A Interval to store the nearest and farthest distances.\n     * @returns {Interval} The nearest and farthest distances on the bounding sphere from position in direction.\n     */\n    BoundingSphere.prototype.computePlaneDistances = function(position, direction, result) {\n        return BoundingSphere.computePlaneDistances(this, position, direction, result);\n    };\n\n    /**\n     * Determines whether or not a sphere is hidden from view by the occluder.\n     *\n     * @param {Occluder} occluder The occluder.\n     * @returns {Boolean} <code>true</code> if the sphere is not visible; otherwise <code>false</code>.\n     */\n    BoundingSphere.prototype.isOccluded = function(occluder) {\n        return BoundingSphere.isOccluded(this, occluder);\n    };\n\n    /**\n     * Compares this BoundingSphere against the provided BoundingSphere componentwise and returns\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\n     *\n     * @param {BoundingSphere} [right] The right hand side BoundingSphere.\n     * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n     */\n    BoundingSphere.prototype.equals = function(right) {\n        return BoundingSphere.equals(this, right);\n    };\n\n    /**\n     * Duplicates this BoundingSphere instance.\n     *\n     * @param {BoundingSphere} [result] The object onto which to store the result.\n     * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n     */\n    BoundingSphere.prototype.clone = function(result) {\n        return BoundingSphere.clone(this, result);\n    };\n\n    /**\n     * Computes the radius of the BoundingSphere.\n     * @returns {Number} The radius of the BoundingSphere.\n     */\n    BoundingSphere.prototype.volume = function() {\n        var radius = this.radius;\n        return volumeConstant * radius * radius * radius;\n    };\n\n    /**\n     * get corner ary.\n     * @returns {Cartesian3[]} corner ary\n     */\n     BoundingSphere.prototype.getCornerAry = function() {\n        var corners = [];\n\n        var scratchCorner = new Cartesian3();\n\n        var u = new Cartesian3(this.radius, 0, 0);\n        var v = new Cartesian3(0, this.radius, 0);\n        var w = new Cartesian3(0, 0, this.radius);\n\n        // project first corner\n        var corner = Cartesian3.add(u, v, scratchCorner);\n        Cartesian3.add(corner, w, corner);\n        Cartesian3.add(corner, this.center, corner);\n\n        corners.push(corner.clone());\n\n        // project second corner\n        Cartesian3.add(this.center, u, corner);\n        Cartesian3.add(corner, v, corner);\n        Cartesian3.subtract(corner, w, corner);\n\n        corners.push(corner.clone());\n\n        // project third corner\n        Cartesian3.add(this.center, u, corner);\n        Cartesian3.subtract(corner, v, corner);\n        Cartesian3.add(corner, w, corner);\n\n        corners.push(corner.clone());\n\n        // project fourth corner\n        Cartesian3.add(this.center, u, corner);\n        Cartesian3.subtract(corner, v, corner);\n        Cartesian3.subtract(corner, w, corner);\n\n        corners.push(corner.clone());\n\n        // project fifth corner\n        Cartesian3.subtract(this.center, u, corner);\n        Cartesian3.add(corner, v, corner);\n        Cartesian3.add(corner, w, corner);\n\n        corners.push(corner.clone());\n\n        // project sixth corner\n        Cartesian3.subtract(this.center, u, corner);\n        Cartesian3.add(corner, v, corner);\n        Cartesian3.subtract(corner, w, corner);\n\n        corners.push(corner.clone());\n\n        // project seventh corner\n        Cartesian3.subtract(this.center, u, corner);\n        Cartesian3.subtract(corner, v, corner);\n        Cartesian3.add(corner, w, corner);\n\n        corners.push(corner.clone());\n\n        // project eighth corner\n        Cartesian3.subtract(this.center, u, corner);\n        Cartesian3.subtract(corner, v, corner);\n        Cartesian3.subtract(corner, w, corner);\n\n        corners.push(corner.clone());\n\n        return corners;\n    };\nexport default BoundingSphere;\n"],"names":["defaultValue","Ellipsoid","defined","Cartesian3","DeveloperError","Cartographic","CesiumMath","Rectangle","Check","Matrix3","Intersect","Matrix4"],"mappings":"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"}