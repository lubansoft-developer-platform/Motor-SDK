{"version":3,"file":"Plane-fdd70b9e.js","sources":["../../Source/Core/Plane.js"],"sourcesContent":["import Cartesian3 from './Cartesian3.js';\r\nimport Check from './Check.js';\r\nimport defined from './defined.js';\r\nimport DeveloperError from './DeveloperError.js';\r\nimport CesiumMath from './Math.js';\r\nimport Matrix4 from './Matrix4.js';\r\n\r\n    /**\r\n     * A plane in Hessian Normal Form defined by\r\n     * <pre>\r\n     * ax + by + cz + d = 0\r\n     * </pre>\r\n     * where (a, b, c) is the plane's <code>normal</code>, d is the signed\r\n     * <code>distance</code> to the plane, and (x, y, z) is any point on\r\n     * the plane.\r\n     *\r\n     * @alias Plane\r\n     * @constructor\r\n     *\r\n     * @param {Cartesian3} normal The plane's normal (normalized).\r\n     * @param {Number} distance The shortest distance from the origin to the plane.  The sign of\r\n     * <code>distance</code> determines which side of the plane the origin\r\n     * is on.  If <code>distance</code> is positive, the origin is in the half-space\r\n     * in the direction of the normal; if negative, the origin is in the half-space\r\n     * opposite to the normal; if zero, the plane passes through the origin.\r\n     *\r\n     * @example\r\n     * // The plane x=0\r\n     * var plane = new Cesium.Plane(Cesium.Cartesian3.UNIT_X, 0.0);\r\n     *\r\n     * @exception {DeveloperError} Normal must be normalized\r\n     */\r\n    function Plane(normal, distance) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('normal', normal);\r\n        if (!CesiumMath.equalsEpsilon(Cartesian3.magnitude(normal), 1.0, CesiumMath.EPSILON6)) {\r\n            throw new DeveloperError('normal must be normalized.');\r\n        }\r\n        Check.typeOf.number('distance', distance);\r\n        //>>includeEnd('debug');\r\n\r\n        /**\r\n         * The plane's normal.\r\n         *\r\n         * @type {Cartesian3}\r\n         */\r\n        this.normal = Cartesian3.clone(normal);\r\n\r\n        /**\r\n         * The shortest distance from the origin to the plane.  The sign of\r\n         * <code>distance</code> determines which side of the plane the origin\r\n         * is on.  If <code>distance</code> is positive, the origin is in the half-space\r\n         * in the direction of the normal; if negative, the origin is in the half-space\r\n         * opposite to the normal; if zero, the plane passes through the origin.\r\n         *\r\n         * @type {Number}\r\n         */\r\n        this.distance = distance;\r\n    }\r\n\r\n    // 对于一个平面上的点集，计算其按照clockwise的方向进行返回\r\n    Plane.computePositionClockWise = function(positions){\r\n        // 目前点集是默认的按照z = 0的xoy平面上的\r\n        let center = new Cartesian3();\r\n        positions.forEach(p=>{\r\n            Cartesian3.add(p, center, center);\r\n        });\r\n        Cartesian3.multiplyByScalar(center, 1 / positions.length, center);\r\n        let dirBase = Cartesian3.UNIT_Y;\r\n        let map = new Map();\r\n        let keys = [];\r\n        let scratchDirection = new Cartesian3();\r\n        positions.forEach(p=>{\r\n            Cartesian3.subtract(p, center, scratchDirection);\r\n            Cartesian3.normalize(scratchDirection, scratchDirection);\r\n            let angle = Cartesian3.dot(scratchDirection, dirBase);\r\n            if(Cartesian3.dot(Cartesian3.cross(dirBase, scratchDirection, scratchDirection), Cartesian3.UNIT_Z) < 0){\r\n                //顺时针排序，位于负半轴的情况下时\r\n                angle = -angle;\r\n                angle = angle - 2;\r\n            }\r\n            keys.push(angle);\r\n            map.set(angle, p);\r\n        });\r\n        keys.sort((a,b)=>a-b);\r\n        let results = [];\r\n        keys.forEach(k=>{\r\n            results.push(map.get(k));\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a plane from a normal and a point on the plane.\r\n     *\r\n     * @param {Cartesian3} point The point on the plane.\r\n     * @param {Cartesian3} normal The plane's normal (normalized).\r\n     * @param {Plane} [result] The object onto which to store the result.\r\n     * @returns {Plane} A new plane instance or the modified result parameter.\r\n     *\r\n     * @example\r\n     * var point = Cesium.Cartesian3.fromDegrees(-72.0, 40.0);\r\n     * var normal = ellipsoid.geodeticSurfaceNormal(point);\r\n     * var tangentPlane = Cesium.Plane.fromPointNormal(point, normal);\r\n     *\r\n     * @exception {DeveloperError} Normal must be normalized\r\n     */\r\n    Plane.fromPointNormal = function(point, normal, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('point', point);\r\n        Check.typeOf.object('normal', normal);\r\n        if (!CesiumMath.equalsEpsilon(Cartesian3.magnitude(normal), 1.0, CesiumMath.EPSILON6)) {\r\n            throw new DeveloperError('normal must be normalized.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var distance = -Cartesian3.dot(normal, point);\r\n\r\n        if (!defined(result)) {\r\n            return new Plane(normal, distance);\r\n        }\r\n\r\n        Cartesian3.clone(normal, result.normal);\r\n        result.distance = distance;\r\n        return result;\r\n    };\r\n\r\n    var scratchNormal = new Cartesian3();\r\n    /**\r\n     * Creates a plane from the general equation\r\n     *\r\n     * @param {Cartesian4} coefficients The plane's normal (normalized).\r\n     * @param {Plane} [result] The object onto which to store the result.\r\n     * @returns {Plane} A new plane instance or the modified result parameter.\r\n     *\r\n     * @exception {DeveloperError} Normal must be normalized\r\n     */\r\n    Plane.fromCartesian4 = function(coefficients, result) {\r\n        var normal = Cartesian3.fromCartesian4(coefficients, scratchNormal);\r\n        var distance = coefficients.w;\r\n\r\n        if (!defined(result)) {\r\n            return new Plane(normal, distance);\r\n        }\r\n        Cartesian3.clone(normal, result.normal);\r\n        result.distance = distance;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * 求平面与线段的交点，返回undefined或者某个点\r\n     *\r\n     * @param {Plane} plane 平面\r\n     * @param {Cartesian3} startPoint 线段端点\r\n     * @param {Cartesian3} endPoint 线段端点\r\n     * @return {Cartesian3 | undefined}\r\n     */\r\n    Plane.getIntersectWithLineSegment = function(plane, startPoint, endPoint){\r\n        let distance0 = Cartesian3.dot(plane.normal, startPoint) - plane.distance;\r\n        let distance1 = Cartesian3.dot(plane.normal, endPoint) - plane.distance;\r\n\r\n        if(distance0 * distance1 <= 0){\r\n            Cartesian3.subtract(startPoint, endPoint, scratchNormal);\r\n            //顶点在平面的两端，因而有交点\r\n            Cartesian3.normalize(scratchNormal, scratchNormal);\r\n            let angle = Cartesian3.dot(scratchNormal, plane.normal);\r\n            Cartesian3.multiplyByScalar(scratchNormal, -distance0 / angle, scratchNormal);\r\n            return Cartesian3.add(scratchNormal, startPoint, new Cartesian3());\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    /**\r\n     * Computes the signed shortest distance of a point to a plane.\r\n     * The sign of the distance determines which side of the plane the point\r\n     * is on.  If the distance is positive, the point is in the half-space\r\n     * in the direction of the normal; if negative, the point is in the half-space\r\n     * opposite to the normal; if zero, the plane passes through the point.\r\n     *\r\n     * @param {Plane} plane The plane.\r\n     * @param {Cartesian3} point The point.\r\n     * @returns {Number} The signed shortest distance of the point to the plane.\r\n     */\r\n    Plane.getPointDistance = function(plane, point) {\r\n        return Cartesian3.dot(plane.normal, point) + plane.distance;\r\n    };\r\n\r\n    var scratchCartesian = new Cartesian3();\r\n    /**\r\n     * Projects a point onto the plane.\r\n     * @param {Plane} plane The plane to project the point onto\r\n     * @param {Cartesian3} point The point to project onto the plane\r\n     * @param {Cartesian3} [result] The result point.  If undefined, a new Cartesian3 will be created.\r\n     * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\r\n     */\r\n    Plane.projectPointOntoPlane = function(plane, point, result) {\r\n        if (!defined(result)) {\r\n            result = new Cartesian3();\r\n        }\r\n\r\n        // projectedPoint = point - (normal.point + scale) * normal\r\n        var pointDistance = Plane.getPointDistance(plane, point);\r\n        var scaledNormal = Cartesian3.multiplyByScalar(plane.normal, pointDistance, scratchCartesian);\r\n\r\n        return Cartesian3.subtract(point, scaledNormal, result);\r\n    };\r\n    /**\r\n     * Projects a point onto the plane.\r\n     * @param {Plane} plane The plane to project the point onto\r\n     * @param {Cartesian3[]} points The point to project onto the plane\r\n     * @param {Cartesian3[]} [result] The result point.  If undefined, a new Cartesian3 will be created.\r\n     * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\r\n     */\r\n    Plane.projectPointsOntoPlane = function(plane, points, result) {\r\n        if (!defined(result)) {\r\n            result = [];\r\n        }\r\n        for(let i = 0; i < points.length; i++){\r\n            result[i] = Plane.projectPointOntoPlane(plane, points[i], result[i]);\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    var scratchPosition = new Cartesian3();\r\n    /**\r\n     * Transforms the plane by the given transformation matrix.\r\n     *\r\n     * @param {Plane} plane The plane.\r\n     * @param {Matrix4} transform The transformation matrix.\r\n     * @param {Plane} [result] The object into which to store the result.\r\n     * @returns {Plane} The plane transformed by the given transformation matrix.\r\n     */\r\n    Plane.transform = function(plane, transform, result) {\r\n        Matrix4.multiplyByPointAsVector(transform, plane.normal, scratchNormal);\r\n        Cartesian3.normalize(scratchNormal, scratchNormal);\r\n\r\n        Cartesian3.multiplyByScalar(plane.normal, -plane.distance, scratchPosition);\r\n        Matrix4.multiplyByPoint(transform, scratchPosition, scratchPosition);\r\n\r\n        return Plane.fromPointNormal(scratchPosition, scratchNormal, result);\r\n    };\r\n\r\n    /**\r\n     * Duplicates a Plane instance.\r\n     *\r\n     * @param {Plane} plane The plane to duplicate.\r\n     * @param {Plane} [result] The object onto which to store the result.\r\n     * @returns {Plane} The modified result parameter or a new Plane instance if one was not provided.\r\n     */\r\n    Plane.clone = function(plane, result) {\r\n        if (!defined(result)) {\r\n            return new Plane(plane.normal, plane.distance);\r\n        }\r\n\r\n        Cartesian3.clone(plane.normal, result.normal);\r\n        result.distance = plane.distance;\r\n\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Compares the provided Planes by normal and distance and returns\r\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\r\n     *\r\n     * @param {Plane} left The first plane.\r\n     * @param {Plane} right The second plane.\r\n     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\r\n     */\r\n    Plane.equals = function(left, right) {\r\n        return (left.distance === right.distance) && Cartesian3.equals(left.normal, right.normal);\r\n    };\r\n\r\n    /**\r\n     * A constant initialized to the XY plane passing through the origin, with normal in positive Z.\r\n     *\r\n     * @type {Plane}\r\n     * @constant\r\n     */\r\n    Plane.ORIGIN_XY_PLANE = Object.freeze(new Plane(Cartesian3.UNIT_Z, 0.0));\r\n\r\n    /**\r\n     * A constant initialized to the YZ plane passing through the origin, with normal in positive X.\r\n     *\r\n     * @type {Plane}\r\n     * @constant\r\n     */\r\n    Plane.ORIGIN_YZ_PLANE = Object.freeze(new Plane(Cartesian3.UNIT_X, 0.0));\r\n\r\n    /**\r\n     * A constant initialized to the ZX plane passing through the origin, with normal in positive Y.\r\n     *\r\n     * @type {Plane}\r\n     * @constant\r\n     */\r\n    Plane.ORIGIN_ZX_PLANE = Object.freeze(new Plane(Cartesian3.UNIT_Y, 0.0));\r\n    Plane.prototype.projectPointsOntoPlane = function(points, result){\r\n        return Plane.projectPointsOntoPlane(this, points, result);\r\n    }\r\n\r\n    Plane.fromPositions = function(positions){\r\n        // 取三个点，得到平面\r\n        if(positions.length < 3){\r\n            throw new Error(\"请输入至少三个点\")\r\n        }\r\n        let p0 = positions[0];\r\n        let p1 = positions[1];\r\n        let p2 = positions[2];\r\n        let v0 = Cartesian3.subtract(p0, p1, new Cartesian3());\r\n        let v1 = Cartesian3.subtract(p0, p2, new Cartesian3());\r\n        let normal = Cartesian3.cross(v0, v1, v1);\r\n        return Plane.fromPointNormal(Cartesian3.clone(p0, v0), normal);\r\n    }\r\nexport default Plane;\r\n"],"names":["Check","CesiumMath","Cartesian3","DeveloperError","defined","Matrix4"],"mappings":"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"}